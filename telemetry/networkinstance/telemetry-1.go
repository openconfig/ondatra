package networkinstance

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"reflect"
	"testing"
	"time"

	"github.com/openconfig/ondatra/internal/gnmigen/genutil"
	oc "github.com/openconfig/ondatra/telemetry"
	"github.com/openconfig/ygot/ygot"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/path-changes to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath extracts the value of the leaf PathChanges from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_PathChangesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PathChanges
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/counters/state-changes to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath extracts the value of the leaf StateChanges from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters_StateChangesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.StateChanges
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/description to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath extracts the value of the leaf Description from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_DescriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Description
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Lookup(t testing.TB) *oc.QualifiedInt32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Get(t testing.TB) int32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedInt32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedInt32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny) Get(t testing.TB) []int32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []int32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionInt32 {
	t.Helper()
	c := &oc.CollectionInt32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedInt32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedInt32) bool) *oc.Int32Watcher {
	t.Helper()
	w := &oc.Int32Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedInt32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedInt32) bool) *oc.Int32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Await(t testing.TB, timeout time.Duration, val int32) *oc.QualifiedInt32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedInt32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionInt32 {
	t.Helper()
	c := &oc.CollectionInt32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedInt32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedInt32) bool) *oc.Int32Watcher {
	t.Helper()
	w := &oc.Int32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedInt32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedInt32) bool) *oc.Int32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedInt32.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedInt32 {
	t.Helper()
	qv := &oc.QualifiedInt32{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetMetricType())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Get(t testing.TB) oc.E_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny) Get(t testing.TB) []oc.E_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_LSP_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE) bool) *oc.E_MplsTypes_LSP_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_METRIC_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE) bool) *oc.E_MplsTypes_LSP_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_LSP_METRIC_TYPE) *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE) bool) *oc.E_MplsTypes_LSP_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_METRIC_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE) bool) *oc.E_MplsTypes_LSP_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/metric-type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath extracts the value of the leaf MetricType from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_MetricTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_LSP_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.MetricType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath) Get(t testing.TB) oc.E_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_LSP_OPER_STATUS
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPathAny) Get(t testing.TB) []oc.E_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_LSP_OPER_STATUS
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_OPER_STATUS{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS) bool) *oc.E_MplsTypes_LSP_OPER_STATUSWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_OPER_STATUSWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_OPER_STATUS)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS) bool) *oc.E_MplsTypes_LSP_OPER_STATUSWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_LSP_OPER_STATUS) *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_OPER_STATUS{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS) bool) *oc.E_MplsTypes_LSP_OPER_STATUSWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_OPER_STATUSWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_OPER_STATUS)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS) bool) *oc.E_MplsTypes_LSP_OPER_STATUSWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/oper-status to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath extracts the value of the leaf OperStatus from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_OperStatusPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_LSP_OPER_STATUS {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_LSP_OPER_STATUS{
		Metadata: md,
	}
	val := parent.OperStatus
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/state/destination to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath extracts the value of the leaf Destination from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_DestinationPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Destination
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPathPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroupsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/exclude-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath extracts the value of the leaf ExcludeGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ExcludeGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-all-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath extracts the value of the leaf IncludeAllGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAllGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/admin-groups/state/include-any-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath extracts the value of the leaf IncludeAnyGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAnyGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath) Lookup(t testing.TB) *oc.QualifiedUint64Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath) Get(t testing.TB) []uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPathAny) Get(t testing.TB) [][]uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64Slice {
	t.Helper()
	c := &oc.CollectionUint64Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	w := &oc.Uint64SliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath) Await(t testing.TB, timeout time.Duration, val []uint64) *oc.QualifiedUint64Slice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64Slice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64Slice {
	t.Helper()
	c := &oc.CollectionUint64Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	w := &oc.Uint64SliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/associated-rsvp-sessions to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath extracts the value of the leaf AssociatedRsvpSessions from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64Slice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_AssociatedRsvpSessionsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint64Slice {
	t.Helper()
	qv := &oc.QualifiedUint64Slice{
		Metadata: md,
	}
	val := parent.AssociatedRsvpSessions
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPathPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/active to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath extracts the value of the leaf Active from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_ActivePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Active
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath extracts the value of the leaf Priority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_PriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Priority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/candidate-secondary-paths/candidate-secondary-path/state/secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath extracts the value of the leaf SecondaryPath from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath_SecondaryPathPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CandidateSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SecondaryPath
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath extracts the value of the leaf CspfMetric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.CspfMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}).SetVal(goStruct.GetCspfTiebreaker())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Get(t testing.TB) oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_CspfTieBreaking
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Get(t testing.TB) []oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_CspfTieBreaking
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	w := &oc.E_Mpls_CspfTieBreakingWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_CspfTieBreaking)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Await(t testing.TB, timeout time.Duration, val oc.E_Mpls_CspfTieBreaking) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	w := &oc.E_Mpls_CspfTieBreakingWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_CspfTieBreaking)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath extracts the value of the leaf CspfTiebreaker from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_CspfTieBreaking.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_CspfTiebreakerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}
	val := parent.CspfTiebreaker
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath extracts the value of the leaf ExplicitPathName from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_ExplicitPathNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ExplicitPathName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}).SetVal(goStruct.GetPathComputationMethod())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Get(t testing.TB) oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_COMPUTATION_METHOD
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath extracts the value of the leaf PathComputationMethod from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}
	val := parent.PathComputationMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath extracts the value of the leaf PathComputationServer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathComputationServerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.PathComputationServer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraintPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint64{
		Metadata: md,
	}).SetVal(goStruct.GetMetricUpperBound())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath extracts the value of the leaf MetricUpperBound from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MetricUpperBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Get(t testing.TB) oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_METRIC_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_METRIC_TYPE) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_METRIC_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PathMetricBoundConstraint) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath extracts the value of the leaf RetryTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_RetryTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RetryTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath extracts the value of the leaf SpfMetric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_SpfMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SpfMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-primary-path/p2p-primary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath extracts the value of the leaf UseCspf from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath_UseCspfPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PPrimaryPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.UseCspf
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPathPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroupsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/exclude-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath extracts the value of the leaf ExcludeGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_ExcludeGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ExcludeGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-all-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath extracts the value of the leaf IncludeAllGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAllGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAllGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/admin-groups/state/include-any-group to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath extracts the value of the leaf IncludeAnyGroup from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups_IncludeAnyGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AdminGroups) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.IncludeAnyGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Lookup(t testing.TB) *oc.QualifiedUint64Slice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Get(t testing.TB) []uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64Slice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64Slice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Get(t testing.TB) [][]uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64Slice {
	t.Helper()
	c := &oc.CollectionUint64Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	w := &oc.Uint64SliceWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Await(t testing.TB, timeout time.Duration, val []uint64) *oc.QualifiedUint64Slice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64Slice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64Slice {
	t.Helper()
	c := &oc.CollectionUint64Slice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64Slice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	w := &oc.Uint64SliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64Slice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64Slice) bool) *oc.Uint64SliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/associated-rsvp-sessions to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath extracts the value of the leaf AssociatedRsvpSessions from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64Slice.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_AssociatedRsvpSessionsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint64Slice {
	t.Helper()
	qv := &oc.QualifiedUint64Slice{
		Metadata: md,
	}
	val := parent.AssociatedRsvpSessions
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath extracts the value of the leaf CspfMetric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.CspfMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}).SetVal(goStruct.GetCspfTiebreaker())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Get(t testing.TB) oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_CspfTieBreaking
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Get(t testing.TB) []oc.E_Mpls_CspfTieBreaking {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_CspfTieBreaking
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	w := &oc.E_Mpls_CspfTieBreakingWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_CspfTieBreaking)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Await(t testing.TB, timeout time.Duration, val oc.E_Mpls_CspfTieBreaking) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_CspfTieBreaking {
	t.Helper()
	c := &oc.CollectionE_Mpls_CspfTieBreaking{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_CspfTieBreaking) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	w := &oc.E_Mpls_CspfTieBreakingWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_CspfTieBreaking)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_CspfTieBreaking) bool) *oc.E_Mpls_CspfTieBreakingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/cspf-tiebreaker to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath extracts the value of the leaf CspfTiebreaker from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_CspfTieBreaking.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_CspfTiebreakerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedE_Mpls_CspfTieBreaking {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_CspfTieBreaking{
		Metadata: md,
	}
	val := parent.CspfTiebreaker
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/explicit-path-name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath extracts the value of the leaf ExplicitPathName from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_ExplicitPathNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ExplicitPathName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetHoldPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/hold-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath extracts the value of the leaf HoldPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_HoldPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HoldPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}).SetVal(goStruct.GetPathComputationMethod())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Get(t testing.TB) oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_COMPUTATION_METHOD
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_COMPUTATION_METHOD) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_COMPUTATION_METHOD{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD) bool) *oc.E_MplsTypes_PATH_COMPUTATION_METHODWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-method to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath extracts the value of the leaf PathComputationMethod from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationMethodPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_COMPUTATION_METHOD{
		Metadata: md,
	}
	val := parent.PathComputationMethod
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/path-computation-server to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath extracts the value of the leaf PathComputationServer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathComputationServerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.PathComputationServer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) bool) *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraintPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint64{
		Metadata: md,
	}).SetVal(goStruct.GetMetricUpperBound())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/metric-upper-bound to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath extracts the value of the leaf MetricUpperBound from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_MetricUpperBoundPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MetricUpperBound
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Get(t testing.TB) oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_METRIC_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_METRIC_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_METRIC_TYPE) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_METRIC_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_METRIC_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE) bool) *oc.E_MplsTypes_PATH_METRIC_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/path-metric-bound-constraints/path-metric-bound-constraint/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PathMetricBoundConstraint) *oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_METRIC_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/retry-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath extracts the value of the leaf RetryTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_RetryTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RetryTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/spf-metric to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath extracts the value of the leaf SpfMetric from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_SpfMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SpfMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/p2p-tunnel-attributes/p2p-secondary-paths/p2p-secondary-path/state/use-cspf to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath extracts the value of the leaf UseCspf from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath_UseCspfPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_P2PTunnelAttributes_P2PSecondaryPath) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.UseCspf
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/preference to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath extracts the value of the leaf Preference from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_PreferencePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Preference
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetProtectionStyleRequested())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Get(t testing.TB) oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Get(t testing.TB) []oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PROTECTION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PROTECTION_TYPE) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath extracts the value of the leaf ProtectionStyleRequested from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PROTECTION_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ProtectionStyleRequestedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}
	val := parent.ProtectionStyleRequested
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/reoptimize-timer to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath extracts the value of the leaf ReoptimizeTimer from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ReoptimizeTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ReoptimizeTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Get(t testing.TB) oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_LSP_ROLE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Get(t testing.TB) []oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_LSP_ROLE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_ROLEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_ROLE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_LSP_ROLE) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_ROLEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_ROLE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/role to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath extracts the value of the leaf Role from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_LSP_ROLE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_RolePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_LSP_ROLE{
		Metadata: md,
	}
	val := parent.Role
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetSetupPriority())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/setup-priority to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath extracts the value of the leaf SetupPriority from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SetupPriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.SetupPriority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetShortcutEligible())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/shortcut-eligible to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath extracts the value of the leaf ShortcutEligible from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_ShortcutEligiblePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ShortcutEligible
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Get(t testing.TB) oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Get(t testing.TB) []oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PATH_SETUP_PROTOCOL
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PATH_SETUP_PROTOCOL) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOL{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/signaling-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath extracts the value of the leaf SignalingProtocol from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SignalingProtocolPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOL{
		Metadata: md,
	}
	val := parent.SignalingProtocol
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetSoftPreemption())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath extracts the value of the leaf SoftPreemption from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SoftPreemptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SoftPreemption
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/source to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath extracts the value of the leaf Source from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_SourcePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Source
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Get(t testing.TB) oc.E_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_TUNNEL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_TUNNEL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_TUNNEL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool) *oc.E_MplsTypes_TUNNEL_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_TUNNEL_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_TUNNEL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool) *oc.E_MplsTypes_TUNNEL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_TUNNEL_TYPE) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_TUNNEL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool) *oc.E_MplsTypes_TUNNEL_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_TUNNEL_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_TUNNEL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_TUNNEL_TYPE) bool) *oc.E_MplsTypes_TUNNEL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/constrained-path/tunnels/tunnel/state/type to the batch object.
func (n *NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_TUNNEL_TYPE.
func convertNetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_ConstrainedPath_Tunnel) *oc.QualifiedE_MplsTypes_TUNNEL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_TUNNEL_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLspPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLspPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLspPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLspWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLspPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLspPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_EgressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_EgressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Egress", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Egress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_IngressWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_IngressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Ingress", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/state/name to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_TransitWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_TransitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath extracts the value of the leaf IncomingLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union{
		Metadata: md,
	}
	val := parent.IncomingLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/next-hop to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath extracts the value of the leaf NextHop from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_NextHopPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NextHop
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_StaticLsp_Transit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union) bool) *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label to the batch object.
func (n *NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath extracts the value of the leaf PushLabel from its parent oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union.
func convertNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_Lsps_StaticLsp_Transit) *oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union{
		Metadata: md,
	}
	val := parent.PushLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPathPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPathPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPathWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPathPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocolPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a ONCE subscription.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher{}
	gs := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_Ldp) bool) *oc.NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/lsps/unconstrained-path/path-setup-protocol/ldp to the batch object.
func (n *NetworkInstance_Mpls_Lsps_UnconstrainedPath_PathSetupProtocol_LdpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocolsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool) *oc.NetworkInstance_Mpls_SignalingProtocolsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocolsWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool) *oc.NetworkInstance_Mpls_SignalingProtocolsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocolsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocolsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocolsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool) *oc.NetworkInstance_Mpls_SignalingProtocolsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocolsWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols) bool) *oc.NetworkInstance_Mpls_SignalingProtocolsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocolsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocolsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_LdpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_LdpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_LdpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_LdpWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_LdpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_LdpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_GlobalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestartPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/forwarding-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath extracts the value of the leaf ForwardingHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ForwardingHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ForwardingHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/helper-enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath extracts the value of the leaf HelperEnable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_HelperEnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HelperEnable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/reconnect-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath extracts the value of the leaf ReconnectTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_ReconnectTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ReconnectTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath extracts the value of the leaf RecoveryTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart_RecoveryTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_GracefulRestart) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RecoveryTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/global/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath extracts the value of the leaf LsrId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Global_LsrIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Global) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LsrId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamilyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Get(t testing.TB) oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_MplsLdpAfi
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Get(t testing.TB) []oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_MplsLdpAfi
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAfiWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAfi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_MplsLdpAfi) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAfiWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAfi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_MplsLdpAfi.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_MplsLdpAfi{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/address-families/address-family/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_AddressFamily) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_CountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/interface-attributes/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_InterfaceAttributes_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_NeighborPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacencyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Get(t testing.TB) oc.E_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Get(t testing.TB) []oc.E_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_MplsLdpAdjacencyType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAdjacencyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool) *oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool) *oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_MplsLdpAdjacencyType) *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAdjacencyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool) *oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType) bool) *oc.E_MplsLdp_MplsLdpAdjacencyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/adjacency-type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath extracts the value of the leaf AdjacencyType from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_AdjacencyTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_MplsLdpAdjacencyType{
		Metadata: md,
	}
	val := parent.AdjacencyType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-dropped to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath extracts the value of the leaf HelloDropped from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloDroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HelloDropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/adjacent to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath extracts the value of the leaf Adjacent from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_AdjacentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Adjacent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/hello-expiration to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath extracts the value of the leaf HelloExpiration from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_HelloExpirationPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HelloExpiration
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/negotiated to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath extracts the value of the leaf Negotiated from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NegotiatedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Negotiated
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/hello-holdtime/state/next-hello to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath extracts the value of the leaf NextHello from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime_NextHelloPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloHoldtime) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.NextHello
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/hello-received to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath extracts the value of the leaf HelloReceived from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_HelloReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HelloReceived
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/last-clear to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath extracts the value of the leaf LastClear from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LastClearPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LastClear
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath extracts the value of the leaf LocalAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_LocalAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LocalAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/hello-adjacencies/hello-adjacency/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath extracts the value of the leaf RemoteAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency_RemoteAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_HelloAdjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/label-space-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath extracts the value of the leaf LabelSpaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LabelSpaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.LabelSpaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/lsr-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath extracts the value of the leaf LsrId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_LsrIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LsrId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Get(t testing.TB) oc.E_MplsLdp_Neighbor_SessionState {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_Neighbor_SessionState
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Get(t testing.TB) []oc.E_MplsLdp_Neighbor_SessionState {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_Neighbor_SessionState
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_Neighbor_SessionState{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool) *oc.E_MplsLdp_Neighbor_SessionStateWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_Neighbor_SessionStateWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_Neighbor_SessionState)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool) *oc.E_MplsLdp_Neighbor_SessionStateWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_Neighbor_SessionState) *oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_Neighbor_SessionState{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool) *oc.E_MplsLdp_Neighbor_SessionStateWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_Neighbor_SessionStateWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_Neighbor_SessionState)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_Neighbor_SessionState) bool) *oc.E_MplsLdp_Neighbor_SessionStateWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/neighbors/neighbor/state/session-state to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath extracts the value of the leaf SessionState from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_Neighbor_SessionState.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor_SessionStatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Neighbor) *oc.QualifiedE_MplsLdp_Neighbor_SessionState {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_Neighbor_SessionState{
		Metadata: md,
	}
	val := parent.SessionState
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_TargetedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamilyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Get(t testing.TB) oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsLdp_MplsLdpAfi
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Get(t testing.TB) []oc.E_MplsLdp_MplsLdpAfi {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsLdp_MplsLdpAfi
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAfiWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAfi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsLdp_MplsLdpAfi) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsLdp_MplsLdpAfi {
	t.Helper()
	c := &oc.CollectionE_MplsLdp_MplsLdpAfi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	w := &oc.E_MplsLdp_MplsLdpAfiWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsLdp_MplsLdpAfi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsLdp_MplsLdpAfi) bool) *oc.E_MplsLdp_MplsLdpAfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/state/afi-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsLdp_MplsLdpAfi.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily) *oc.QualifiedE_MplsLdp_MplsLdpAfi {
	t.Helper()
	qv := &oc.QualifiedE_MplsLdp_MplsLdpAfi{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_TargetPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/enabled to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/local-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath extracts the value of the leaf LocalAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_LocalAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LocalAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/address-families/address-family/targets/target/state/remote-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath extracts the value of the leaf RemoteAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target_RemoteAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_AddressFamily_Target) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-accept to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath extracts the value of the leaf HelloAccept from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloAcceptPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HelloAccept
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-holdtime to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath extracts the value of the leaf HelloHoldtime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloHoldtimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloHoldtime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/ldp/targeted/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_Ldp_Targeted) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_GlobalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_CountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ErrorsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath extracts the value of the leaf AuthenticationFail from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_AuthenticationFailPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.AuthenticationFail
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath extracts the value of the leaf BadChecksum from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadChecksumPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadChecksum
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath extracts the value of the leaf BadPacketFormat from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketFormatPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketFormat
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath extracts the value of the leaf BadPacketLength from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_BadPacketLengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketLength
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath extracts the value of the leaf OutOfOrder from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_OutOfOrderPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOfOrder
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath extracts the value of the leaf ReceivedNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_ReceivedNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReceivedNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath extracts the value of the leaf TransmitFailure from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitFailurePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitFailure
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath extracts the value of the leaf TransmitQueueFull from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_TransmitQueueFullPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitQueueFull
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath extracts the value of the leaf UnknownAck from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownAckPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownAck
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath extracts the value of the leaf UnknownNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors_UnknownNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath extracts the value of the leaf InAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath extracts the value of the leaf InHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath extracts the value of the leaf InPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath extracts the value of the leaf InPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath extracts the value of the leaf InPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath extracts the value of the leaf InReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath extracts the value of the leaf InReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath extracts the value of the leaf InReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath extracts the value of the leaf InSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_InSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath extracts the value of the leaf OutAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath extracts the value of the leaf OutHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath extracts the value of the leaf OutPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath extracts the value of the leaf OutPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath extracts the value of the leaf OutPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath extracts the value of the leaf OutReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath extracts the value of the leaf OutReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath extracts the value of the leaf OutReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath extracts the value of the leaf OutSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_OutSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/path-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath extracts the value of the leaf PathTimeouts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_PathTimeoutsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.PathTimeouts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath extracts the value of the leaf RateLimitedMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_RateLimitedMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.RateLimitedMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/state/counters/reservation-timeouts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath extracts the value of the leaf ReservationTimeouts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters_ReservationTimeoutsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReservationTimeouts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestartPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/recovery-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath extracts the value of the leaf RecoveryTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RecoveryTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.RecoveryTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/graceful-restart/state/restart-time to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath extracts the value of the leaf RestartTime from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart_RestartTimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_GracefulRestart) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.RestartTime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_HellosPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetHelloInterval())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetRefreshReduction())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath extracts the value of the leaf RefreshReduction from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos_RefreshReductionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_Hellos) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RefreshReduction
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetSoftPreemptionTimeout())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/global/soft-preemption/state/soft-preemption-timeout to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath extracts the value of the leaf SoftPreemptionTimeout from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption_SoftPreemptionTimeoutPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Global_SoftPreemption) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.SoftPreemptionTimeout
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath) Get(t testing.TB) oc.E_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePathAny) Get(t testing.TB) []oc.E_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_RSVP_AUTH_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_RSVP_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE) bool) *oc.E_MplsTypes_RSVP_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_RSVP_AUTH_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE) bool) *oc.E_MplsTypes_RSVP_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_RSVP_AUTH_TYPE) *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_RSVP_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE) bool) *oc.E_MplsTypes_RSVP_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_RSVP_AUTH_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE) bool) *oc.E_MplsTypes_RSVP_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/authentication-type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath extracts the value of the leaf AuthenticationType from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_AuthenticationTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) *oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_RSVP_AUTH_TYPE{
		Metadata: md,
	}
	val := parent.AuthenticationType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnable())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/authentication/state/enable to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath extracts the value of the leaf Enable from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication_EnablePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enable
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/active-reservations-count to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath extracts the value of the leaf ActiveReservationsCount from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ActiveReservationsCountPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ActiveReservationsCount
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/available-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath extracts the value of the leaf AvailableBandwidth from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_AvailableBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.AvailableBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/highwater-mark to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath extracts the value of the leaf HighwaterMark from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_HighwaterMarkPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.HighwaterMark
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath extracts the value of the leaf Priority from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_PriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union{
		Metadata: md,
	}
	val := parent.Priority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/reserved-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath extracts the value of the leaf ReservedBandwidth from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_ReservedBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReservedBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_CountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_ErrorsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/authentication-fail to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath extracts the value of the leaf AuthenticationFail from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_AuthenticationFailPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.AuthenticationFail
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-checksum to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath extracts the value of the leaf BadChecksum from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadChecksumPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadChecksum
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-format to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath extracts the value of the leaf BadPacketFormat from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketFormatPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketFormat
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/bad-packet-length to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath extracts the value of the leaf BadPacketLength from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_BadPacketLengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.BadPacketLength
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/out-of-order to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath extracts the value of the leaf OutOfOrder from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_OutOfOrderPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOfOrder
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/received-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath extracts the value of the leaf ReceivedNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_ReceivedNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.ReceivedNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-failure to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath extracts the value of the leaf TransmitFailure from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitFailurePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitFailure
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/transmit-queue-full to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath extracts the value of the leaf TransmitQueueFull from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_TransmitQueueFullPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.TransmitQueueFull
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-ack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath extracts the value of the leaf UnknownAck from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownAckPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownAck
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/errors/unknown-nack to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath extracts the value of the leaf UnknownNack from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors_UnknownNackPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_Errors) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UnknownNack
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath extracts the value of the leaf InAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath extracts the value of the leaf InHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath extracts the value of the leaf InPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath extracts the value of the leaf InPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath extracts the value of the leaf InPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath extracts the value of the leaf InReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath extracts the value of the leaf InReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath extracts the value of the leaf InReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/in-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath extracts the value of the leaf InSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_InSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-ack-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath extracts the value of the leaf OutAckMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutAckMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutAckMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-hello-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath extracts the value of the leaf OutHelloMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutHelloMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutHelloMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath extracts the value of the leaf OutPathErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath extracts the value of the leaf OutPathMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-path-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath extracts the value of the leaf OutPathTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutPathTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPathTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-error-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath extracts the value of the leaf OutReservationErrorMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationErrorMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationErrorMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath extracts the value of the leaf OutReservationMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-reservation-tear-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath extracts the value of the leaf OutReservationTearMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutReservationTearMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutReservationTearMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/out-srefresh-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath extracts the value of the leaf OutSrefreshMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_OutSrefreshMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutSrefreshMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/counters/rate-limited-messages to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath extracts the value of the leaf RateLimitedMessages from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters_RateLimitedMessagesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Counters) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.RateLimitedMessages
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_HellosPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetHelloInterval())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/hello-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetRefreshReduction())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/hellos/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath extracts the value of the leaf RefreshReduction from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos_RefreshReductionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Hellos) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RefreshReduction
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/state/max-link-bandwidth to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath extracts the value of the leaf MaxLinkBandwidth from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_MaxLinkBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.MaxLinkBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_ProtectionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/bypass-optimize-interval to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath extracts the value of the leaf BypassOptimizeInterval from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_BypassOptimizeIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.BypassOptimizeInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}).SetVal(goStruct.GetLinkProtectionStyleRequested())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Get(t testing.TB) oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Get(t testing.TB) []oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PROTECTION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PROTECTION_TYPE) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/protection/state/link-protection-style-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath extracts the value of the leaf LinkProtectionStyleRequested from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PROTECTION_TYPE.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection_LinkProtectionStyleRequestedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Protection) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}
	val := parent.LinkProtectionStyleRequested
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_SubscriptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/calculated-absolute-subscription-bw to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath extracts the value of the leaf CalculatedAbsoluteSubscriptionBw from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_CalculatedAbsoluteSubscriptionBwPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.CalculatedAbsoluteSubscriptionBw
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/subscription/state/subscription to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath extracts the value of the leaf Subscription from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription_SubscriptionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_Subscription) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Subscription
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_NeighborPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/detected-interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath extracts the value of the leaf DetectedInterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_DetectedInterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.DetectedInterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Lookup(t testing.TB) *oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Get(t testing.TB) oc.E_Neighbor_NeighborStatus {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Neighbor_NeighborStatus
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Get(t testing.TB) []oc.E_Neighbor_NeighborStatus {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Neighbor_NeighborStatus
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Neighbor_NeighborStatus {
	t.Helper()
	c := &oc.CollectionE_Neighbor_NeighborStatus{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Neighbor_NeighborStatus) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Neighbor_NeighborStatus) bool) *oc.E_Neighbor_NeighborStatusWatcher {
	t.Helper()
	w := &oc.E_Neighbor_NeighborStatusWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Neighbor_NeighborStatus)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Neighbor_NeighborStatus) bool) *oc.E_Neighbor_NeighborStatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Await(t testing.TB, timeout time.Duration, val oc.E_Neighbor_NeighborStatus) *oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Neighbor_NeighborStatus) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Neighbor_NeighborStatus {
	t.Helper()
	c := &oc.CollectionE_Neighbor_NeighborStatus{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Neighbor_NeighborStatus) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Neighbor_NeighborStatus) bool) *oc.E_Neighbor_NeighborStatusWatcher {
	t.Helper()
	w := &oc.E_Neighbor_NeighborStatusWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Neighbor_NeighborStatus)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Neighbor_NeighborStatus) bool) *oc.E_Neighbor_NeighborStatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/neighbor-status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath extracts the value of the leaf NeighborStatus from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Neighbor_NeighborStatus.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_NeighborStatusPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedE_Neighbor_NeighborStatus {
	t.Helper()
	qv := &oc.QualifiedE_Neighbor_NeighborStatus{
		Metadata: md,
	}
	val := parent.NeighborStatus
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/neighbors/neighbor/state/refresh-reduction to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath extracts the value of the leaf RefreshReduction from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor_RefreshReductionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Neighbor) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RefreshReduction
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_SessionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/destination-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath extracts the value of the leaf DestinationAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_DestinationAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.DestinationAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObjectPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/asn to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath extracts the value of the leaf Asn from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_AsnPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Asn
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/ip-prefix to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath extracts the value of the leaf IpPrefix from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_IpPrefixPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.IpPrefix
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath extracts the value of the leaf Label from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union{
		Metadata: md,
	}
	val := parent.Label
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/loose to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath extracts the value of the leaf Loose from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_LoosePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Loose
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Lookup(t testing.TB) *oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Get(t testing.TB) oc.E_ExplicitRouteObject_Type {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_ExplicitRouteObject_Type
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Get(t testing.TB) []oc.E_ExplicitRouteObject_Type {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_ExplicitRouteObject_Type
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_ExplicitRouteObject_Type {
	t.Helper()
	c := &oc.CollectionE_ExplicitRouteObject_Type{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_ExplicitRouteObject_Type) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_ExplicitRouteObject_Type) bool) *oc.E_ExplicitRouteObject_TypeWatcher {
	t.Helper()
	w := &oc.E_ExplicitRouteObject_TypeWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_ExplicitRouteObject_Type)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_ExplicitRouteObject_Type) bool) *oc.E_ExplicitRouteObject_TypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_ExplicitRouteObject_Type) *oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_ExplicitRouteObject_Type) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_ExplicitRouteObject_Type {
	t.Helper()
	c := &oc.CollectionE_ExplicitRouteObject_Type{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_ExplicitRouteObject_Type) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_ExplicitRouteObject_Type) bool) *oc.E_ExplicitRouteObject_TypeWatcher {
	t.Helper()
	w := &oc.E_ExplicitRouteObject_TypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_ExplicitRouteObject_Type)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_ExplicitRouteObject_Type) bool) *oc.E_ExplicitRouteObject_TypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedE_ExplicitRouteObject_Type.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) *oc.QualifiedE_ExplicitRouteObject_Type {
	t.Helper()
	qv := &oc.QualifiedE_ExplicitRouteObject_Type{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath extracts the value of the leaf LabelIn from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelInPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union{
		Metadata: md,
	}
	val := parent.LabelIn
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath extracts the value of the leaf LabelOut from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOutPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union{
		Metadata: md,
	}
	val := parent.LabelOut
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/local-index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath extracts the value of the leaf LocalIndex from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LocalIndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LocalIndex
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/lsp-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath extracts the value of the leaf LspId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LspIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.LspId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Get(t testing.TB) oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PROTECTION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Get(t testing.TB) []oc.E_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_PROTECTION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_PROTECTION_TYPE) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PROTECTION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PROTECTION_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PROTECTION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PROTECTION_TYPE) bool) *oc.E_MplsTypes_PROTECTION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/protection-requested to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath extracts the value of the leaf ProtectionRequested from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PROTECTION_TYPE.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ProtectionRequestedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedE_MplsTypes_PROTECTION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PROTECTION_TYPE{
		Metadata: md,
	}
	val := parent.ProtectionRequested
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObjectPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/index to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-flags to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath extracts the value of the leaf ReportedFlags from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedFlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.ReportedFlags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath extracts the value of the leaf ReportedLabel from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union{
		Metadata: md,
	}
	val := parent.ReportedLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspecPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/peak-data-rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath extracts the value of the leaf PeakDataRate from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_PeakDataRatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.PeakDataRate
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/rate to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath extracts the value of the leaf Rate from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_RatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Rate
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Lookup(t testing.TB) *oc.QualifiedFloat32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Get(t testing.TB) float32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Lookup(t testing.TB) []*oc.QualifiedFloat32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedFloat32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Get(t testing.TB) []float32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []float32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Await(t testing.TB, timeout time.Duration, val float32) *oc.QualifiedFloat32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedFloat32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionFloat32 {
	t.Helper()
	c := &oc.CollectionFloat32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedFloat32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	w := &oc.Float32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedFloat32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedFloat32) bool) *oc.Float32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/sender-tspec/size to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath extracts the value of the leaf Size from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec
// and combines the update with an existing Metadata to return a *oc.QualifiedFloat32.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec_SizePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SenderTspec) *oc.QualifiedFloat32 {
	t.Helper()
	qv := &oc.QualifiedFloat32{
		Metadata: md,
	}
	val := parent.Size
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(ygot.BinaryToFloat32(val))
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/session-name to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath extracts the value of the leaf SessionName from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SessionNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SessionName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/source-address to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath extracts the value of the leaf SourceAddress from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_SourceAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SourceAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Lookup(t testing.TB) *oc.QualifiedE_Session_Status {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Get(t testing.TB) oc.E_Session_Status {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Session_Status {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Session_Status
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Get(t testing.TB) []oc.E_Session_Status {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Session_Status
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Session_Status {
	t.Helper()
	c := &oc.CollectionE_Session_Status{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Session_Status) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Session_Status) bool) *oc.E_Session_StatusWatcher {
	t.Helper()
	w := &oc.E_Session_StatusWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Session_Status)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Session_Status) bool) *oc.E_Session_StatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Await(t testing.TB, timeout time.Duration, val oc.E_Session_Status) *oc.QualifiedE_Session_Status {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Session_Status) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Session_Status {
	t.Helper()
	c := &oc.CollectionE_Session_Status{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Session_Status) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Session_Status) bool) *oc.E_Session_StatusWatcher {
	t.Helper()
	w := &oc.E_Session_StatusWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Session_Status)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Session_Status) bool) *oc.E_Session_StatusWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/status to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath extracts the value of the leaf Status from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Session_Status.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_StatusPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedE_Session_Status {
	t.Helper()
	qv := &oc.QualifiedE_Session_Status{
		Metadata: md,
	}
	val := parent.Status
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/tunnel-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath extracts the value of the leaf TunnelId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TunnelIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.TunnelId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Get(t testing.TB) oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_LSP_ROLE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Get(t testing.TB) []oc.E_MplsTypes_LSP_ROLE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_MplsTypes_LSP_ROLE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_ROLEWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_ROLE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_MplsTypes_LSP_ROLE) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_LSP_ROLE {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_LSP_ROLE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_LSP_ROLE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_LSP_ROLEWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_LSP_ROLE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_LSP_ROLE) bool) *oc.E_MplsTypes_LSP_ROLEWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/type to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_LSP_ROLE.
func convertNetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) *oc.QualifiedE_MplsTypes_LSP_ROLE {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_LSP_ROLE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRoutingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath extracts the value of the leaf MplsLabel from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union{
		Metadata: md,
	}
	val := parent.MplsLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClassPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/exp to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath extracts the value of the leaf Exp from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_ExpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Exp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/forwarding-classes/forwarding-class/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_ForwardingClass) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath extracts the value of the leaf InOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/in-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath extracts the value of the leaf InPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_InPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Get(t testing.TB) oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union) bool) *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath extracts the value of the leaf MplsLabel from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union{
		Metadata: md,
	}
	val := parent.MplsLabel
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-octets to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath extracts the value of the leaf OutOctets from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutOctetsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutOctets
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a ONCE subscription.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/out-pkts to the batch object.
func (n *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath extracts the value of the leaf OutPkts from its parent oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_OutPktsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.OutPkts
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_TeGlobalAttributes
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_TeGlobalAttributes)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_TeGlobalAttributes) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributesWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/admin-group-name to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath extracts the value of the leaf AdminGroupName from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_AdminGroupNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AdminGroupName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/mpls-admin-groups/admin-group/state/bit-position to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath extracts the value of the leaf BitPosition from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_TeGlobalAttributes_AdminGroup_BitPositionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_AdminGroup) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.BitPosition
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_SrlgWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_SrlgWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_SrlgWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_SrlgPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_SrlgWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_SrlgWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_SrlgWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_SrlgPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_SrlgPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/cost to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath extracts the value of the leaf Cost from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_CostPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Cost
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath) Lookup(t testing.TB) *oc.QualifiedE_Mpls_MplsSrlgFloodingType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath(t, md, goStruct)
	}
	return (&oc.QualifiedE_Mpls_MplsSrlgFloodingType{
		Metadata: md,
	}).SetVal(goStruct.GetFloodingType())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath) Get(t testing.TB) oc.E_Mpls_MplsSrlgFloodingType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_Mpls_MplsSrlgFloodingType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Mpls_MplsSrlgFloodingType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePathAny) Get(t testing.TB) []oc.E_Mpls_MplsSrlgFloodingType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Mpls_MplsSrlgFloodingType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_MplsSrlgFloodingType {
	t.Helper()
	c := &oc.CollectionE_Mpls_MplsSrlgFloodingType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_MplsSrlgFloodingType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_MplsSrlgFloodingType) bool) *oc.E_Mpls_MplsSrlgFloodingTypeWatcher {
	t.Helper()
	w := &oc.E_Mpls_MplsSrlgFloodingTypeWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_MplsSrlgFloodingType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_MplsSrlgFloodingType) bool) *oc.E_Mpls_MplsSrlgFloodingTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_Mpls_MplsSrlgFloodingType) *oc.QualifiedE_Mpls_MplsSrlgFloodingType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Mpls_MplsSrlgFloodingType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Mpls_MplsSrlgFloodingType {
	t.Helper()
	c := &oc.CollectionE_Mpls_MplsSrlgFloodingType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Mpls_MplsSrlgFloodingType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Mpls_MplsSrlgFloodingType) bool) *oc.E_Mpls_MplsSrlgFloodingTypeWatcher {
	t.Helper()
	w := &oc.E_Mpls_MplsSrlgFloodingTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Mpls_MplsSrlgFloodingType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Mpls_MplsSrlgFloodingType) bool) *oc.E_Mpls_MplsSrlgFloodingTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/flooding-type to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath extracts the value of the leaf FloodingType from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Mpls_MplsSrlgFloodingType.
func convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_FloodingTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg) *oc.QualifiedE_Mpls_MplsSrlgFloodingType {
	t.Helper()
	qv := &oc.QualifiedE_Mpls_MplsSrlgFloodingType{
		Metadata: md,
	}
	val := parent.FloodingType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersListPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/from-address to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath extracts the value of the leaf FromAddress from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_FromAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.FromAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/static-srlg-members/members-list/state/to-address to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath extracts the value of the leaf ToAddress from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList_ToAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg_MembersList) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.ToAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/name to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_Srlg", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/srlgs/srlg/state/value to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath extracts the value of the leaf Value from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Mpls_TeGlobalAttributes_Srlg_ValuePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_Srlg) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Value
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath) Get(t testing.TB) *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers)))
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersWatcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersWatcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) bool) *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/cleanup-delay to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath extracts the value of the leaf CleanupDelay from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_CleanupDelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.CleanupDelay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/install-delay to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath extracts the value of the leaf InstallDelay from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_InstallDelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.InstallDelay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a ONCE subscription.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/mpls/te-global-attributes/te-lsp-timers/state/reoptimize-timer to the batch object.
func (n *NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath extracts the value of the leaf ReoptimizeTimer from its parent oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers_ReoptimizeTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Mpls_TeGlobalAttributes_TeLspTimers) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.ReoptimizeTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/state/mtu with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_MtuPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_MtuPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/state/mtu with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_MtuPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/state/mtu with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_MtuPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_MtuPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/state/mtu with a ONCE subscription.
func (n *NetworkInstance_MtuPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/mtu with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_MtuPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_MtuPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_MtuPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/mtu with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_MtuPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_MtuPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/state/mtu with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_MtuPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/state/mtu failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/mtu to the batch object.
func (n *NetworkInstance_MtuPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/mtu with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_MtuPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_MtuPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_MtuPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/mtu with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_MtuPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_MtuPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/mtu to the batch object.
func (n *NetworkInstance_MtuPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_MtuPath extracts the value of the leaf Mtu from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_MtuPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Mtu
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/state/name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_NamePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance{}
	md, ok := oc.Lookup(t, n, "NetworkInstance", goStruct, true, false)
	if ok {
		return convertNetworkInstance_NamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/state/name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_NamePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/state/name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_NamePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_NamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/state/name with a ONCE subscription.
func (n *NetworkInstance_NamePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_NamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_NamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_NamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_NamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_NamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/state/name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_NamePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/state/name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/name to the batch object.
func (n *NetworkInstance_NamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/state/name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_NamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_NamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_NamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/state/name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_NamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_NamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/state/name to the batch object.
func (n *NetworkInstance_NamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_NamePath extracts the value of the leaf Name from its parent oc.NetworkInstance
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_NamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Name
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_PolicyForwardingPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_PolicyForwarding {
	t.Helper()
	goStruct := &oc.NetworkInstance_PolicyForwarding{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_PolicyForwarding", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_PolicyForwarding{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_PolicyForwardingPath) Get(t testing.TB) *oc.NetworkInstance_PolicyForwarding {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_PolicyForwardingPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_PolicyForwarding {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_PolicyForwarding
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_PolicyForwarding{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_PolicyForwarding", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_PolicyForwarding{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a ONCE subscription.
func (n *NetworkInstance_PolicyForwardingPathAny) Get(t testing.TB) []*oc.NetworkInstance_PolicyForwarding {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_PolicyForwarding
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_PolicyForwardingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_PolicyForwarding {
	t.Helper()
	c := &oc.CollectionNetworkInstance_PolicyForwarding{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_PolicyForwarding) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_PolicyForwarding{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_PolicyForwarding)))
		return false
	})
	return c
}

func watch_NetworkInstance_PolicyForwardingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_PolicyForwarding) bool) *oc.NetworkInstance_PolicyForwardingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_PolicyForwardingWatcher{}
	gs := &oc.NetworkInstance_PolicyForwarding{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_PolicyForwarding", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_PolicyForwarding{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_PolicyForwarding)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_PolicyForwardingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_PolicyForwarding) bool) *oc.NetworkInstance_PolicyForwardingWatcher {
	t.Helper()
	return watch_NetworkInstance_PolicyForwardingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_PolicyForwardingPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_PolicyForwarding) *oc.QualifiedNetworkInstance_PolicyForwarding {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_PolicyForwarding) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/policy-forwarding failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/policy-forwarding to the batch object.
func (n *NetworkInstance_PolicyForwardingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_PolicyForwardingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_PolicyForwarding {
	t.Helper()
	c := &oc.CollectionNetworkInstance_PolicyForwarding{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_PolicyForwarding) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_PolicyForwardingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_PolicyForwarding) bool) *oc.NetworkInstance_PolicyForwardingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_PolicyForwardingWatcher{}
	structs := map[string]*oc.NetworkInstance_PolicyForwarding{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_PolicyForwarding{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_PolicyForwarding", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_PolicyForwarding{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_PolicyForwarding)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/policy-forwarding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_PolicyForwardingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_PolicyForwarding) bool) *oc.NetworkInstance_PolicyForwardingWatcher {
	t.Helper()
	return watch_NetworkInstance_PolicyForwardingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/policy-forwarding to the batch object.
func (n *NetworkInstance_PolicyForwardingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}
