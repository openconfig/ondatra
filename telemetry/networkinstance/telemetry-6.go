package networkinstance

// This file contains generated telemetry method augmentations for the
// generated path structs, which makes use of their gNMI paths for making
// ONDATRA telemetry calls.

import (
	"reflect"
	"testing"
	"time"

	"github.com/openconfig/ondatra/internal/gnmigen/genutil"
	oc "github.com/openconfig/ondatra/telemetry"
	"github.com/openconfig/ygot/ygot"

	gpb "github.com/openconfig/gnmi/proto/gnmi"
)

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/instance-id to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath extracts the value of the leaf InstanceId from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_InstanceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.InstanceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_SegmentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/index to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-interface-id to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath extracts the value of the leaf LocalInterfaceId from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalInterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.LocalInterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv4-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath extracts the value of the leaf LocalIpv4Address from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv4AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LocalIpv4Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/local-ipv6-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath extracts the value of the leaf LocalIpv6Address from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_LocalIpv6AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LocalIpv6Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-bos to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath extracts the value of the leaf MplsBos from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsBosPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.MplsBos
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-tc to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath extracts the value of the leaf MplsTc from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTcPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.MplsTc
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/mpls-ttl to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath extracts the value of the leaf MplsTtl from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_MplsTtlPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.MplsTtl
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv4-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath extracts the value of the leaf RemoteIpv4Address from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv4AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteIpv4Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/remote-ipv6-address to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath extracts the value of the leaf RemoteIpv6Address from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_RemoteIpv6AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RemoteIpv6Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath) Get(t testing.TB) oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPathAny) Get(t testing.TB) []oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_UnionWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath extracts the value of the leaf Sid from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_SidPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union{
		Metadata: md,
	}
	val := parent.Sid
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath) Lookup(t testing.TB) *oc.QualifiedE_Segment_Type {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath) Get(t testing.TB) oc.E_Segment_Type {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_Segment_Type {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Segment_Type
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePathAny) Get(t testing.TB) []oc.E_Segment_Type {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Segment_Type
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Segment_Type {
	t.Helper()
	c := &oc.CollectionE_Segment_Type{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Segment_Type) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Segment_Type) bool) *oc.E_Segment_TypeWatcher {
	t.Helper()
	w := &oc.E_Segment_TypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Segment_Type)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Segment_Type) bool) *oc.E_Segment_TypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_Segment_Type) *oc.QualifiedE_Segment_Type {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Segment_Type) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Segment_Type {
	t.Helper()
	c := &oc.CollectionE_Segment_Type{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Segment_Type) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Segment_Type) bool) *oc.E_Segment_TypeWatcher {
	t.Helper()
	w := &oc.E_Segment_TypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Segment_Type)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Segment_Type) bool) *oc.E_Segment_TypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/type to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Segment_Type.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) *oc.QualifiedE_Segment_Type {
	t.Helper()
	qv := &oc.QualifiedE_Segment_Type{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/state/weight to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath extracts the value of the leaf Weight from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_WeightPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Weight
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath) Lookup(t testing.TB) *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath) Get(t testing.TB) oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePathAny) Get(t testing.TB) []oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv) *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath) Lookup(t testing.TB) *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath) Get(t testing.TB) oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePathAny) Get(t testing.TB) []oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	c := &oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPEWatcher {
	t.Helper()
	w := &oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	c := &oc.CollectionE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPEWatcher {
	t.Helper()
	w := &oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE) bool) *oc.E_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/state/type to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel
// and combines the update with an existing Metadata to return a *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE.
func convertNetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel) *oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_RibBgpTypes_TUNNEL_ENCAPSULATION_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_Community", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Bgp_Rib_Community {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Bgp_Rib_Community {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Bgp_Rib_Community
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Bgp_Rib_Community)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_CommunityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_CommunityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_CommunityWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_CommunityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_CommunityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Bgp_Rib_Community) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_CommunityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_CommunityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_CommunityWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_CommunityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_CommunityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_CommunityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_Community", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath) Get(t testing.TB) []oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath) Await(t testing.TB, timeout time.Duration, val []oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_CommunityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath extracts the value of the leaf Community from its parent oc.NetworkInstance_Protocol_Bgp_Rib_Community
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice.
func convertNetworkInstance_Protocol_Bgp_Rib_Community_CommunityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_Community) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_Community_Community_UnionSlice{
		Metadata: md,
	}
	val := parent.Community
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_Community", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_Community_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_Community_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_Community_IndexPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_Community_IndexPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_Community{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_Community", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_Community_IndexPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_Community_IndexPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/index to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_Community_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_Community_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Protocol_Bgp_Rib_Community
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Bgp_Rib_Community_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_Community) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunityWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunityWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath) Get(t testing.TB) []oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPathAny) Get(t testing.TB) [][]oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath) Await(t testing.TB, timeout time.Duration, val []oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSliceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice) bool) *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath extracts the value of the leaf ExtCommunity from its parent oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice.
func convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity) *oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_UnionSlice{
		Metadata: md,
	}
	val := parent.ExtCommunity
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a ONCE subscription.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Bgp_Rib_ExtCommunity", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/index to the batch object.
func (n *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath extracts the value of the leaf Index from its parent oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Bgp_Rib_ExtCommunity_IndexPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Bgp_Rib_ExtCommunity) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.Index
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_DefaultMetricPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_DefaultMetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_DefaultMetricPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_DefaultMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_DefaultMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_DefaultMetricPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_DefaultMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_DefaultMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_DefaultMetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_DefaultMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_DefaultMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_DefaultMetricPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric to the batch object.
func (n *NetworkInstance_Protocol_DefaultMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_DefaultMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_DefaultMetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_DefaultMetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_DefaultMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_DefaultMetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/default-metric to the batch object.
func (n *NetworkInstance_Protocol_DefaultMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_DefaultMetricPath extracts the value of the leaf DefaultMetric from its parent oc.NetworkInstance_Protocol
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_DefaultMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.DefaultMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_IdentifierPath) Lookup(t testing.TB) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_IdentifierPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_IdentifierPath) Get(t testing.TB) oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_IdentifierPathAny) Lookup(t testing.TB) []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_IdentifierPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a ONCE subscription.
func (n *NetworkInstance_Protocol_IdentifierPathAny) Get(t testing.TB) []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_IdentifierPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_IdentifierPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	w := &oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_IdentifierPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_IdentifierPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_IdentifierPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_IdentifierPath) Await(t testing.TB, timeout time.Duration, val oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPE) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier to the batch object.
func (n *NetworkInstance_Protocol_IdentifierPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_IdentifierPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	c := &oc.CollectionE_PolicyTypes_INSTALL_PROTOCOL_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_IdentifierPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	w := &oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_IdentifierPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_IdentifierPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE) bool) *oc.E_PolicyTypes_INSTALL_PROTOCOL_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_IdentifierPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/state/identifier to the batch object.
func (n *NetworkInstance_Protocol_IdentifierPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_IdentifierPath extracts the value of the leaf Identifier from its parent oc.NetworkInstance_Protocol
// and combines the update with an existing Metadata to return a *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE.
func convertNetworkInstance_Protocol_IdentifierPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol) *oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_PolicyTypes_INSTALL_PROTOCOL_TYPE{
		Metadata: md,
	}
	val := parent.Identifier
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_IgmpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_IgmpPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_IgmpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a ONCE subscription.
func (n *NetworkInstance_Protocol_IgmpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_IgmpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_IgmpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp) bool) *oc.NetworkInstance_Protocol_IgmpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_IgmpWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_IgmpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp) bool) *oc.NetworkInstance_Protocol_IgmpWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_IgmpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_IgmpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp) *oc.QualifiedNetworkInstance_Protocol_Igmp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp to the batch object.
func (n *NetworkInstance_Protocol_IgmpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_IgmpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_IgmpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp) bool) *oc.NetworkInstance_Protocol_IgmpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_IgmpWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_IgmpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp) bool) *oc.NetworkInstance_Protocol_IgmpWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_IgmpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp to the batch object.
func (n *NetworkInstance_Protocol_IgmpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Global", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_GlobalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Global) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Global)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_GlobalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global) bool) *oc.NetworkInstance_Protocol_Igmp_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_GlobalWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_GlobalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global) bool) *oc.NetworkInstance_Protocol_Igmp_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_GlobalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_GlobalPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Global) *oc.QualifiedNetworkInstance_Protocol_Igmp_Global {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Global) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global to the batch object.
func (n *NetworkInstance_Protocol_Igmp_GlobalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_GlobalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Global) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_GlobalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global) bool) *oc.NetworkInstance_Protocol_Igmp_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_GlobalWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_GlobalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global) bool) *oc.NetworkInstance_Protocol_Igmp_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_GlobalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global to the batch object.
func (n *NetworkInstance_Protocol_Igmp_GlobalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Global_Ssm", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Global_Ssm {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Global_Ssm {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Global_Ssm
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Global_Ssm)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_SsmPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm) bool) *oc.NetworkInstance_Protocol_Igmp_Global_SsmWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Global_SsmWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm) bool) *oc.NetworkInstance_Protocol_Igmp_Global_SsmWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_SsmPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Global_Ssm) *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_SsmPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm) bool) *oc.NetworkInstance_Protocol_Igmp_Global_SsmWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Global_SsmWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Global_Ssm{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Global_Ssm{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm) bool) *oc.NetworkInstance_Protocol_Igmp_Global_SsmWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_SsmPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_SsmPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) bool) *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_MappingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_MappingWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) bool) *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_MappingWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) bool) *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_MappingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_MappingWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) bool) *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_MappingWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_MappingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/source to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath extracts the value of the leaf Source from its parent oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SourcePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Source
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/global/ssm/mappings/mapping/state/ssm-ranges to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath extracts the value of the leaf SsmRanges from its parent oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Global_Ssm_Mapping_SsmRangesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Global_Ssm_Mapping) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SsmRanges
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface) bool) *oc.NetworkInstance_Protocol_Igmp_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface) bool) *oc.NetworkInstance_Protocol_Igmp_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface to the batch object.
func (n *NetworkInstance_Protocol_Igmp_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface) bool) *oc.NetworkInstance_Protocol_Igmp_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_InterfaceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface) bool) *oc.NetworkInstance_Protocol_Igmp_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface to the batch object.
func (n *NetworkInstance_Protocol_Igmp_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_Counters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_CountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_CountersWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_CountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_Counters) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_CountersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_CountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_CountersWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_CountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_CountersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_CountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_QueriesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v1 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path extracts the value of the leaf V1 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V1Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V1
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v2 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path extracts the value of the leaf V2 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V2Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V2
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/received/state/v3 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path extracts the value of the leaf V3 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received_V3Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Received) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V3
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v1 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path extracts the value of the leaf V1 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V1Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V1
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v2 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path extracts the value of the leaf V2 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V2Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V2
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/queries/sent/state/v3 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path extracts the value of the leaf V3 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent_V3Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Queries_Sent) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V3
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Reports {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Counters_Reports) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_ReportsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v1 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path extracts the value of the leaf V1 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V1Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V1
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v2 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path extracts the value of the leaf V2 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V2Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V2
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3PathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3PathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Counters_Reports", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/counters/reports/state/v3 to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path extracts the value of the leaf V3 from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_Counters_Reports_V3Path(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Counters_Reports) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.V3
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Igmp_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Igmp_Interface_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/filter-prefixes to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath extracts the value of the leaf FilterPrefixes from its parent oc.NetworkInstance_Protocol_Igmp_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_FilterPrefixesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.FilterPrefixes
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_Group {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_Group {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_Group
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Group {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Group{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_Group)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_GroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_GroupWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_GroupWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_GroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_GroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_Group) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Group {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_Group{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_GroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_GroupWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_GroupWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_Group) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_GroupWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_GroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_GroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Group_GroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Group_GroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Group_GroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Group_GroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Group_GroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Group_GroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/group to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_GroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Group_GroupPath extracts the value of the leaf Group from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Group
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_Group_GroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Group) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Group
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/reporter to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_ReporterPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath extracts the value of the leaf Reporter from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Group
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_Group_ReporterPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Group) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Reporter
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_Group_SourcePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_Group_SourcePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_Group_SourcePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_Group_SourcePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_Group{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_Group", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_Group_SourcePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_Group_SourcePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/membership-groups/group/state/source to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_Group_SourcePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_Group_SourcePath extracts the value of the leaf Source from its parent oc.NetworkInstance_Protocol_Igmp_Interface_Group
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_Group_SourcePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_Group) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Source
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Protocol_Igmp_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRefWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Igmp_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-expires to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryExpiresPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath extracts the value of the leaf QueryExpires from its parent oc.NetworkInstance_Protocol_Igmp_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Igmp_Interface_QueryExpiresPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.QueryExpires
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/query-interval to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_QueryIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath extracts the value of the leaf QueryInterval from its parent oc.NetworkInstance_Protocol_Igmp_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Igmp_Interface_QueryIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.QueryInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_StaticGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroupsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroupsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups) *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Igmp_Interface_StaticGroups {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroupsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroupsWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Igmp_Interface_StaticGroups) bool) *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroupsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroupsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/source to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath extracts the value of the leaf Source from its parent oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_SourcePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Source
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface_StaticGroups", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/static-membership-groups/static-groups/state/static-group to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath extracts the value of the leaf StaticGroup from its parent oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Igmp_Interface_StaticGroups_StaticGroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface_StaticGroups) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.StaticGroup
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Igmp_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Igmp_Interface_VersionPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Igmp_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Igmp_Interface_VersionPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a ONCE subscription.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_VersionPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Igmp_Interface_VersionPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_VersionPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Igmp_Interface_VersionPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Igmp_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Igmp_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Igmp_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Igmp_Interface_VersionPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Igmp_Interface_VersionPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/igmp/interfaces/interface/state/version to the batch object.
func (n *NetworkInstance_Protocol_Igmp_Interface_VersionPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Igmp_Interface_VersionPath extracts the value of the leaf Version from its parent oc.NetworkInstance_Protocol_Igmp_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Igmp_Interface_VersionPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Igmp_Interface) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Version
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_IsisPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_IsisPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_IsisPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a ONCE subscription.
func (n *NetworkInstance_Protocol_IsisPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_IsisPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_IsisPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis) bool) *oc.NetworkInstance_Protocol_IsisWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_IsisWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_IsisPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis) bool) *oc.NetworkInstance_Protocol_IsisWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_IsisPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_IsisPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis) *oc.QualifiedNetworkInstance_Protocol_Isis {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis to the batch object.
func (n *NetworkInstance_Protocol_IsisPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_IsisPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_IsisPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis) bool) *oc.NetworkInstance_Protocol_IsisWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_IsisWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_IsisPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis) bool) *oc.NetworkInstance_Protocol_IsisWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_IsisPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis to the batch object.
func (n *NetworkInstance_Protocol_IsisPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_GlobalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_GlobalPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_GlobalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_GlobalPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_GlobalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_GlobalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global) bool) *oc.NetworkInstance_Protocol_Isis_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_GlobalWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_GlobalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global) bool) *oc.NetworkInstance_Protocol_Isis_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_GlobalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_GlobalPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedNetworkInstance_Protocol_Isis_Global {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global to the batch object.
func (n *NetworkInstance_Protocol_Isis_GlobalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_GlobalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_GlobalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global) bool) *oc.NetworkInstance_Protocol_Isis_GlobalWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_GlobalWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_GlobalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global) bool) *oc.NetworkInstance_Protocol_Isis_GlobalWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_GlobalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global to the batch object.
func (n *NetworkInstance_Protocol_Isis_GlobalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_AfPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_AfPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Af {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_AfPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_AfPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Af {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Af
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_AfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Af {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Af{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Af)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_AfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_AfWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_AfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_AfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_AfPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Af) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_AfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_AfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Af {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Af{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_AfPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_AfWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_AfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_AfPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_AfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Af_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath) Get(t testing.TB) oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Af_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Af_AfiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AFI_TYPE) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_AfiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Af_AfiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_AfiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Af_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Protocol_Isis_Global_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Global_Af_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Af) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AFI_TYPE{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Af_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Af_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Af_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Af_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Af_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Global_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_Af_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Af) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Af_MetricPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint32{
		Metadata: md,
	}).SetVal(goStruct.GetMetric())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Af_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Af_MetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Af_MetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Af_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Protocol_Isis_Global_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Global_Af_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Af) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology) bool) *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology) bool) *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Af_MultiTopology {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology) bool) *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Af_MultiTopology) bool) *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopologyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath) Get(t testing.TB) oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AFI_TYPE) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AFI_TYPE{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath) Get(t testing.TB) oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_SAFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_SAFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_SAFI_TYPE) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af_MultiTopology", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/multi-topology/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath extracts the value of the leaf SafiName from its parent oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_SAFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Global_Af_MultiTopology_SafiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Af_MultiTopology) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_SAFI_TYPE{
		Metadata: md,
	}
	val := parent.SafiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Af_SafiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath) Get(t testing.TB) oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_SAFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Af_SafiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_SAFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Af_SafiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_SAFI_TYPE) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Af_SafiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Af_SafiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Af_SafiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/afi-safi/af/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Af_SafiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Af_SafiNamePath extracts the value of the leaf SafiName from its parent oc.NetworkInstance_Protocol_Isis_Global_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_SAFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Global_Af_SafiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Af) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_SAFI_TYPE{
		Metadata: md,
	}
	val := parent.SafiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Afi", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Afi {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Afi {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Afi
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Afi {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Afi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Afi)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_AfiPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfiWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_AfiWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_AfiPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Afi) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Afi {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Afi{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_AfiPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfiWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_AfiWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Afi) bool) *oc.NetworkInstance_Protocol_Isis_Global_AfiWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_AfiPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_AfiPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Afi", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath) Get(t testing.TB) oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AFI_TYPE) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Protocol_Isis_Global_Afi
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Global_Afi_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Afi) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AFI_TYPE{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath) Lookup(t testing.TB) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Afi", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Afi_NhTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath) Get(t testing.TB) []oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Afi_NhTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePathAny) Get(t testing.TB) [][]oc.E_MplsTypes_PATH_SETUP_PROTOCOL {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_MplsTypes_PATH_SETUP_PROTOCOL
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOLSlice {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOLSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLSliceWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_SETUP_PROTOCOLSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Afi_NhTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath) Await(t testing.TB, timeout time.Duration, val []oc.E_MplsTypes_PATH_SETUP_PROTOCOL) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOLSlice {
	t.Helper()
	c := &oc.CollectionE_MplsTypes_PATH_SETUP_PROTOCOLSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Afi_NhTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLSliceWatcher {
	t.Helper()
	w := &oc.E_MplsTypes_PATH_SETUP_PROTOCOLSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Afi{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Afi{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Afi", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Afi_NhTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice) bool) *oc.E_MplsTypes_PATH_SETUP_PROTOCOLSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Afi_NhTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/igp-shortcuts/afi/state/nh-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Afi_NhTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Afi_NhTypePath extracts the value of the leaf NhType from its parent oc.NetworkInstance_Protocol_Isis_Global_Afi
// and combines the update with an existing Metadata to return a *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice.
func convertNetworkInstance_Protocol_Isis_Global_Afi_NhTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Afi) *oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice {
	t.Helper()
	qv := &oc.QualifiedE_MplsTypes_PATH_SETUP_PROTOCOLSlice{
		Metadata: md,
	}
	val := parent.NhType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetAuthenticationCheck())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/authentication-check to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_AuthenticationCheckPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath extracts the value of the leaf AuthenticationCheck from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_AuthenticationCheckPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.AuthenticationCheck
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_FastFloodingPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetFastFlooding())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_FastFloodingPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_FastFloodingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_FastFloodingPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_FastFloodingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_FastFloodingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_FastFloodingPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_FastFloodingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/fast-flooding to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_FastFloodingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_FastFloodingPath extracts the value of the leaf FastFlooding from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_FastFloodingPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.FastFlooding
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_GracefulRestart", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_GracefulRestartPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart) bool) *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestartWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart) bool) *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_GracefulRestartPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_GracefulRestart {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_GracefulRestartPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart) bool) *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestartWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestartWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_GracefulRestart) bool) *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestartWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_GracefulRestartPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestartPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_GracefulRestart", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_GracefulRestart", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/graceful-restart/state/helper-only to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath extracts the value of the leaf HelperOnly from its parent oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_GracefulRestart_HelperOnlyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_GracefulRestart) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.HelperOnly
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_HelloPaddingPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_IsisTypes_HelloPaddingType{
		Metadata: md,
	}).SetVal(goStruct.GetHelloPadding())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPath) Get(t testing.TB) oc.E_IsisTypes_HelloPaddingType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_HelloPaddingType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_HelloPaddingPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPathAny) Get(t testing.TB) []oc.E_IsisTypes_HelloPaddingType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_HelloPaddingType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_HelloPaddingType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_HelloPaddingType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_HelloPaddingType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_HelloPaddingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_HelloPaddingTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_HelloPaddingPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_HelloPaddingType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_HelloPaddingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_HelloPaddingType) *oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_HelloPaddingType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_HelloPaddingType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_HelloPaddingType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_HelloPaddingType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_HelloPaddingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_HelloPaddingTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_HelloPaddingPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_HelloPaddingType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_HelloPaddingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/hello-padding to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_HelloPaddingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_HelloPaddingPath extracts the value of the leaf HelloPadding from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_HelloPaddingType.
func convertNetworkInstance_Protocol_Isis_Global_HelloPaddingPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_HelloPaddingType{
		Metadata: md,
	}
	val := parent.HelloPadding
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_IidTlvPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetIidTlv())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_IidTlvPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_IidTlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_IidTlvPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_IidTlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_IidTlvPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_IidTlvPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_IidTlvPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/iid-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_IidTlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_IidTlvPath extracts the value of the leaf IidTlv from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_IidTlvPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.IidTlv
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_InstancePath(t, md, goStruct)
	}
	return (&oc.QualifiedString{
		Metadata: md,
	}).SetVal(goStruct.GetInstance())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_InstancePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InstancePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_InstancePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InstancePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InstancePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_InstancePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InstancePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/instance to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InstancePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_InstancePath extracts the value of the leaf Instance from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Global_InstancePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Instance
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPoliciesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2PathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2PathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Watcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2 {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Watcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2 to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath) Lookup(t testing.TB) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}).SetVal(goStruct.GetDefaultImportPolicy())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath) Get(t testing.TB) oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPathAny) Get(t testing.TB) []oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_RoutingPolicy_DefaultPolicyType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	c := &oc.CollectionE_RoutingPolicy_DefaultPolicyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	w := &oc.E_RoutingPolicy_DefaultPolicyTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RoutingPolicy_DefaultPolicyType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath) Await(t testing.TB, timeout time.Duration, val oc.E_RoutingPolicy_DefaultPolicyType) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	c := &oc.CollectionE_RoutingPolicy_DefaultPolicyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	w := &oc.E_RoutingPolicy_DefaultPolicyTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RoutingPolicy_DefaultPolicyType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/default-import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath extracts the value of the leaf DefaultImportPolicy from its parent oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2
// and combines the update with an existing Metadata to return a *oc.QualifiedE_RoutingPolicy_DefaultPolicyType.
func convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_DefaultImportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	qv := &oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}
	val := parent.DefaultImportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level1-to-level2/state/import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath extracts the value of the leaf ImportPolicy from its parent oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2_ImportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level1ToLevel2) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ImportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1PathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1PathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Watcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Path) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1PathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1 {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1PathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Watcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1PathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) bool) *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1PathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1 to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1PathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath) Lookup(t testing.TB) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}).SetVal(goStruct.GetDefaultImportPolicy())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath) Get(t testing.TB) oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_RoutingPolicy_DefaultPolicyType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPathAny) Get(t testing.TB) []oc.E_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_RoutingPolicy_DefaultPolicyType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	c := &oc.CollectionE_RoutingPolicy_DefaultPolicyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	w := &oc.E_RoutingPolicy_DefaultPolicyTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RoutingPolicy_DefaultPolicyType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath) Await(t testing.TB, timeout time.Duration, val oc.E_RoutingPolicy_DefaultPolicyType) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	c := &oc.CollectionE_RoutingPolicy_DefaultPolicyType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	w := &oc.E_RoutingPolicy_DefaultPolicyTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_RoutingPolicy_DefaultPolicyType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_RoutingPolicy_DefaultPolicyType) bool) *oc.E_RoutingPolicy_DefaultPolicyTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/default-import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath extracts the value of the leaf DefaultImportPolicy from its parent oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1
// and combines the update with an existing Metadata to return a *oc.QualifiedE_RoutingPolicy_DefaultPolicyType.
func convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_DefaultImportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) *oc.QualifiedE_RoutingPolicy_DefaultPolicyType {
	t.Helper()
	qv := &oc.QualifiedE_RoutingPolicy_DefaultPolicyType{
		Metadata: md,
	}
	val := parent.DefaultImportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/inter-level-propagation-policies/level2-to-level1/state/import-policy to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath extracts the value of the leaf ImportPolicy from its parent oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1_ImportPolicyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_InterLevelPropagationPolicies_Level2ToLevel1) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.ImportPolicy
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LevelCapabilityPath(t, md, goStruct)
	}
	return (&oc.QualifiedE_IsisTypes_LevelType{
		Metadata: md,
	}).SetVal(goStruct.GetLevelCapability())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath) Get(t testing.TB) oc.E_IsisTypes_LevelType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_LevelType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LevelCapabilityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPathAny) Get(t testing.TB) []oc.E_IsisTypes_LevelType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_LevelType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_LevelType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_LevelType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_LevelType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_LevelTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LevelCapabilityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_LevelType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_LevelType) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_LevelType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_LevelType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_LevelType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_LevelType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LevelCapabilityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_LevelTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LevelCapabilityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_LevelType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LevelCapabilityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/level-capability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LevelCapabilityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LevelCapabilityPath extracts the value of the leaf LevelCapability from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_LevelType.
func convertNetworkInstance_Protocol_Isis_Global_LevelCapabilityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_LevelType{
		Metadata: md,
	}
	val := parent.LevelCapability
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_LspBit {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_LspBit {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_LspBit
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_LspBit)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBitWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBitWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_LspBit) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBitWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBitWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetIgnoreBit())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/ignore-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath extracts the value of the leaf IgnoreBit from its parent oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_IgnoreBitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.IgnoreBit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetSuppressBit())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/attached-bit/state/suppress-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath extracts the value of the leaf SuppressBit from its parent oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit_SuppressBitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_LspBit_AttachedBit) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SuppressBit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetAdvertiseHighMetric())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/advertise-high-metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath extracts the value of the leaf AdvertiseHighMetric from its parent oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_AdvertiseHighMetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.AdvertiseHighMetric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) bool) *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTriggerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath extracts the value of the leaf Delay from its parent oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_DelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Delay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath) Get(t testing.TB) oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPathAny) Get(t testing.TB) []oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) bool) *oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) bool) *oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) bool) *oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE) bool) *oc.E_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/reset-triggers/reset-trigger/state/reset-trigger to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath extracts the value of the leaf ResetTrigger from its parent oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE.
func convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger_ResetTriggerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_ResetTrigger) *oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_OVERLOAD_RESET_TRIGGER_TYPE{
		Metadata: md,
	}
	val := parent.ResetTrigger
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetSetBitOnBoot())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit-on-boot to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath extracts the value of the leaf SetBitOnBoot from its parent oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitOnBootPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SetBitOnBoot
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetSetBit())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/lsp-bit/overload-bit/state/set-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath extracts the value of the leaf SetBit from its parent oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit_SetBitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_LspBit_OverloadBit) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SetBit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/max-ecmp-paths to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath extracts the value of the leaf MaxEcmpPaths from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Global_MaxEcmpPathsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.MaxEcmpPaths
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint8{
		Metadata: md,
	}).SetVal(goStruct.GetMaximumAreaAddresses())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/maximum-area-addresses to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath extracts the value of the leaf MaximumAreaAddresses from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Global_MaximumAreaAddressesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.MaximumAreaAddresses
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Mpls", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Mpls {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Mpls {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Mpls
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Mpls)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_MplsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Global_MplsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_MplsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Mpls{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Global_MplsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_MplsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Mpls) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_MplsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Global_MplsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_MplsWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Mpls{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Mpls{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Global_MplsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_MplsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_MplsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSyncPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/mpls/igp-ldp-sync/state/post-session-up-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath extracts the value of the leaf PostSessionUpDelay from its parent oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync_PostSessionUpDelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Mpls_IgpLdpSync) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.PostSessionUpDelay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_NetPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_NetPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_NetPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_NetPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_NetPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_NetPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_NetPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_NetPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_NetPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_NetPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_NetPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_NetPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_NetPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_NetPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_NetPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_NetPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_NetPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_NetPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/net to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_NetPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_NetPath extracts the value of the leaf Net from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Global_NetPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.Net
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Nsr", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Nsr {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Nsr", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Nsr {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Nsr
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Nsr {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Nsr{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Nsr)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_NsrPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr) bool) *oc.NetworkInstance_Protocol_Isis_Global_NsrWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_NsrWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Nsr", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr) bool) *oc.NetworkInstance_Protocol_Isis_Global_NsrWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_NsrPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Nsr) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Nsr {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Nsr{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_NsrPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr) bool) *oc.NetworkInstance_Protocol_Isis_Global_NsrWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_NsrWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Nsr", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Nsr) bool) *oc.NetworkInstance_Protocol_Isis_Global_NsrWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_NsrPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_NsrPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Nsr", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Nsr", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Nsr", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Nsr{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Nsr", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/nsr/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Nsr_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Global_Nsr
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_Nsr_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Nsr) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_PoiTlvPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetPoiTlv())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_PoiTlvPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_PoiTlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_PoiTlvPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_PoiTlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_PoiTlvPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_PoiTlvPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_PoiTlvPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/state/poi-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_PoiTlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_PoiTlvPath extracts the value of the leaf PoiTlv from its parent oc.NetworkInstance_Protocol_Isis_Global
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_PoiTlvPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.PoiTlv
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) bool) *oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/reference-bandwidth/state/reference-bandwidth to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath extracts the value of the leaf ReferenceBandwidth from its parent oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Global_ReferenceBandwidth_ReferenceBandwidthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_ReferenceBandwidth) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.ReferenceBandwidth
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Global_SegmentRoutingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRoutingWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Global_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRoutingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Global_SegmentRoutingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRoutingWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Global_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRoutingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRoutingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srgb to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath extracts the value of the leaf Srgb from its parent oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrgbPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Srgb
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_SegmentRouting", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/segment-routing/state/srlb to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath extracts the value of the leaf Srlb from its parent oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Global_SegmentRouting_SrlbPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_SegmentRouting) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Srlb
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Timers {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Timers {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Timers
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Timers)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_TimersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Global_TimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_TimersWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Global_TimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_TimersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Timers) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_TimersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Global_TimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_TimersWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Global_TimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_TimersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_TimersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGenerationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath) Get(t testing.TB) oc.E_IsisTypes_AdaptiveTimerType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AdaptiveTimerType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPathAny) Get(t testing.TB) []oc.E_IsisTypes_AdaptiveTimerType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AdaptiveTimerType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AdaptiveTimerType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AdaptiveTimerTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AdaptiveTimerType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AdaptiveTimerType) *oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AdaptiveTimerType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AdaptiveTimerTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AdaptiveTimerType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/adaptive-timer to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath extracts the value of the leaf AdaptiveTimer from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AdaptiveTimerType.
func convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_AdaptiveTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) *oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AdaptiveTimerType{
		Metadata: md,
	}
	val := parent.AdaptiveTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-first-wait-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath extracts the value of the leaf LspFirstWaitInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspFirstWaitIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LspFirstWaitInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-max-wait-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath extracts the value of the leaf LspMaxWaitInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspMaxWaitIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LspMaxWaitInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/lsp-generation/state/lsp-second-wait-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath extracts the value of the leaf LspSecondWaitInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Global_Timers_LspGeneration_LspSecondWaitIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_LspGeneration) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LspSecondWaitInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint16{
		Metadata: md,
	}).SetVal(goStruct.GetLspLifetimeInterval())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-lifetime-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath extracts the value of the leaf LspLifetimeInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Global_Timers_LspLifetimeIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.LspLifetimeInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/state/lsp-refresh-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath extracts the value of the leaf LspRefreshInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Global_Timers_LspRefreshIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.LspRefreshInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_Spf {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_SpfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_SpfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Timers_SpfWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_SpfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_SpfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_Spf {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_SpfPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_SpfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_Timers_SpfWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Timers_Spf) bool) *oc.NetworkInstance_Protocol_Isis_Global_Timers_SpfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_SpfPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_SpfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath) Get(t testing.TB) oc.E_IsisTypes_AdaptiveTimerType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AdaptiveTimerType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPathAny) Get(t testing.TB) []oc.E_IsisTypes_AdaptiveTimerType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AdaptiveTimerType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AdaptiveTimerType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AdaptiveTimerTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AdaptiveTimerType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AdaptiveTimerType) *oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AdaptiveTimerType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AdaptiveTimerTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AdaptiveTimerType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AdaptiveTimerType) bool) *oc.E_IsisTypes_AdaptiveTimerTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/adaptive-timer to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath extracts the value of the leaf AdaptiveTimer from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AdaptiveTimerType.
func convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_AdaptiveTimerPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf) *oc.QualifiedE_IsisTypes_AdaptiveTimerType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AdaptiveTimerType{
		Metadata: md,
	}
	val := parent.AdaptiveTimer
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-first-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath extracts the value of the leaf SpfFirstInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfFirstIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SpfFirstInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint64{
		Metadata: md,
	}).SetVal(goStruct.GetSpfHoldInterval())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-hold-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath extracts the value of the leaf SpfHoldInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfHoldIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SpfHoldInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Timers_Spf", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/timers/spf/state/spf-second-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath extracts the value of the leaf SpfSecondInterval from its parent oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Global_Timers_Spf_SpfSecondIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Timers_Spf) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.SpfSecondInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Transport", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Global_Transport {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Transport", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Global_Transport {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Global_Transport
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Transport {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Transport{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Global_Transport)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_TransportPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport) bool) *oc.NetworkInstance_Protocol_Isis_Global_TransportWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_TransportWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Transport", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport) bool) *oc.NetworkInstance_Protocol_Isis_Global_TransportWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_TransportPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Global_Transport) *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Global_Transport {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Global_Transport{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_TransportPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport) bool) *oc.NetworkInstance_Protocol_Isis_Global_TransportWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Global_TransportWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Transport{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Transport", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Global_Transport) bool) *oc.NetworkInstance_Protocol_Isis_Global_TransportWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_TransportPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_TransportPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Global_Transport", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Transport", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Transport", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Global_Transport{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Global_Transport{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Global_Transport", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/global/transport/state/lsp-mtu-size to the batch object.
func (n *NetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath extracts the value of the leaf LspMtuSize from its parent oc.NetworkInstance_Protocol_Isis_Global_Transport
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Global_Transport_LspMtuSizePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Global_Transport) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.LspMtuSize
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_InterfacePath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_InterfacePath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_InterfacePathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface) bool) *oc.NetworkInstance_Protocol_Isis_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_InterfaceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface) bool) *oc.NetworkInstance_Protocol_Isis_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_InterfacePath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface to the batch object.
func (n *NetworkInstance_Protocol_Isis_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface) bool) *oc.NetworkInstance_Protocol_Isis_InterfaceWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_InterfaceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface) bool) *oc.NetworkInstance_Protocol_Isis_InterfaceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface to the batch object.
func (n *NetworkInstance_Protocol_Isis_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Af {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Af {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Af
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Af {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Af{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Af)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_AfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_AfWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_AfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Af) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Af {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Af{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_AfPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_AfWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_AfPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_AfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath) Get(t testing.TB) oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AFI_TYPE) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Protocol_Isis_Interface_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Interface_Af_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Af) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AFI_TYPE{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Af_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Af_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Af_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Af_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Af_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Af_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Af_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Af_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Af) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath) Get(t testing.TB) oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_SAFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_SAFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_SAFI_TYPE) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/afi-safi/af/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Af_SafiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath extracts the value of the leaf SafiName from its parent oc.NetworkInstance_Protocol_Isis_Interface_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_SAFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Interface_Af_SafiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Af) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_SAFI_TYPE{
		Metadata: md,
	}
	val := parent.SafiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Authentication) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_AuthenticationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_AuthenticationWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_AuthenticationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath) Get(t testing.TB) oc.E_IsisTypes_AUTH_MODE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AUTH_MODE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePathAny) Get(t testing.TB) []oc.E_IsisTypes_AUTH_MODE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AUTH_MODE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AUTH_MODE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AUTH_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AUTH_MODEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AUTH_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AUTH_MODE) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AUTH_MODE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AUTH_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AUTH_MODEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AUTH_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-mode to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath extracts the value of the leaf AuthMode from its parent oc.NetworkInstance_Protocol_Isis_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AUTH_MODE.
func convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Authentication) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AUTH_MODE{
		Metadata: md,
	}
	val := parent.AuthMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-password to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath extracts the value of the leaf AuthPassword from its parent oc.NetworkInstance_Protocol_Isis_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthPasswordPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthPassword
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath) Lookup(t testing.TB) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath) Get(t testing.TB) oc.E_KeychainTypes_AUTH_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_KeychainTypes_AUTH_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePathAny) Get(t testing.TB) []oc.E_KeychainTypes_AUTH_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_KeychainTypes_AUTH_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_KeychainTypes_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_KeychainTypes_AUTH_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_KeychainTypes_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_KeychainTypes_AUTH_TYPE) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_KeychainTypes_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_KeychainTypes_AUTH_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_KeychainTypes_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/auth-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath extracts the value of the leaf AuthType from its parent oc.NetworkInstance_Protocol_Isis_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_KeychainTypes_AUTH_TYPE.
func convertNetworkInstance_Protocol_Isis_Interface_Authentication_AuthTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Authentication) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_KeychainTypes_AUTH_TYPE{
		Metadata: md,
	}
	val := parent.AuthType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Authentication_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/authentication/state/keychain to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath extracts the value of the leaf Keychain from its parent oc.NetworkInstance_Protocol_Isis_Interface_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Authentication_KeychainPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Keychain
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Bfd", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Bfd {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Bfd", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Bfd {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Bfd
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Bfd {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Bfd{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Bfd)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_BfdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_BfdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_BfdWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Bfd", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_BfdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_BfdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Bfd) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Bfd {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Bfd{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_BfdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_BfdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_BfdWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Bfd", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Bfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_BfdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_BfdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_BfdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Bfd", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Bfd", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Bfd", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Bfd{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Bfd", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/bfd/state/bfd-tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath extracts the value of the leaf BfdTlv from its parent oc.NetworkInstance_Protocol_Isis_Interface_Bfd
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Bfd_BfdTlvPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Bfd) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.BfdTlv
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCountersWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_CircuitCounters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCountersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCountersWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_CircuitCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCountersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-changes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath extracts the value of the leaf AdjChanges from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjChangesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.AdjChanges
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/adj-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath extracts the value of the leaf AdjNumber from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AdjNumberPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.AdjNumber
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath extracts the value of the leaf AuthFails from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthFailsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.AuthFails
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/auth-type-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath extracts the value of the leaf AuthTypeFails from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_AuthTypeFailsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.AuthTypeFails
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/id-field-len-mismatches to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath extracts the value of the leaf IdFieldLenMismatches from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_IdFieldLenMismatchesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.IdFieldLenMismatches
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/init-fails to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath extracts the value of the leaf InitFails from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_InitFailsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.InitFails
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/lan-dis-changes to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath extracts the value of the leaf LanDisChanges from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_LanDisChangesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.LanDisChanges
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/max-area-address-mismatches to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath extracts the value of the leaf MaxAreaAddressMismatches from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_MaxAreaAddressMismatchesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.MaxAreaAddressMismatches
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_CircuitCounters", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/circuit-counters/state/rejected-adj to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath extracts the value of the leaf RejectedAdj from its parent oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitCounters_RejectedAdjPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_CircuitCounters) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.RejectedAdj
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_CircuitType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_CircuitTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePath) Get(t testing.TB) oc.E_IsisTypes_CircuitType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_CircuitType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_CircuitType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePathAny) Get(t testing.TB) []oc.E_IsisTypes_CircuitType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_CircuitType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_CircuitType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_CircuitType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_CircuitType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_CircuitType) bool) *oc.E_IsisTypes_CircuitTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_CircuitTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_CircuitTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_CircuitType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_CircuitType) bool) *oc.E_IsisTypes_CircuitTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_CircuitType) *oc.QualifiedE_IsisTypes_CircuitType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_CircuitType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_CircuitType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_CircuitType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_CircuitType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_CircuitTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_CircuitType) bool) *oc.E_IsisTypes_CircuitTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_CircuitTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_CircuitTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_CircuitType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_CircuitType) bool) *oc.E_IsisTypes_CircuitTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_CircuitTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/circuit-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_CircuitTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_CircuitTypePath extracts the value of the leaf CircuitType from its parent oc.NetworkInstance_Protocol_Isis_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_CircuitType.
func convertNetworkInstance_Protocol_Isis_Interface_CircuitTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface) *oc.QualifiedE_IsisTypes_CircuitType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_CircuitType{
		Metadata: md,
	}
	val := parent.CircuitType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_EnableBfd", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_EnableBfd", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_EnableBfd {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_EnableBfdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_EnableBfdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfdWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_EnableBfd", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_EnableBfdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_EnableBfdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_EnableBfd {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_EnableBfdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_EnableBfdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfdWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_EnableBfd", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_EnableBfd) bool) *oc.NetworkInstance_Protocol_Isis_Interface_EnableBfdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_EnableBfdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_EnableBfd", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_EnableBfd", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_EnableBfd", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_EnableBfd", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/enable-bfd/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_EnableBfd_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_EnableBfd) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_HelloPaddingPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath) Get(t testing.TB) oc.E_IsisTypes_HelloPaddingType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_HelloPaddingType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_HelloPaddingPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPathAny) Get(t testing.TB) []oc.E_IsisTypes_HelloPaddingType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_HelloPaddingType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_HelloPaddingType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_HelloPaddingType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_HelloPaddingType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_HelloPaddingTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_HelloPaddingPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_HelloPaddingType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_HelloPaddingType) *oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_HelloPaddingType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_HelloPaddingType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_HelloPaddingType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_HelloPaddingType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_HelloPaddingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_HelloPaddingTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_HelloPaddingPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_HelloPaddingType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_HelloPaddingType) bool) *oc.E_IsisTypes_HelloPaddingTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_HelloPaddingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/hello-padding to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_HelloPaddingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_HelloPaddingPath extracts the value of the leaf HelloPadding from its parent oc.NetworkInstance_Protocol_Isis_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_HelloPaddingType.
func convertNetworkInstance_Protocol_Isis_Interface_HelloPaddingPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface) *oc.QualifiedE_IsisTypes_HelloPaddingType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_HelloPaddingType{
		Metadata: md,
	}
	val := parent.HelloPadding
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_InterfaceIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_InterfaceIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_InterfaceIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_InterfaceIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/interface-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_InterfaceIdPath extracts the value of the leaf InterfaceId from its parent oc.NetworkInstance_Protocol_Isis_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_InterfaceIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.InterfaceId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRefWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_InterfaceRef {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRefPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRefWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRefWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_InterfaceRef) bool) *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRefWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRefPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRefPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/interface to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath extracts the value of the leaf Interface from its parent oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_InterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Interface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_InterfaceRef", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/interface-ref/state/subinterface to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath extracts the value of the leaf Subinterface from its parent oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_InterfaceRef_SubinterfacePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_InterfaceRef) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Subinterface
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_LevelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level) bool) *oc.NetworkInstance_Protocol_Isis_Interface_LevelWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_LevelWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level) bool) *oc.NetworkInstance_Protocol_Isis_Interface_LevelWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_LevelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_LevelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level) bool) *oc.NetworkInstance_Protocol_Isis_Interface_LevelWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_LevelWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level) bool) *oc.NetworkInstance_Protocol_Isis_Interface_LevelWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_LevelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_LevelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Adjacency {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Adjacency {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Adjacency) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AdjacencyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath) Get(t testing.TB) oc.E_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_IsisInterfaceAdjState
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePathAny) Get(t testing.TB) []oc.E_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_IsisInterfaceAdjState
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_IsisInterfaceAdjState{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState) bool) *oc.E_IsisTypes_IsisInterfaceAdjStateWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_IsisInterfaceAdjStateWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_IsisInterfaceAdjState)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState) bool) *oc.E_IsisTypes_IsisInterfaceAdjStateWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_IsisInterfaceAdjState) *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_IsisInterfaceAdjState{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState) bool) *oc.E_IsisTypes_IsisInterfaceAdjStateWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_IsisInterfaceAdjStateWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_IsisInterfaceAdjState)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState) bool) *oc.E_IsisTypes_IsisInterfaceAdjStateWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-state to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath extracts the value of the leaf AdjacencyState from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyStatePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedE_IsisTypes_IsisInterfaceAdjState {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_IsisInterfaceAdjState{
		Metadata: md,
	}
	val := parent.AdjacencyState
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath) Get(t testing.TB) oc.E_IsisTypes_LevelType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_LevelType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePathAny) Get(t testing.TB) []oc.E_IsisTypes_LevelType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_LevelType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_LevelType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_LevelType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_LevelType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_LevelTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_LevelType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_LevelType) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_LevelType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_LevelType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_LevelType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_LevelType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_LevelTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_LevelType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/adjacency-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath extracts the value of the leaf AdjacencyType from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_LevelType.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AdjacencyTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_LevelType{
		Metadata: md,
	}
	val := parent.AdjacencyType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/area-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath extracts the value of the leaf AreaAddress from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_AreaAddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.AreaAddress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/dis-system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath extracts the value of the leaf DisSystemId from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_DisSystemIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.DisSystemId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/local-extended-circuit-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath extracts the value of the leaf LocalExtendedCircuitId from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_LocalExtendedCircuitIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.LocalExtendedCircuitId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/multi-topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath extracts the value of the leaf MultiTopology from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_MultiTopologyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.MultiTopology
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath) Get(t testing.TB) oc.E_IsisTypes_LevelType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_LevelType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePathAny) Get(t testing.TB) []oc.E_IsisTypes_LevelType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_LevelType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_LevelType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_LevelType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_LevelType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_LevelTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_LevelType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_LevelType) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_LevelType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_LevelType {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_LevelType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_LevelType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_LevelTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_LevelType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_LevelType) bool) *oc.E_IsisTypes_LevelTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-circuit-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath extracts the value of the leaf NeighborCircuitType from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_LevelType.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborCircuitTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedE_IsisTypes_LevelType {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_LevelType{
		Metadata: md,
	}
	val := parent.NeighborCircuitType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-extended-circuit-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath extracts the value of the leaf NeighborExtendedCircuitId from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborExtendedCircuitIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.NeighborExtendedCircuitId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv4-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath extracts the value of the leaf NeighborIpv4Address from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv4AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NeighborIpv4Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-ipv6-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath extracts the value of the leaf NeighborIpv6Address from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborIpv6AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NeighborIpv6Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/neighbor-snpa to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath extracts the value of the leaf NeighborSnpa from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NeighborSnpaPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.NeighborSnpa
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath) Lookup(t testing.TB) *oc.QualifiedE_Adjacency_NlpidSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath) Get(t testing.TB) []oc.E_Adjacency_Nlpid {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Adjacency_NlpidSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Adjacency_NlpidSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPathAny) Get(t testing.TB) [][]oc.E_Adjacency_Nlpid {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Adjacency_Nlpid
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Adjacency_NlpidSlice {
	t.Helper()
	c := &oc.CollectionE_Adjacency_NlpidSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Adjacency_NlpidSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Adjacency_NlpidSlice) bool) *oc.E_Adjacency_NlpidSliceWatcher {
	t.Helper()
	w := &oc.E_Adjacency_NlpidSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Adjacency_NlpidSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Adjacency_NlpidSlice) bool) *oc.E_Adjacency_NlpidSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath) Await(t testing.TB, timeout time.Duration, val []oc.E_Adjacency_Nlpid) *oc.QualifiedE_Adjacency_NlpidSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Adjacency_NlpidSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Adjacency_NlpidSlice {
	t.Helper()
	c := &oc.CollectionE_Adjacency_NlpidSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Adjacency_NlpidSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Adjacency_NlpidSlice) bool) *oc.E_Adjacency_NlpidSliceWatcher {
	t.Helper()
	w := &oc.E_Adjacency_NlpidSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Adjacency_NlpidSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Adjacency_NlpidSlice) bool) *oc.E_Adjacency_NlpidSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/nlpid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath extracts the value of the leaf Nlpid from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Adjacency_NlpidSlice.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_NlpidPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedE_Adjacency_NlpidSlice {
	t.Helper()
	qv := &oc.QualifiedE_Adjacency_NlpidSlice{
		Metadata: md,
	}
	val := parent.Nlpid
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath extracts the value of the leaf Priority from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_PriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Priority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-status to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath extracts the value of the leaf RestartStatus from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartStatusPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RestartStatus
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-support to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath extracts the value of the leaf RestartSupport from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSupportPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RestartSupport
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/restart-suppress to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath extracts the value of the leaf RestartSuppress from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_RestartSuppressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.RestartSuppress
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/system-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath extracts the value of the leaf SystemId from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_SystemIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.SystemId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath) Get(t testing.TB) []oc.E_IsisTypes_AFI_SAFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPathAny) Get(t testing.TB) [][]oc.E_IsisTypes_AFI_SAFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_IsisTypes_AFI_SAFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_SAFI_TYPESlice {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_SAFI_TYPESlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice) bool) *oc.E_IsisTypes_AFI_SAFI_TYPESliceWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_SAFI_TYPESliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice) bool) *oc.E_IsisTypes_AFI_SAFI_TYPESliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath) Await(t testing.TB, timeout time.Duration, val []oc.E_IsisTypes_AFI_SAFI_TYPE) *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_SAFI_TYPESlice {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_SAFI_TYPESlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice) bool) *oc.E_IsisTypes_AFI_SAFI_TYPESliceWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_SAFI_TYPESliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice) bool) *oc.E_IsisTypes_AFI_SAFI_TYPESliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/topology to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath extracts the value of the leaf Topology from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_TopologyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AFI_SAFI_TYPESlice{
		Metadata: md,
	}
	val := parent.Topology
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Adjacency", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/adjacencies/adjacency/state/up-timestamp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath extracts the value of the leaf UpTimestamp from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Adjacency_UpTimestampPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Adjacency) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.UpTimestamp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_AfPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_AfWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_AfPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_AfPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AfWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_AfWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_AfWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_AfPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_AfPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath) Get(t testing.TB) oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_AFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AFI_TYPE) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AFI_TYPE) bool) *oc.E_IsisTypes_AFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/afi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath extracts the value of the leaf AfiName from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_AfiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af) *oc.QualifiedE_IsisTypes_AFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AFI_TYPE{
		Metadata: md,
	}
	val := parent.AfiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath(t, md, goStruct)
	}
	return (&oc.QualifiedUint32{
		Metadata: md,
	}).SetVal(goStruct.GetMetric())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath) Get(t testing.TB) oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_SAFI_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePathAny) Get(t testing.TB) []oc.E_IsisTypes_SAFI_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_SAFI_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_SAFI_TYPE) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_SAFI_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_SAFI_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_SAFI_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_SAFI_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_SAFI_TYPE) bool) *oc.E_IsisTypes_SAFI_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/state/safi-name to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath extracts the value of the leaf SafiName from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_SAFI_TYPE.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SafiNamePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af) *oc.QualifiedE_IsisTypes_SAFI_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_SAFI_TYPE{
		Metadata: md,
	}
	val := parent.SafiName
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRoutingPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath) Get(t testing.TB) oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPathAny) Get(t testing.TB) []oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_UnionWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath extracts the value of the leaf AllocatedDynamicLocal from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union{
		Metadata: md,
	}
	val := parent.AllocatedDynamicLocal
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetGroup())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/group to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath extracts the value of the leaf Group from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_GroupPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Group
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/neighbor to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath extracts the value of the leaf Neighbor from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_NeighborPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Neighbor
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetProtectionEligible())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/protection-eligible to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath extracts the value of the leaf ProtectionEligible from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_ProtectionEligiblePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.ProtectionEligible
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath) Get(t testing.TB) oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPathAny) Get(t testing.TB) []oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_UnionWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath extracts the value of the leaf SidId from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union{
		Metadata: md,
	}
	val := parent.SidId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSidPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath) Lookup(t testing.TB) *oc.QualifiedE_PrefixSid_LabelOptions {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath) Get(t testing.TB) oc.E_PrefixSid_LabelOptions {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPathAny) Lookup(t testing.TB) []*oc.QualifiedE_PrefixSid_LabelOptions {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_PrefixSid_LabelOptions
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPathAny) Get(t testing.TB) []oc.E_PrefixSid_LabelOptions {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_PrefixSid_LabelOptions
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PrefixSid_LabelOptions {
	t.Helper()
	c := &oc.CollectionE_PrefixSid_LabelOptions{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PrefixSid_LabelOptions) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_PrefixSid_LabelOptions) bool) *oc.E_PrefixSid_LabelOptionsWatcher {
	t.Helper()
	w := &oc.E_PrefixSid_LabelOptionsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_PrefixSid_LabelOptions)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PrefixSid_LabelOptions) bool) *oc.E_PrefixSid_LabelOptionsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath) Await(t testing.TB, timeout time.Duration, val oc.E_PrefixSid_LabelOptions) *oc.QualifiedE_PrefixSid_LabelOptions {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_PrefixSid_LabelOptions) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_PrefixSid_LabelOptions {
	t.Helper()
	c := &oc.CollectionE_PrefixSid_LabelOptions{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_PrefixSid_LabelOptions) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_PrefixSid_LabelOptions) bool) *oc.E_PrefixSid_LabelOptionsWatcher {
	t.Helper()
	w := &oc.E_PrefixSid_LabelOptionsWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_PrefixSid_LabelOptions)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_PrefixSid_LabelOptions) bool) *oc.E_PrefixSid_LabelOptionsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/label-options to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath extracts the value of the leaf LabelOptions from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
// and combines the update with an existing Metadata to return a *oc.QualifiedE_PrefixSid_LabelOptions.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_LabelOptionsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) *oc.QualifiedE_PrefixSid_LabelOptions {
	t.Helper()
	qv := &oc.QualifiedE_PrefixSid_LabelOptions{
		Metadata: md,
	}
	val := parent.LabelOptions
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/prefix to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath extracts the value of the leaf Prefix from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_PrefixPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Prefix
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath) Get(t testing.TB) oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPathAny) Get(t testing.TB) []oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_UnionWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath extracts the value of the leaf SidId from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union{
		Metadata: md,
	}
	val := parent.SidId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath) Get(t testing.TB) oc.E_IsisTypes_AUTH_MODE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AUTH_MODE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePathAny) Get(t testing.TB) []oc.E_IsisTypes_AUTH_MODE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AUTH_MODE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AUTH_MODE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AUTH_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AUTH_MODEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AUTH_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AUTH_MODE) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AUTH_MODE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AUTH_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AUTH_MODEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AUTH_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-mode to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath extracts the value of the leaf AuthMode from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AUTH_MODE.
func convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AUTH_MODE{
		Metadata: md,
	}
	val := parent.AuthMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-password to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath extracts the value of the leaf AuthPassword from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthPasswordPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthPassword
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath) Lookup(t testing.TB) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath) Get(t testing.TB) oc.E_KeychainTypes_AUTH_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_KeychainTypes_AUTH_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePathAny) Get(t testing.TB) []oc.E_KeychainTypes_AUTH_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_KeychainTypes_AUTH_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_KeychainTypes_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_KeychainTypes_AUTH_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_KeychainTypes_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_KeychainTypes_AUTH_TYPE) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_KeychainTypes_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_KeychainTypes_AUTH_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_KeychainTypes_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/auth-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath extracts the value of the leaf AuthType from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_KeychainTypes_AUTH_TYPE.
func convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_AuthTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_KeychainTypes_AUTH_TYPE{
		Metadata: md,
	}
	val := parent.AuthType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/hello-authentication/state/keychain to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath extracts the value of the leaf Keychain from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication_KeychainPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_HelloAuthentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Keychain
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/level-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath extracts the value of the leaf LevelNumber from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Interface_Level_LevelNumberPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.LevelNumber
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCountersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_CsnpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath extracts the value of the leaf Dropped from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_DroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Dropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath extracts the value of the leaf Processed from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ProcessedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Processed
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath extracts the value of the leaf Received from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_ReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Received
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath extracts the value of the leaf Retransmit from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_RetransmitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Retransmit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/csnp/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath extracts the value of the leaf Sent from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp_SentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Csnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Sent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_EshPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath extracts the value of the leaf Dropped from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_DroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Dropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath extracts the value of the leaf Processed from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ProcessedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Processed
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath extracts the value of the leaf Received from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_ReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Received
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath extracts the value of the leaf Retransmit from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_RetransmitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Retransmit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/esh/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath extracts the value of the leaf Sent from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh_SentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Esh) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Sent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IihPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath extracts the value of the leaf Dropped from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_DroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Dropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath extracts the value of the leaf Processed from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ProcessedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Processed
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath extracts the value of the leaf Received from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_ReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Received
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath extracts the value of the leaf Retransmit from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_RetransmitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Retransmit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/iih/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath extracts the value of the leaf Sent from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih_SentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Iih) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Sent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_IshPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath extracts the value of the leaf Dropped from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_DroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Dropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath extracts the value of the leaf Processed from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ProcessedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Processed
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath extracts the value of the leaf Received from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_ReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Received
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath extracts the value of the leaf Retransmit from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_RetransmitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Retransmit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/ish/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath extracts the value of the leaf Sent from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish_SentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Ish) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Sent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_LspPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath extracts the value of the leaf Dropped from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_DroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Dropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath extracts the value of the leaf Processed from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ProcessedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Processed
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath extracts the value of the leaf Received from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_ReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Received
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath extracts the value of the leaf Retransmit from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_RetransmitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Retransmit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/lsp/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath extracts the value of the leaf Sent from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp_SentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Lsp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Sent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_PsnpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath extracts the value of the leaf Dropped from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_DroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Dropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath extracts the value of the leaf Processed from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ProcessedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Processed
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath extracts the value of the leaf Received from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_ReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Received
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath extracts the value of the leaf Retransmit from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_RetransmitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Retransmit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/psnp/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath extracts the value of the leaf Sent from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp_SentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Psnp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Sent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_UnknownPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/dropped to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath extracts the value of the leaf Dropped from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_DroppedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Dropped
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/processed to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath extracts the value of the leaf Processed from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ProcessedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Processed
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/received to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath extracts the value of the leaf Received from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_ReceivedPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Received
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/retransmit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath extracts the value of the leaf Retransmit from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_RetransmitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Retransmit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/packet-counters/unknown/state/sent to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath extracts the value of the leaf Sent from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown_SentPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_PacketCounters_Unknown) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Sent
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PassivePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetPassive())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PassivePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PassivePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PassivePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PassivePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PassivePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PassivePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PassivePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/passive to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PassivePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PassivePath extracts the value of the leaf Passive from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PassivePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Passive
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_PriorityPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PriorityPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_PriorityPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_PriorityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_PriorityPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_PriorityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/state/priority to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_PriorityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_PriorityPath extracts the value of the leaf Priority from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Interface_Level_PriorityPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Priority
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Timers", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Timers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_TimersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_TimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_TimersWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_TimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_TimersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Timers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_TimersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_TimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Level_TimersWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Level_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Level_TimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_TimersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_TimersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Timers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath extracts the value of the leaf HelloInterval from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.HelloInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Level_Timers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Level_Timers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/timers/state/hello-multiplier to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath extracts the value of the leaf HelloMultiplier from its parent oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Interface_Level_Timers_HelloMultiplierPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Level_Timers) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.HelloMultiplier
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Mpls", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Mpls {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Mpls {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Mpls
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Mpls)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_MplsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Interface_MplsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_MplsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Interface_MplsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_MplsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Mpls) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_MplsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Interface_MplsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_MplsWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Mpls{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Mpls{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls) bool) *oc.NetworkInstance_Protocol_Isis_Interface_MplsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_MplsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_MplsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) bool) *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSyncPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/mpls/igp-ldp-sync/state/post-session-up-delay to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath extracts the value of the leaf PostSessionUpDelay from its parent oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync_PostSessionUpDelayPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Mpls_IgpLdpSync) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.PostSessionUpDelay
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_PassivePath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetPassive())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_PassivePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_PassivePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_PassivePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_PassivePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_PassivePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_PassivePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_PassivePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/state/passive to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_PassivePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_PassivePath extracts the value of the leaf Passive from its parent oc.NetworkInstance_Protocol_Isis_Interface
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Interface_PassivePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Passive
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Timers", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Interface_Timers {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Interface_Timers {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Interface_Timers
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Timers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Timers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Interface_Timers)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_TimersPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_TimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_TimersWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_TimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_TimersPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Interface_Timers) *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Interface_Timers {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Interface_Timers{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_TimersPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_TimersWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Interface_TimersWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Interface_Timers) bool) *oc.NetworkInstance_Protocol_Isis_Interface_TimersWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_TimersPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_TimersPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Timers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/csnp-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath extracts the value of the leaf CsnpInterval from its parent oc.NetworkInstance_Protocol_Isis_Interface_Timers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Interface_Timers_CsnpIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Timers) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.CsnpInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath) Lookup(t testing.TB) *oc.QualifiedUint64 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Interface_Timers", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath) Get(t testing.TB) uint64 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPathAny) Lookup(t testing.TB) []*oc.QualifiedUint64 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint64
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPathAny) Get(t testing.TB) []uint64 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint64
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath) Await(t testing.TB, timeout time.Duration, val uint64) *oc.QualifiedUint64 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint64) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint64 {
	t.Helper()
	c := &oc.CollectionUint64{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint64) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	w := &oc.Uint64Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Interface_Timers{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Interface_Timers", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint64)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint64) bool) *oc.Uint64Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/timers/state/lsp-pacing-interval to the batch object.
func (n *NetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath extracts the value of the leaf LspPacingInterval from its parent oc.NetworkInstance_Protocol_Isis_Interface_Timers
// and combines the update with an existing Metadata to return a *oc.QualifiedUint64.
func convertNetworkInstance_Protocol_Isis_Interface_Timers_LspPacingIntervalPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Interface_Timers) *oc.QualifiedUint64 {
	t.Helper()
	qv := &oc.QualifiedUint64{
		Metadata: md,
	}
	val := parent.LspPacingInterval
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_LevelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_LevelPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_LevelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_LevelPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_LevelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_LevelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level) bool) *oc.NetworkInstance_Protocol_Isis_LevelWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_LevelWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_LevelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level) bool) *oc.NetworkInstance_Protocol_Isis_LevelWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_LevelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_LevelPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level) *oc.QualifiedNetworkInstance_Protocol_Isis_Level {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level to the batch object.
func (n *NetworkInstance_Protocol_Isis_LevelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_LevelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_LevelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level) bool) *oc.NetworkInstance_Protocol_Isis_LevelWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_LevelWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_LevelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level) bool) *oc.NetworkInstance_Protocol_Isis_LevelWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_LevelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level to the batch object.
func (n *NetworkInstance_Protocol_Isis_LevelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetAuthenticationCheck())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/authentication-check to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationCheckPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath extracts the value of the leaf AuthenticationCheck from its parent oc.NetworkInstance_Protocol_Isis_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_AuthenticationCheckPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.AuthenticationCheck
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_AuthenticationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_AuthenticationWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_AuthenticationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath) Lookup(t testing.TB) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath) Get(t testing.TB) oc.E_IsisTypes_AUTH_MODE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisTypes_AUTH_MODE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePathAny) Get(t testing.TB) []oc.E_IsisTypes_AUTH_MODE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisTypes_AUTH_MODE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AUTH_MODE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AUTH_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AUTH_MODEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AUTH_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisTypes_AUTH_MODE) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisTypes_AUTH_MODE {
	t.Helper()
	c := &oc.CollectionE_IsisTypes_AUTH_MODE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisTypes_AUTH_MODE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	w := &oc.E_IsisTypes_AUTH_MODEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisTypes_AUTH_MODE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisTypes_AUTH_MODE) bool) *oc.E_IsisTypes_AUTH_MODEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-mode to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthModePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath extracts the value of the leaf AuthMode from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisTypes_AUTH_MODE.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthModePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedE_IsisTypes_AUTH_MODE {
	t.Helper()
	qv := &oc.QualifiedE_IsisTypes_AUTH_MODE{
		Metadata: md,
	}
	val := parent.AuthMode
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-password to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath extracts the value of the leaf AuthPassword from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthPasswordPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthPassword
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath) Lookup(t testing.TB) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath) Get(t testing.TB) oc.E_KeychainTypes_AUTH_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_KeychainTypes_AUTH_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePathAny) Get(t testing.TB) []oc.E_KeychainTypes_AUTH_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_KeychainTypes_AUTH_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_KeychainTypes_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_KeychainTypes_AUTH_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_KeychainTypes_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_KeychainTypes_AUTH_TYPE) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	c := &oc.CollectionE_KeychainTypes_AUTH_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	w := &oc.E_KeychainTypes_AUTH_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_KeychainTypes_AUTH_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_KeychainTypes_AUTH_TYPE) bool) *oc.E_KeychainTypes_AUTH_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/auth-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath extracts the value of the leaf AuthType from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_KeychainTypes_AUTH_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_AuthTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedE_KeychainTypes_AUTH_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_KeychainTypes_AUTH_TYPE{
		Metadata: md,
	}
	val := parent.AuthType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetDisableCsnp())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-csnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath extracts the value of the leaf DisableCsnp from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableCsnpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.DisableCsnp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetDisableLsp())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath extracts the value of the leaf DisableLsp from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_DisableLspPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.DisableLsp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetDisablePsnp())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/disable-psnp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath extracts the value of the leaf DisablePsnp from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_DisablePsnpPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.DisablePsnp
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/authentication/state/keychain to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Authentication_KeychainPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath extracts the value of the leaf Keychain from its parent oc.NetworkInstance_Protocol_Isis_Level_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Authentication_KeychainPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Keychain
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_EnabledPath(t, md, goStruct)
	}
	return (&oc.QualifiedBool{
		Metadata: md,
	}).SetVal(goStruct.GetEnabled())
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_EnabledPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_EnabledPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_EnabledPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_EnabledPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_EnabledPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_EnabledPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_EnabledPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/enabled to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_EnabledPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_EnabledPath extracts the value of the leaf Enabled from its parent oc.NetworkInstance_Protocol_Isis_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_EnabledPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.Enabled
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_LevelNumberPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_LevelNumberPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_LevelNumberPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_LevelNumberPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_LevelNumberPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_LevelNumberPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_LevelNumberPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_LevelNumberPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/state/level-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_LevelNumberPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_LevelNumberPath extracts the value of the leaf LevelNumber from its parent oc.NetworkInstance_Protocol_Isis_Level
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_LevelNumberPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.LevelNumber
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_LspPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_LspPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_LspPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_LspPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_LspPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_LspPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Level_LspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_LspWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_LspPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Level_LspWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_LspPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_LspPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_LspPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_LspPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_LspPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Level_LspWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_LspWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_LspPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp) bool) *oc.NetworkInstance_Protocol_Isis_Level_LspWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_LspPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_LspPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/checksum to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath extracts the value of the leaf Checksum from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_ChecksumPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.Checksum
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath) Lookup(t testing.TB) *oc.QualifiedE_Lsp_FlagsSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath) Get(t testing.TB) []oc.E_Lsp_Flags {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Lsp_FlagsSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Lsp_FlagsSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPathAny) Get(t testing.TB) [][]oc.E_Lsp_Flags {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Lsp_Flags
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Lsp_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_Lsp_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Lsp_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Lsp_FlagsSlice) bool) *oc.E_Lsp_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_Lsp_FlagsSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Lsp_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Lsp_FlagsSlice) bool) *oc.E_Lsp_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath) Await(t testing.TB, timeout time.Duration, val []oc.E_Lsp_Flags) *oc.QualifiedE_Lsp_FlagsSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Lsp_FlagsSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Lsp_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_Lsp_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Lsp_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Lsp_FlagsSlice) bool) *oc.E_Lsp_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_Lsp_FlagsSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Lsp_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Lsp_FlagsSlice) bool) *oc.E_Lsp_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_FlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath extracts the value of the leaf Flags from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Lsp_FlagsSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_FlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedE_Lsp_FlagsSlice {
	t.Helper()
	qv := &oc.QualifiedE_Lsp_FlagsSlice{
		Metadata: md,
	}
	val := parent.Flags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/id-length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath extracts the value of the leaf IdLength from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_IdLengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.IdLength
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/is-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_IsTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath extracts the value of the leaf IsType from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_IsTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.IsType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/lsp-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_LspIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath extracts the value of the leaf LspId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_LspIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.LspId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/maximum-area-addresses to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath extracts the value of the leaf MaximumAreaAddresses from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_MaximumAreaAddressesPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.MaximumAreaAddresses
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath extracts the value of the leaf PduLength from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_PduLengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.PduLength
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath) Lookup(t testing.TB) *oc.QualifiedE_Lsp_PduType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath) Get(t testing.TB) oc.E_Lsp_PduType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_Lsp_PduType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Lsp_PduType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePathAny) Get(t testing.TB) []oc.E_Lsp_PduType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Lsp_PduType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Lsp_PduType {
	t.Helper()
	c := &oc.CollectionE_Lsp_PduType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Lsp_PduType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Lsp_PduType) bool) *oc.E_Lsp_PduTypeWatcher {
	t.Helper()
	w := &oc.E_Lsp_PduTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Lsp_PduType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Lsp_PduType) bool) *oc.E_Lsp_PduTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_Lsp_PduType) *oc.QualifiedE_Lsp_PduType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Lsp_PduType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Lsp_PduType {
	t.Helper()
	c := &oc.CollectionE_Lsp_PduType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Lsp_PduType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Lsp_PduType) bool) *oc.E_Lsp_PduTypeWatcher {
	t.Helper()
	w := &oc.E_Lsp_PduTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Lsp_PduType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Lsp_PduType) bool) *oc.E_Lsp_PduTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/pdu-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_PduTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath extracts the value of the leaf PduType from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Lsp_PduType.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_PduTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedE_Lsp_PduType {
	t.Helper()
	qv := &oc.QualifiedE_Lsp_PduType{
		Metadata: md,
	}
	val := parent.PduType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath) Lookup(t testing.TB) *oc.QualifiedUint16 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath) Get(t testing.TB) uint16 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePathAny) Lookup(t testing.TB) []*oc.QualifiedUint16 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint16
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePathAny) Get(t testing.TB) []uint16 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint16
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath) Await(t testing.TB, timeout time.Duration, val uint16) *oc.QualifiedUint16 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint16) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint16 {
	t.Helper()
	c := &oc.CollectionUint16{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint16) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	w := &oc.Uint16Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint16)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint16) bool) *oc.Uint16Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/remaining-lifetime to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath extracts the value of the leaf RemainingLifetime from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint16.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_RemainingLifetimePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint16 {
	t.Helper()
	qv := &oc.QualifiedUint16{
		Metadata: md,
	}
	val := parent.RemainingLifetime
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/state/sequence-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath extracts the value of the leaf SequenceNumber from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_SequenceNumberPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.SequenceNumber
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_TlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_TlvWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_TlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_TlvPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_TlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_TlvWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_TlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_TlvPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_TlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath) Lookup(t testing.TB) *oc.QualifiedStringSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath) Get(t testing.TB) []string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPathAny) Lookup(t testing.TB) []*oc.QualifiedStringSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedStringSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPathAny) Get(t testing.TB) [][]string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath) Await(t testing.TB, timeout time.Duration, val []string) *oc.QualifiedStringSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedStringSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionStringSlice {
	t.Helper()
	c := &oc.CollectionStringSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedStringSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	w := &oc.StringSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedStringSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedStringSlice) bool) *oc.StringSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/area-address/state/address to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath extracts the value of the leaf Address from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress
// and combines the update with an existing Metadata to return a *oc.QualifiedStringSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress_AddressPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AreaAddress) *oc.QualifiedStringSlice {
	t.Helper()
	qv := &oc.QualifiedStringSlice{
		Metadata: md,
	}
	val := parent.Address
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_AuthenticationPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/authentication-key to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath extracts the value of the leaf AuthenticationKey from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_AuthenticationKeyPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.AuthenticationKey
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath) Lookup(t testing.TB) *oc.QualifiedE_Authentication_CryptoType {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath) Get(t testing.TB) oc.E_Authentication_CryptoType {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_Authentication_CryptoType {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Authentication_CryptoType
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePathAny) Get(t testing.TB) []oc.E_Authentication_CryptoType {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_Authentication_CryptoType
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Authentication_CryptoType {
	t.Helper()
	c := &oc.CollectionE_Authentication_CryptoType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Authentication_CryptoType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Authentication_CryptoType) bool) *oc.E_Authentication_CryptoTypeWatcher {
	t.Helper()
	w := &oc.E_Authentication_CryptoTypeWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Authentication_CryptoType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Authentication_CryptoType) bool) *oc.E_Authentication_CryptoTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath) Await(t testing.TB, timeout time.Duration, val oc.E_Authentication_CryptoType) *oc.QualifiedE_Authentication_CryptoType {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Authentication_CryptoType) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Authentication_CryptoType {
	t.Helper()
	c := &oc.CollectionE_Authentication_CryptoType{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Authentication_CryptoType) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Authentication_CryptoType) bool) *oc.E_Authentication_CryptoTypeWatcher {
	t.Helper()
	w := &oc.E_Authentication_CryptoTypeWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Authentication_CryptoType)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Authentication_CryptoType) bool) *oc.E_Authentication_CryptoTypeWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/authentication/state/crypto-type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath extracts the value of the leaf CryptoType from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Authentication_CryptoType.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication_CryptoTypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Authentication) *oc.QualifiedE_Authentication_CryptoType {
	t.Helper()
	qv := &oc.QualifiedE_Authentication_CryptoType{
		Metadata: md,
	}
	val := parent.CryptoType
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_CapabilityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath) Lookup(t testing.TB) *oc.QualifiedE_Capability_FlagsSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath) Get(t testing.TB) []oc.E_Capability_Flags {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Capability_FlagsSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Capability_FlagsSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPathAny) Get(t testing.TB) [][]oc.E_Capability_Flags {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Capability_Flags
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Capability_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_Capability_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Capability_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Capability_FlagsSlice) bool) *oc.E_Capability_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_Capability_FlagsSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Capability_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Capability_FlagsSlice) bool) *oc.E_Capability_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath) Await(t testing.TB, timeout time.Duration, val []oc.E_Capability_Flags) *oc.QualifiedE_Capability_FlagsSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Capability_FlagsSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Capability_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_Capability_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Capability_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Capability_FlagsSlice) bool) *oc.E_Capability_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_Capability_FlagsSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Capability_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Capability_FlagsSlice) bool) *oc.E_Capability_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath extracts the value of the leaf Flags from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Capability_FlagsSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_FlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) *oc.QualifiedE_Capability_FlagsSlice {
	t.Helper()
	qv := &oc.QualifiedE_Capability_FlagsSlice{
		Metadata: md,
	}
	val := parent.Flags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/instance-number to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath extracts the value of the leaf InstanceNumber from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_InstanceNumberPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.InstanceNumber
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/state/router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath extracts the value of the leaf RouterId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_RouterIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RouterId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_SubtlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithmsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath) Lookup(t testing.TB) *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath) Get(t testing.TB) []oc.E_SegmentRoutingAlgorithms_Algorithm {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPathAny) Lookup(t testing.TB) []*oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPathAny) Get(t testing.TB) [][]oc.E_SegmentRoutingAlgorithms_Algorithm {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_SegmentRoutingAlgorithms_Algorithm
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_SegmentRoutingAlgorithms_AlgorithmSlice {
	t.Helper()
	c := &oc.CollectionE_SegmentRoutingAlgorithms_AlgorithmSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice) bool) *oc.E_SegmentRoutingAlgorithms_AlgorithmSliceWatcher {
	t.Helper()
	w := &oc.E_SegmentRoutingAlgorithms_AlgorithmSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice) bool) *oc.E_SegmentRoutingAlgorithms_AlgorithmSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath) Await(t testing.TB, timeout time.Duration, val []oc.E_SegmentRoutingAlgorithms_Algorithm) *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_SegmentRoutingAlgorithms_AlgorithmSlice {
	t.Helper()
	c := &oc.CollectionE_SegmentRoutingAlgorithms_AlgorithmSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice) bool) *oc.E_SegmentRoutingAlgorithms_AlgorithmSliceWatcher {
	t.Helper()
	w := &oc.E_SegmentRoutingAlgorithms_AlgorithmSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice) bool) *oc.E_SegmentRoutingAlgorithms_AlgorithmSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-algorithms/state/algorithm to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath extracts the value of the leaf Algorithm from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms
// and combines the update with an existing Metadata to return a *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms_AlgorithmPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingAlgorithms) *oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice {
	t.Helper()
	qv := &oc.QualifiedE_SegmentRoutingAlgorithms_AlgorithmSlice{
		Metadata: md,
	}
	val := parent.Algorithm
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapabilityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath) Lookup(t testing.TB) *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath) Get(t testing.TB) []oc.E_SegmentRoutingCapability_Flags {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedE_SegmentRoutingCapability_FlagsSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_SegmentRoutingCapability_FlagsSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPathAny) Get(t testing.TB) [][]oc.E_SegmentRoutingCapability_Flags {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_SegmentRoutingCapability_Flags
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_SegmentRoutingCapability_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_SegmentRoutingCapability_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice) bool) *oc.E_SegmentRoutingCapability_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_SegmentRoutingCapability_FlagsSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_SegmentRoutingCapability_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice) bool) *oc.E_SegmentRoutingCapability_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath) Await(t testing.TB, timeout time.Duration, val []oc.E_SegmentRoutingCapability_Flags) *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_SegmentRoutingCapability_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_SegmentRoutingCapability_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice) bool) *oc.E_SegmentRoutingCapability_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_SegmentRoutingCapability_FlagsSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_SegmentRoutingCapability_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice) bool) *oc.E_SegmentRoutingCapability_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath extracts the value of the leaf Flags from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability
// and combines the update with an existing Metadata to return a *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_FlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability) *oc.QualifiedE_SegmentRoutingCapability_FlagsSlice {
	t.Helper()
	qv := &oc.QualifiedE_SegmentRoutingCapability_FlagsSlice{
		Metadata: md,
	}
	val := parent.Flags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptorPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath) Get(t testing.TB) oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPathAny) Get(t testing.TB) []oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_UnionWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath) Await(t testing.TB, timeout time.Duration, val oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_UnionWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_UnionWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_UnionWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath extracts the value of the leaf Label from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor
// and combines the update with an existing Metadata to return a *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_LabelPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union {
	t.Helper()
	qv := &oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union{
		Metadata: md,
	}
	val := parent.Label
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/range to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath extracts the value of the leaf Range from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_RangePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Range
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/length to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath extracts the value of the leaf Length from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_LengthPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Length
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath) Lookup(t testing.TB) *oc.QualifiedUint8 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath) Get(t testing.TB) uint8 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedUint8 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint8
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePathAny) Get(t testing.TB) []uint8 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint8
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath) Await(t testing.TB, timeout time.Duration, val uint8) *oc.QualifiedUint8 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint8) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint8 {
	t.Helper()
	c := &oc.CollectionUint8{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint8) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	w := &oc.Uint8Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint8)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint8) bool) *oc.Uint8Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedUint8.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) *oc.QualifiedUint8 {
	t.Helper()
	qv := &oc.QualifiedUint8{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath) Lookup(t testing.TB) *oc.QualifiedBinary {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath) Get(t testing.TB) oc.Binary {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePathAny) Lookup(t testing.TB) []*oc.QualifiedBinary {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBinary
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePathAny) Get(t testing.TB) []oc.Binary {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.Binary
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath) Await(t testing.TB, timeout time.Duration, val oc.Binary) *oc.QualifiedBinary {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBinary) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBinary {
	t.Helper()
	c := &oc.CollectionBinary{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBinary) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	w := &oc.BinaryWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBinary)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBinary) bool) *oc.BinaryWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/undefined-subtlvs/undefined-subtlv/state/value to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath extracts the value of the leaf Value from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv
// and combines the update with an existing Metadata to return a *oc.QualifiedBinary.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv_ValuePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_UndefinedSubtlv) *oc.QualifiedBinary {
	t.Helper()
	qv := &oc.QualifiedBinary{
		Metadata: md,
	}
	val := parent.Value
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4ReachabilityPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_PrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath) Lookup(t testing.TB) *oc.QualifiedUint32 {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath) Get(t testing.TB) uint32 {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPathAny) Lookup(t testing.TB) []*oc.QualifiedUint32 {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedUint32
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPathAny) Get(t testing.TB) []uint32 {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []uint32
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath) Await(t testing.TB, timeout time.Duration, val uint32) *oc.QualifiedUint32 {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedUint32) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionUint32 {
	t.Helper()
	c := &oc.CollectionUint32{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedUint32) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	w := &oc.Uint32Watcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedUint32)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedUint32) bool) *oc.Uint32Watcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/metric to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath extracts the value of the leaf Metric from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// and combines the update with an existing Metadata to return a *oc.QualifiedUint32.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_MetricPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) *oc.QualifiedUint32 {
	t.Helper()
	qv := &oc.QualifiedUint32{
		Metadata: md,
	}
	val := parent.Metric
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/prefix to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath extracts the value of the leaf Prefix from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_PrefixPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.Prefix
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath) Lookup(t testing.TB) *oc.QualifiedBool {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath) Get(t testing.TB) bool {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPathAny) Lookup(t testing.TB) []*oc.QualifiedBool {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedBool
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPathAny) Get(t testing.TB) []bool {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []bool
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath) Await(t testing.TB, timeout time.Duration, val bool) *oc.QualifiedBool {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedBool) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionBool {
	t.Helper()
	c := &oc.CollectionBool{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedBool) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	w := &oc.BoolWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedBool)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedBool) bool) *oc.BoolWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/state/s-bit to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath extracts the value of the leaf SBit from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix
// and combines the update with an existing Metadata to return a *oc.QualifiedBool.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SBitPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix) *oc.QualifiedBool {
	t.Helper()
	qv := &oc.QualifiedBool{
		Metadata: md,
	}
	val := parent.SBit
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_SubtlvPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_FlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath) Lookup(t testing.TB) *oc.QualifiedE_Flags_FlagsSlice {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath) Get(t testing.TB) []oc.E_Flags_Flags {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPathAny) Lookup(t testing.TB) []*oc.QualifiedE_Flags_FlagsSlice {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_Flags_FlagsSlice
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPathAny) Get(t testing.TB) [][]oc.E_Flags_Flags {
	t.Helper()
	fulldata := n.Lookup(t)
	var data [][]oc.E_Flags_Flags
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Flags_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_Flags_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Flags_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Flags_FlagsSlice) bool) *oc.E_Flags_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_Flags_FlagsSliceWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Flags_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Flags_FlagsSlice) bool) *oc.E_Flags_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath) Await(t testing.TB, timeout time.Duration, val []oc.E_Flags_Flags) *oc.QualifiedE_Flags_FlagsSlice {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_Flags_FlagsSlice) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_Flags_FlagsSlice {
	t.Helper()
	c := &oc.CollectionE_Flags_FlagsSlice{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_Flags_FlagsSlice) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_Flags_FlagsSlice) bool) *oc.E_Flags_FlagsSliceWatcher {
	t.Helper()
	w := &oc.E_Flags_FlagsSliceWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_Flags_FlagsSlice)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_Flags_FlagsSlice) bool) *oc.E_Flags_FlagsSliceWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/flags to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath extracts the value of the leaf Flags from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags
// and combines the update with an existing Metadata to return a *oc.QualifiedE_Flags_FlagsSlice.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_FlagsPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) *oc.QualifiedE_Flags_FlagsSlice {
	t.Helper()
	qv := &oc.QualifiedE_Flags_FlagsSlice{
		Metadata: md,
	}
	val := parent.Flags
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/flags/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Flags) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath extracts the value of the leaf RouterId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_RouterIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RouterId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath) Lookup(t testing.TB) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath) Get(t testing.TB) oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePathAny) Lookup(t testing.TB) []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePathAny) Get(t testing.TB) []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath) Await(t testing.TB, timeout time.Duration, val oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPE) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	c := &oc.CollectionE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	w := &oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE) bool) *oc.E_IsisLsdbTypes_ISIS_SUBTLV_TYPEWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv4-source-router-id/state/type to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath extracts the value of the leaf Type from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId
// and combines the update with an existing Metadata to return a *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId_TypePath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv4SourceRouterId) *oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE {
	t.Helper()
	qv := &oc.QualifiedE_IsisLsdbTypes_ISIS_SUBTLV_TYPE{
		Metadata: md,
	}
	val := parent.Type
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(val)
	}
	return qv
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath) Lookup(t testing.TB) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", goStruct, false, false)
	if ok {
		return (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{
			Metadata: md,
		}).SetVal(goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath) Get(t testing.TB) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPathAny) Lookup(t testing.TB) []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", goStruct, queryPath, false, false)
		if !ok {
			continue
		}
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{
			Metadata: md,
		}).SetVal(goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPathAny) Get(t testing.TB) []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) bool {
		copy, err := ygot.DeepCopy(v.Val(t))
		if err != nil {
			t.Fatal(err)
		}
		c.Data = append(c.Data, (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{
			Metadata: v.Metadata,
		}).SetVal(copy.(*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId)))
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", gs, queryPath, false, false)
		qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{
			Metadata: md,
		}).SetVal(gs)
		return []genutil.QualifiedValue{qv}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath) Await(t testing.TB, timeout time.Duration, val *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId {
	t.Helper()
	c := &oc.CollectionNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdWatcher {
	t.Helper()
	w := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, false, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", structs[pre], queryPath, false, false)
			qv := (&oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{
				Metadata: md,
			}).SetVal(structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) bool) *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Lookup fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a ONCE subscription.
// It returns nil if there is no value present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath) Lookup(t testing.TB) *oc.QualifiedString {
	t.Helper()
	goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	md, ok := oc.Lookup(t, n, "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", goStruct, true, false)
	if ok {
		return convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath(t, md, goStruct)
	}
	return nil
}

// Get fetches the value at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a ONCE subscription,
// failing the test fatally if no value is present at the path.
// To avoid a fatal test failure, use the Lookup method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath) Get(t testing.TB) string {
	t.Helper()
	return n.Lookup(t).Val(t)
}

// Lookup fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a ONCE subscription.
// It returns an empty list if no values are present at the path.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPathAny) Lookup(t testing.TB) []*oc.QualifiedString {
	t.Helper()
	datapoints, queryPath := genutil.MustGet(t, n)
	datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, datapoints, uint(len(queryPath.Elem)))

	var data []*oc.QualifiedString
	for _, prefix := range sortedPrefixes {
		goStruct := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
		md, ok := genutil.MustUnmarshal(t, datapointGroups[prefix], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", goStruct, queryPath, true, false)
		if !ok {
			continue
		}
		qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath(t, md, goStruct)
		data = append(data, qv)
	}
	return data
}

// Get fetches the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a ONCE subscription.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPathAny) Get(t testing.TB) []string {
	t.Helper()
	fulldata := n.Lookup(t)
	var data []string
	for _, full := range fulldata {
		data = append(data, full.Val(t))
	}
	return data
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	gs := &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		md, _ := genutil.MustUnmarshal(t, upd, oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", gs, queryPath, true, false)
		return []genutil.QualifiedValue{convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath(t, md, gs)}, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath(t, n, timeout, predicate)
}

// Await observes values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a STREAM subscription,
// blocking until a value that is deep equal to the specified val is received
// or failing fatally if the value is not received by the specified timeout.
// To avoid a fatal failure, to wait for a generic predicate, or to make a
// non-blocking call, use the Watch method instead.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath) Await(t testing.TB, timeout time.Duration, val string) *oc.QualifiedString {
	t.Helper()
	got, success := n.Watch(t, timeout, func(data *oc.QualifiedString) bool {
		return data.IsPresent() && reflect.DeepEqual(data.Val(t), val)
	}).Await(t)
	if !success {
		t.Fatalf("Await() at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id failed: want %v, last got %v", val, got)
	}
	return got
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// Collect starts an asynchronous collection of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a STREAM subscription.
// Calling Await on the return Collection waits for the specified duration to elapse and returns the collected values.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPathAny) Collect(t testing.TB, duration time.Duration) *oc.CollectionString {
	t.Helper()
	c := &oc.CollectionString{}
	c.W = n.Watch(t, duration, func(v *oc.QualifiedString) bool {
		c.Data = append(c.Data, v)
		return false
	})
	return c
}

func watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPathAny(t testing.TB, n ygot.PathStruct, duration time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	w := &oc.StringWatcher{}
	structs := map[string]*oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
	w.W = genutil.MustWatch(t, n, nil, duration, true, func(upd []*genutil.DataPoint, queryPath *gpb.Path) ([]genutil.QualifiedValue, error) {
		t.Helper()
		datapointGroups, sortedPrefixes := genutil.BundleDatapoints(t, upd, uint(len(queryPath.Elem)))
		var currStructs []genutil.QualifiedValue
		for _, pre := range sortedPrefixes {
			if len(datapointGroups[pre]) == 0 {
				continue
			}
			if _, ok := structs[pre]; !ok {
				structs[pre] = &oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId{}
			}
			md, _ := genutil.MustUnmarshal(t, datapointGroups[pre], oc.GetSchema(), "NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId", structs[pre], queryPath, true, false)
			qv := convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath(t, md, structs[pre])
			currStructs = append(currStructs, qv)
		}
		return currStructs, nil
	}, func(qualVal genutil.QualifiedValue) bool {
		val, ok := qualVal.(*oc.QualifiedString)
		w.LastVal = val
		return ok && predicate(val)
	})
	return w
}

// Watch starts an asynchronous observation of the values at /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id with a STREAM subscription,
// evaluating each observed value with the specified predicate.
// The subscription completes when either the predicate is true or the specified duration elapses.
// Calling Await on the returned Watcher waits for the subscription to complete.
// It returns the last observed value and a boolean that indicates whether that value satisfies the predicate.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPathAny) Watch(t testing.TB, timeout time.Duration, predicate func(val *oc.QualifiedString) bool) *oc.StringWatcher {
	t.Helper()
	return watch_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPathAny(t, n, timeout, predicate)
}

// Batch adds /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/extended-ipv4-reachability/prefixes/prefix/subtlvs/subtlv/ipv6-source-router-id/state/router-id to the batch object.
func (n *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPathAny) Batch(t testing.TB, b *oc.Batch) {
	t.Helper()
	oc.MustAddToBatch(t, b, n)
}

// convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath extracts the value of the leaf RouterId from its parent oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId
// and combines the update with an existing Metadata to return a *oc.QualifiedString.
func convertNetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId_RouterIdPath(t testing.TB, md *genutil.Metadata, parent *oc.NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_ExtendedIpv4Reachability_Prefix_Subtlv_Ipv6SourceRouterId) *oc.QualifiedString {
	t.Helper()
	qv := &oc.QualifiedString{
		Metadata: md,
	}
	val := parent.RouterId
	if !reflect.ValueOf(val).IsZero() {
		qv.SetVal(*val)
	}
	return qv
}
