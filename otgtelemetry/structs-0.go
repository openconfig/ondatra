/*
Package otgtelemetry is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by /home/athena/go/pkg/mod/github.com/openconfig/ygot@v0.16.3/genutil/names.go
using the following YANG input files:
	- gnmi-collector-metadata.yang
	- models-yang/models/isis/open-traffic-generator-isis.yang
	- models-yang/models/types/open-traffic-generator-types.yang
	- models-yang/models/flow/open-traffic-generator-flow.yang
	- models-yang/models/discovery/open-traffic-generator-discovery.yang
	- models-yang/models/interface/open-traffic-generator-port.yang
	- models-yang/models/bgp/open-traffic-generator-bgp.yang
Imported modules were sourced from:
	- models-yang/models/...
*/
package otgtelemetry

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
)

func init() {
	var err error
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// BgpPeer represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer YANG schema element.
type BgpPeer struct {
	Counters     *BgpPeer_Counters      `path:"state/counters" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Name         *string                `path:"state/name|name" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"name" shadow-module:"open-traffic-generator-bgp"`
	SessionState E_BgpPeer_SessionState `path:"state/session-state" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *BgpPeer) GetOrCreateCounters() *BgpPeer_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &BgpPeer_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from BgpPeer. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *BgpPeer) GetCounters() *BgpPeer_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the BgpPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *BgpPeer) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSessionState retrieves the value of the leaf SessionState from the BgpPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionState is set, it can
// safely use t.GetSessionState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionState == nil' before retrieving the leaf's value.
func (t *BgpPeer) GetSessionState() E_BgpPeer_SessionState {
	if t == nil || t.SessionState == 0 {
		return 0
	}
	return t.SessionState
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the BgpPeer struct, which is a YANG list entry.
func (t *BgpPeer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// BgpPeer_Counters represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/state/counters YANG schema element.
type BgpPeer_Counters struct {
	Flaps            *uint64 `path:"flaps" module:"open-traffic-generator-bgp"`
	InKeepalives     *uint64 `path:"in-keepalives" module:"open-traffic-generator-bgp"`
	InNotifications  *uint64 `path:"in-notifications" module:"open-traffic-generator-bgp"`
	InOpens          *uint64 `path:"in-opens" module:"open-traffic-generator-bgp"`
	InRouteWithdraw  *uint64 `path:"in-route-withdraw" module:"open-traffic-generator-bgp"`
	InRoutes         *uint64 `path:"in-routes" module:"open-traffic-generator-bgp"`
	InUpdates        *uint64 `path:"in-updates" module:"open-traffic-generator-bgp"`
	OutKeepalives    *uint64 `path:"out-keepalives" module:"open-traffic-generator-bgp"`
	OutNotifications *uint64 `path:"out-notifications" module:"open-traffic-generator-bgp"`
	OutOpens         *uint64 `path:"out-opens" module:"open-traffic-generator-bgp"`
	OutRouteWithdraw *uint64 `path:"out-route-withdraw" module:"open-traffic-generator-bgp"`
	OutRoutes        *uint64 `path:"out-routes" module:"open-traffic-generator-bgp"`
	OutUpdates       *uint64 `path:"out-updates" module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_Counters) IsYANGGoStruct() {}

// GetFlaps retrieves the value of the leaf Flaps from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flaps is set, it can
// safely use t.GetFlaps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flaps == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetFlaps() uint64 {
	if t == nil || t.Flaps == nil {
		return 0
	}
	return *t.Flaps
}

// GetInKeepalives retrieves the value of the leaf InKeepalives from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InKeepalives is set, it can
// safely use t.GetInKeepalives() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InKeepalives == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInKeepalives() uint64 {
	if t == nil || t.InKeepalives == nil {
		return 0
	}
	return *t.InKeepalives
}

// GetInNotifications retrieves the value of the leaf InNotifications from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InNotifications is set, it can
// safely use t.GetInNotifications() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InNotifications == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInNotifications() uint64 {
	if t == nil || t.InNotifications == nil {
		return 0
	}
	return *t.InNotifications
}

// GetInOpens retrieves the value of the leaf InOpens from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOpens is set, it can
// safely use t.GetInOpens() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOpens == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInOpens() uint64 {
	if t == nil || t.InOpens == nil {
		return 0
	}
	return *t.InOpens
}

// GetInRouteWithdraw retrieves the value of the leaf InRouteWithdraw from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRouteWithdraw is set, it can
// safely use t.GetInRouteWithdraw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRouteWithdraw == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInRouteWithdraw() uint64 {
	if t == nil || t.InRouteWithdraw == nil {
		return 0
	}
	return *t.InRouteWithdraw
}

// GetInRoutes retrieves the value of the leaf InRoutes from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRoutes is set, it can
// safely use t.GetInRoutes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRoutes == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInRoutes() uint64 {
	if t == nil || t.InRoutes == nil {
		return 0
	}
	return *t.InRoutes
}

// GetInUpdates retrieves the value of the leaf InUpdates from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUpdates is set, it can
// safely use t.GetInUpdates() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUpdates == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInUpdates() uint64 {
	if t == nil || t.InUpdates == nil {
		return 0
	}
	return *t.InUpdates
}

// GetOutKeepalives retrieves the value of the leaf OutKeepalives from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutKeepalives is set, it can
// safely use t.GetOutKeepalives() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutKeepalives == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutKeepalives() uint64 {
	if t == nil || t.OutKeepalives == nil {
		return 0
	}
	return *t.OutKeepalives
}

// GetOutNotifications retrieves the value of the leaf OutNotifications from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutNotifications is set, it can
// safely use t.GetOutNotifications() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutNotifications == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutNotifications() uint64 {
	if t == nil || t.OutNotifications == nil {
		return 0
	}
	return *t.OutNotifications
}

// GetOutOpens retrieves the value of the leaf OutOpens from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOpens is set, it can
// safely use t.GetOutOpens() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOpens == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutOpens() uint64 {
	if t == nil || t.OutOpens == nil {
		return 0
	}
	return *t.OutOpens
}

// GetOutRouteWithdraw retrieves the value of the leaf OutRouteWithdraw from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRouteWithdraw is set, it can
// safely use t.GetOutRouteWithdraw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRouteWithdraw == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutRouteWithdraw() uint64 {
	if t == nil || t.OutRouteWithdraw == nil {
		return 0
	}
	return *t.OutRouteWithdraw
}

// GetOutRoutes retrieves the value of the leaf OutRoutes from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRoutes is set, it can
// safely use t.GetOutRoutes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRoutes == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutRoutes() uint64 {
	if t == nil || t.OutRoutes == nil {
		return 0
	}
	return *t.OutRoutes
}

// GetOutUpdates retrieves the value of the leaf OutUpdates from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutUpdates is set, it can
// safely use t.GetOutUpdates() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutUpdates == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutUpdates() uint64 {
	if t == nil || t.OutUpdates == nil {
		return 0
	}
	return *t.OutUpdates
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Device represents the /device YANG schema element.
type Device struct {
	BgpPeer    map[string]*BgpPeer       `path:"bgp-peers/bgp-peer" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Flow       map[Device_Flow_Key]*Flow `path:"flows/flow" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	Interface  map[string]*Interface     `path:"interfaces/interface" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	IsisRouter map[string]*IsisRouter    `path:"isis-routers/isis-router" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Meta       *Meta                     `path:"meta" module:"gnmi-collector-metadata"`
	Port       map[string]*Port          `path:"ports/port" module:"open-traffic-generator-port/open-traffic-generator-port"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// Device_Flow_Key represents the key for list Flow of element /device.
type Device_Flow_Key struct {
	Name        string `path:"name"`
	MetricGroup string `path:"metric-group"`
}

// NewBgpPeer creates a new entry in the BgpPeer list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewBgpPeer(Name string) (*BgpPeer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeer == nil {
		t.BgpPeer = make(map[string]*BgpPeer)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BgpPeer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BgpPeer", key)
	}

	t.BgpPeer[key] = &BgpPeer{
		Name: &Name,
	}

	return t.BgpPeer[key], nil
}

// RenameBgpPeer renames an entry in the list BgpPeer within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameBgpPeer(oldK, newK string) error {
	if _, ok := t.BgpPeer[newK]; ok {
		return fmt.Errorf("key %v already exists in BgpPeer", newK)
	}

	e, ok := t.BgpPeer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BgpPeer", oldK)
	}
	e.Name = &newK

	t.BgpPeer[newK] = e
	delete(t.BgpPeer, oldK)
	return nil
}

// GetOrCreateBgpPeer retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateBgpPeer(Name string) *BgpPeer {

	key := Name

	if v, ok := t.BgpPeer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBgpPeer(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBgpPeer got unexpected error: %v", err))
	}
	return v
}

// GetBgpPeer retrieves the value with the specified key from
// the BgpPeer map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetBgpPeer(Name string) *BgpPeer {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.BgpPeer[key]; ok {
		return lm
	}
	return nil
}

// DeleteBgpPeer deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteBgpPeer(Name string) {
	key := Name

	delete(t.BgpPeer, key)
}

// AppendBgpPeer appends the supplied BgpPeer struct to the
// list BgpPeer of Device. If the key value(s) specified in
// the supplied BgpPeer already exist in the list, an error is
// returned.
func (t *Device) AppendBgpPeer(v *BgpPeer) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeer == nil {
		t.BgpPeer = make(map[string]*BgpPeer)
	}

	if _, ok := t.BgpPeer[key]; ok {
		return fmt.Errorf("duplicate key for list BgpPeer %v", key)
	}

	t.BgpPeer[key] = v
	return nil
}

// NewFlow creates a new entry in the Flow list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewFlow(Name string, MetricGroup string) (*Flow, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flow == nil {
		t.Flow = make(map[Device_Flow_Key]*Flow)
	}

	key := Device_Flow_Key{
		Name:        Name,
		MetricGroup: MetricGroup,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Flow[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Flow", key)
	}

	t.Flow[key] = &Flow{
		Name:        &Name,
		MetricGroup: &MetricGroup,
	}

	return t.Flow[key], nil
}

// RenameFlow renames an entry in the list Flow within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameFlow(oldK, newK Device_Flow_Key) error {
	if _, ok := t.Flow[newK]; ok {
		return fmt.Errorf("key %v already exists in Flow", newK)
	}

	e, ok := t.Flow[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Flow", oldK)
	}
	e.Name = &newK.Name
	e.MetricGroup = &newK.MetricGroup

	t.Flow[newK] = e
	delete(t.Flow, oldK)
	return nil
}

// GetOrCreateFlow retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateFlow(Name string, MetricGroup string) *Flow {

	key := Device_Flow_Key{
		Name:        Name,
		MetricGroup: MetricGroup,
	}

	if v, ok := t.Flow[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFlow(Name, MetricGroup)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFlow got unexpected error: %v", err))
	}
	return v
}

// GetFlow retrieves the value with the specified key from
// the Flow map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetFlow(Name string, MetricGroup string) *Flow {

	if t == nil {
		return nil
	}

	key := Device_Flow_Key{
		Name:        Name,
		MetricGroup: MetricGroup,
	}

	if lm, ok := t.Flow[key]; ok {
		return lm
	}
	return nil
}

// DeleteFlow deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteFlow(Name string, MetricGroup string) {
	key := Device_Flow_Key{
		Name:        Name,
		MetricGroup: MetricGroup,
	}

	delete(t.Flow, key)
}

// AppendFlow appends the supplied Flow struct to the
// list Flow of Device. If the key value(s) specified in
// the supplied Flow already exist in the list, an error is
// returned.
func (t *Device) AppendFlow(v *Flow) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key for Name")
	}

	if v.MetricGroup == nil {
		return fmt.Errorf("invalid nil key for MetricGroup")
	}

	key := Device_Flow_Key{
		Name:        *v.Name,
		MetricGroup: *v.MetricGroup,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flow == nil {
		t.Flow = make(map[Device_Flow_Key]*Flow)
	}

	if _, ok := t.Flow[key]; ok {
		return fmt.Errorf("duplicate key for list Flow %v", key)
	}

	t.Flow[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewInterface(Name string) (*Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateInterface(Name string) *Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetInterface(Name string) *Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Interface struct to the
// list Interface of Device. If the key value(s) specified in
// the supplied Interface already exist in the list, an error is
// returned.
func (t *Device) AppendInterface(v *Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewIsisRouter creates a new entry in the IsisRouter list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewIsisRouter(Name string) (*IsisRouter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IsisRouter == nil {
		t.IsisRouter = make(map[string]*IsisRouter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IsisRouter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IsisRouter", key)
	}

	t.IsisRouter[key] = &IsisRouter{
		Name: &Name,
	}

	return t.IsisRouter[key], nil
}

// RenameIsisRouter renames an entry in the list IsisRouter within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenameIsisRouter(oldK, newK string) error {
	if _, ok := t.IsisRouter[newK]; ok {
		return fmt.Errorf("key %v already exists in IsisRouter", newK)
	}

	e, ok := t.IsisRouter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IsisRouter", oldK)
	}
	e.Name = &newK

	t.IsisRouter[newK] = e
	delete(t.IsisRouter, oldK)
	return nil
}

// GetOrCreateIsisRouter retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreateIsisRouter(Name string) *IsisRouter {

	key := Name

	if v, ok := t.IsisRouter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIsisRouter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIsisRouter got unexpected error: %v", err))
	}
	return v
}

// GetIsisRouter retrieves the value with the specified key from
// the IsisRouter map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetIsisRouter(Name string) *IsisRouter {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.IsisRouter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIsisRouter deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeleteIsisRouter(Name string) {
	key := Name

	delete(t.IsisRouter, key)
}

// AppendIsisRouter appends the supplied IsisRouter struct to the
// list IsisRouter of Device. If the key value(s) specified in
// the supplied IsisRouter already exist in the list, an error is
// returned.
func (t *Device) AppendIsisRouter(v *IsisRouter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IsisRouter == nil {
		t.IsisRouter = make(map[string]*IsisRouter)
	}

	if _, ok := t.IsisRouter[key]; ok {
		return fmt.Errorf("duplicate key for list IsisRouter %v", key)
	}

	t.IsisRouter[key] = v
	return nil
}

// NewPort creates a new entry in the Port list of the
// Device struct. The keys of the list are populated from the input
// arguments.
func (t *Device) NewPort(Name string) (*Port, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*Port)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Port[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Port", key)
	}

	t.Port[key] = &Port{
		Name: &Name,
	}

	return t.Port[key], nil
}

// RenamePort renames an entry in the list Port within
// the Device struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Device) RenamePort(oldK, newK string) error {
	if _, ok := t.Port[newK]; ok {
		return fmt.Errorf("key %v already exists in Port", newK)
	}

	e, ok := t.Port[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Port", oldK)
	}
	e.Name = &newK

	t.Port[newK] = e
	delete(t.Port, oldK)
	return nil
}

// GetOrCreatePort retrieves the value with the specified keys from
// the receiver Device. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Device) GetOrCreatePort(Name string) *Port {

	key := Name

	if v, ok := t.Port[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPort(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePort got unexpected error: %v", err))
	}
	return v
}

// GetPort retrieves the value with the specified key from
// the Port map field of Device. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Device) GetPort(Name string) *Port {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Port[key]; ok {
		return lm
	}
	return nil
}

// DeletePort deletes the value with the specified keys from
// the receiver Device. If there is no such element, the function
// is a no-op.
func (t *Device) DeletePort(Name string) {
	key := Name

	delete(t.Port, key)
}

// AppendPort appends the supplied Port struct to the
// list Port of Device. If the key value(s) specified in
// the supplied Port already exist in the list, an error is
// returned.
func (t *Device) AppendPort(v *Port) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*Port)
	}

	if _, ok := t.Port[key]; ok {
		return fmt.Errorf("duplicate key for list Port %v", key)
	}

	t.Port[key] = v
	return nil
}

// GetOrCreateMeta retrieves the value of the Meta field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateMeta() *Meta {
	if t.Meta != nil {
		return t.Meta
	}
	t.Meta = &Meta{}
	return t.Meta
}

// GetMeta returns the value of the Meta struct pointer
// from Device. If the receiver or the field Meta is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetMeta() *Meta {
	if t != nil && t.Meta != nil {
		return t.Meta
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Device
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Device) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Meta.PopulateDefaults()
	for _, e := range t.BgpPeer {
		e.PopulateDefaults()
	}
	for _, e := range t.Flow {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.IsisRouter {
		e.PopulateDefaults()
	}
	for _, e := range t.Port {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Flow represents the /open-traffic-generator-flow/flows/flow YANG schema element.
type Flow struct {
	Counters     *Flow_Counters               `path:"state/counters" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	Enumeration  map[string]*Flow_Enumeration `path:"enumerations/enumeration" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	InFrameRate  Binary                       `path:"state/in-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	InRate       Binary                       `path:"state/in-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	LossPct      Binary                       `path:"state/loss-pct" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	MetricGroup  *string                      `path:"state/metric-group|metric-group" module:"open-traffic-generator-flow/open-traffic-generator-flow|open-traffic-generator-flow" shadow-path:"metric-group" shadow-module:"open-traffic-generator-flow"`
	Name         *string                      `path:"state/name|name" module:"open-traffic-generator-flow/open-traffic-generator-flow|open-traffic-generator-flow" shadow-path:"name" shadow-module:"open-traffic-generator-flow"`
	OutFrameRate Binary                       `path:"state/out-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	OutRate      Binary                       `path:"state/out-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
}

// IsYANGGoStruct ensures that Flow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow) IsYANGGoStruct() {}

// NewEnumeration creates a new entry in the Enumeration list of the
// Flow struct. The keys of the list are populated from the input
// arguments.
func (t *Flow) NewEnumeration(Name string) (*Flow_Enumeration, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Enumeration == nil {
		t.Enumeration = make(map[string]*Flow_Enumeration)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Enumeration[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Enumeration", key)
	}

	t.Enumeration[key] = &Flow_Enumeration{
		Name: &Name,
	}

	return t.Enumeration[key], nil
}

// RenameEnumeration renames an entry in the list Enumeration within
// the Flow struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Flow) RenameEnumeration(oldK, newK string) error {
	if _, ok := t.Enumeration[newK]; ok {
		return fmt.Errorf("key %v already exists in Enumeration", newK)
	}

	e, ok := t.Enumeration[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Enumeration", oldK)
	}
	e.Name = &newK

	t.Enumeration[newK] = e
	delete(t.Enumeration, oldK)
	return nil
}

// GetOrCreateEnumeration retrieves the value with the specified keys from
// the receiver Flow. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Flow) GetOrCreateEnumeration(Name string) *Flow_Enumeration {

	key := Name

	if v, ok := t.Enumeration[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEnumeration(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEnumeration got unexpected error: %v", err))
	}
	return v
}

// GetEnumeration retrieves the value with the specified key from
// the Enumeration map field of Flow. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Flow) GetEnumeration(Name string) *Flow_Enumeration {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Enumeration[key]; ok {
		return lm
	}
	return nil
}

// DeleteEnumeration deletes the value with the specified keys from
// the receiver Flow. If there is no such element, the function
// is a no-op.
func (t *Flow) DeleteEnumeration(Name string) {
	key := Name

	delete(t.Enumeration, key)
}

// AppendEnumeration appends the supplied Flow_Enumeration struct to the
// list Enumeration of Flow. If the key value(s) specified in
// the supplied Flow_Enumeration already exist in the list, an error is
// returned.
func (t *Flow) AppendEnumeration(v *Flow_Enumeration) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Enumeration == nil {
		t.Enumeration = make(map[string]*Flow_Enumeration)
	}

	if _, ok := t.Enumeration[key]; ok {
		return fmt.Errorf("duplicate key for list Enumeration %v", key)
	}

	t.Enumeration[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Flow) GetOrCreateCounters() *Flow_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Flow_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Flow. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Flow) GetCounters() *Flow_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInFrameRate retrieves the value of the leaf InFrameRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFrameRate is set, it can
// safely use t.GetInFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFrameRate == nil' before retrieving the leaf's value.
func (t *Flow) GetInFrameRate() Binary {
	if t == nil || t.InFrameRate == nil {
		return nil
	}
	return t.InFrameRate
}

// GetInRate retrieves the value of the leaf InRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRate is set, it can
// safely use t.GetInRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRate == nil' before retrieving the leaf's value.
func (t *Flow) GetInRate() Binary {
	if t == nil || t.InRate == nil {
		return nil
	}
	return t.InRate
}

// GetLossPct retrieves the value of the leaf LossPct from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossPct is set, it can
// safely use t.GetLossPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossPct == nil' before retrieving the leaf's value.
func (t *Flow) GetLossPct() Binary {
	if t == nil || t.LossPct == nil {
		return nil
	}
	return t.LossPct
}

// GetMetricGroup retrieves the value of the leaf MetricGroup from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricGroup is set, it can
// safely use t.GetMetricGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricGroup == nil' before retrieving the leaf's value.
func (t *Flow) GetMetricGroup() string {
	if t == nil || t.MetricGroup == nil {
		return ""
	}
	return *t.MetricGroup
}

// GetName retrieves the value of the leaf Name from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Flow) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOutFrameRate retrieves the value of the leaf OutFrameRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutFrameRate is set, it can
// safely use t.GetOutFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutFrameRate == nil' before retrieving the leaf's value.
func (t *Flow) GetOutFrameRate() Binary {
	if t == nil || t.OutFrameRate == nil {
		return nil
	}
	return t.OutFrameRate
}

// GetOutRate retrieves the value of the leaf OutRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRate is set, it can
// safely use t.GetOutRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRate == nil' before retrieving the leaf's value.
func (t *Flow) GetOutRate() Binary {
	if t == nil || t.OutRate == nil {
		return nil
	}
	return t.OutRate
}

// PopulateDefaults recursively populates unset leaf fields in the Flow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	for _, e := range t.Enumeration {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Flow struct, which is a YANG list entry.
func (t *Flow) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MetricGroup == nil {
		return nil, fmt.Errorf("nil value for key MetricGroup")
	}

	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"metric-group": *t.MetricGroup,
		"name":         *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Flow_Counters represents the /open-traffic-generator-flow/flows/flow/state/counters YANG schema element.
type Flow_Counters struct {
	InOctets  *uint64 `path:"in-octets" module:"open-traffic-generator-flow"`
	InPkts    *uint64 `path:"in-pkts" module:"open-traffic-generator-flow"`
	OutOctets *uint64 `path:"out-octets" module:"open-traffic-generator-flow"`
	OutPkts   *uint64 `path:"out-pkts" module:"open-traffic-generator-flow"`
}

// IsYANGGoStruct ensures that Flow_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_Counters) IsYANGGoStruct() {}

// GetInOctets retrieves the value of the leaf InOctets from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_Counters) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// Flow_Enumeration represents the /open-traffic-generator-flow/flows/flow/enumerations/enumeration YANG schema element.
type Flow_Enumeration struct {
	Counters     *Flow_Enumeration_Counters `path:"state/counters" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	InFrameRate  Binary                     `path:"state/in-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	InRate       Binary                     `path:"state/in-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	LossPct      Binary                     `path:"state/loss-pct" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	MetricGroup  *string                    `path:"state/metric-group" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	Name         *string                    `path:"state/name|name" module:"open-traffic-generator-flow/open-traffic-generator-flow|open-traffic-generator-flow" shadow-path:"name" shadow-module:"open-traffic-generator-flow"`
	OutFrameRate Binary                     `path:"state/out-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	OutRate      Binary                     `path:"state/out-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
}

// IsYANGGoStruct ensures that Flow_Enumeration implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_Enumeration) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Flow_Enumeration) GetOrCreateCounters() *Flow_Enumeration_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Flow_Enumeration_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Flow_Enumeration. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Flow_Enumeration) GetCounters() *Flow_Enumeration_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInFrameRate retrieves the value of the leaf InFrameRate from the Flow_Enumeration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFrameRate is set, it can
// safely use t.GetInFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFrameRate == nil' before retrieving the leaf's value.
func (t *Flow_Enumeration) GetInFrameRate() Binary {
	if t == nil || t.InFrameRate == nil {
		return nil
	}
	return t.InFrameRate
}

// GetInRate retrieves the value of the leaf InRate from the Flow_Enumeration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRate is set, it can
// safely use t.GetInRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRate == nil' before retrieving the leaf's value.
func (t *Flow_Enumeration) GetInRate() Binary {
	if t == nil || t.InRate == nil {
		return nil
	}
	return t.InRate
}

// GetLossPct retrieves the value of the leaf LossPct from the Flow_Enumeration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossPct is set, it can
// safely use t.GetLossPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossPct == nil' before retrieving the leaf's value.
func (t *Flow_Enumeration) GetLossPct() Binary {
	if t == nil || t.LossPct == nil {
		return nil
	}
	return t.LossPct
}

// GetMetricGroup retrieves the value of the leaf MetricGroup from the Flow_Enumeration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MetricGroup is set, it can
// safely use t.GetMetricGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MetricGroup == nil' before retrieving the leaf's value.
func (t *Flow_Enumeration) GetMetricGroup() string {
	if t == nil || t.MetricGroup == nil {
		return ""
	}
	return *t.MetricGroup
}

// GetName retrieves the value of the leaf Name from the Flow_Enumeration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Flow_Enumeration) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOutFrameRate retrieves the value of the leaf OutFrameRate from the Flow_Enumeration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutFrameRate is set, it can
// safely use t.GetOutFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutFrameRate == nil' before retrieving the leaf's value.
func (t *Flow_Enumeration) GetOutFrameRate() Binary {
	if t == nil || t.OutFrameRate == nil {
		return nil
	}
	return t.OutFrameRate
}

// GetOutRate retrieves the value of the leaf OutRate from the Flow_Enumeration
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRate is set, it can
// safely use t.GetOutRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRate == nil' before retrieving the leaf's value.
func (t *Flow_Enumeration) GetOutRate() Binary {
	if t == nil || t.OutRate == nil {
		return nil
	}
	return t.OutRate
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_Enumeration
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_Enumeration) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Flow_Enumeration struct, which is a YANG list entry.
func (t *Flow_Enumeration) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_Enumeration) Validate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_Enumeration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_Enumeration) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }
