/*
Package oc is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by ygnmi version: v0.8.1: (ygot: v0.29.0)
using the following YANG input files:
  - gnmi-collector-metadata.yang
  - gnsi/authz/gnsi-authz.yang
  - gnsi/cert/gnsi-cert.yang
  - gnsi/console/gnsi-console.yang
  - gnsi/pathz/gnsi-pathz.yang
  - gnsi/ssh/gnsi-ssh.yang
  - public/release/models/acl/openconfig-acl.yang
  - public/release/models/acl/openconfig-packet-match.yang
  - public/release/models/aft/openconfig-aft.yang
  - public/release/models/aft/openconfig-aft-network-instance.yang
  - public/release/models/ate/openconfig-ate-flow.yang
  - public/release/models/ate/openconfig-ate-intf.yang
  - public/release/models/bfd/openconfig-bfd.yang
  - public/release/models/bgp/openconfig-bgp-policy.yang
  - public/release/models/bgp/openconfig-bgp-types.yang
  - public/release/models/interfaces/openconfig-if-aggregate.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/interfaces/openconfig-if-ethernet-ext.yang
  - public/release/models/interfaces/openconfig-if-ip-ext.yang
  - public/release/models/interfaces/openconfig-if-ip.yang
  - public/release/models/interfaces/openconfig-if-sdn-ext.yang
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/isis/openconfig-isis.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - public/release/models/lldp/openconfig-lldp-types.yang
  - public/release/models/lldp/openconfig-lldp.yang
  - public/release/models/local-routing/openconfig-local-routing.yang
  - public/release/models/mpls/openconfig-mpls-types.yang
  - public/release/models/multicast/openconfig-pim.yang
  - public/release/models/network-instance/openconfig-network-instance.yang
  - public/release/models/openconfig-extensions.yang
  - public/release/models/optical-transport/openconfig-terminal-device.yang
  - public/release/models/optical-transport/openconfig-transport-types.yang
  - public/release/models/ospf/openconfig-ospfv2.yang
  - public/release/models/p4rt/openconfig-p4rt.yang
  - public/release/models/platform/openconfig-platform-controller-card.yang
  - public/release/models/platform/openconfig-platform-cpu.yang
  - public/release/models/platform/openconfig-platform-ext.yang
  - public/release/models/platform/openconfig-platform-fabric.yang
  - public/release/models/platform/openconfig-platform-fan.yang
  - public/release/models/platform/openconfig-platform-integrated-circuit.yang
  - public/release/models/platform/openconfig-platform-linecard.yang
  - public/release/models/platform/openconfig-platform-pipeline-counters.yang
  - public/release/models/platform/openconfig-platform-software.yang
  - public/release/models/platform/openconfig-platform-transceiver.yang
  - public/release/models/platform/openconfig-platform.yang
  - public/release/models/policy-forwarding/openconfig-policy-forwarding.yang
  - public/release/models/policy/openconfig-policy-types.yang
  - public/release/models/qos/openconfig-qos-elements.yang
  - public/release/models/qos/openconfig-qos-interfaces.yang
  - public/release/models/qos/openconfig-qos-types.yang
  - public/release/models/qos/openconfig-qos.yang
  - public/release/models/rib/openconfig-rib-bgp.yang
  - public/release/models/sampling/openconfig-sampling-sflow.yang
  - public/release/models/segment-routing/openconfig-segment-routing-types.yang
  - public/release/models/system/openconfig-system.yang
  - public/release/models/types/openconfig-inet-types.yang
  - public/release/models/types/openconfig-types.yang
  - public/release/models/types/openconfig-yang-types.yang
  - public/release/models/vlan/openconfig-vlan.yang
  - public/third_party/ietf/iana-if-type.yang
  - public/third_party/ietf/ietf-inet-types.yang
  - public/third_party/ietf/ietf-interfaces.yang
  - public/third_party/ietf/ietf-yang-types.yang

Imported modules were sourced from:
  - public/release/models/...
  - public/third_party/ietf/...
*/
package oc

import (
	"fmt"
)

// Acl_AclSet_AclEntry_Ipv4_Protocol_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/ipv4/state/protocol within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8].
type Acl_AclSet_AclEntry_Ipv4_Protocol_Union interface {
	// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8]
	Documentation_for_Acl_AclSet_AclEntry_Ipv4_Protocol_Union()
}

// Documentation_for_Acl_AclSet_AclEntry_Ipv4_Protocol_Union ensures that E_PacketMatchTypes_IP_PROTOCOL
// implements the Acl_AclSet_AclEntry_Ipv4_Protocol_Union interface.
func (E_PacketMatchTypes_IP_PROTOCOL) Documentation_for_Acl_AclSet_AclEntry_Ipv4_Protocol_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_Ipv4_Protocol_Union ensures that UnionUint8
// implements the Acl_AclSet_AclEntry_Ipv4_Protocol_Union interface.
func (UnionUint8) Documentation_for_Acl_AclSet_AclEntry_Ipv4_Protocol_Union() {}

// To_Acl_AclSet_AclEntry_Ipv4_Protocol_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Acl_AclSet_AclEntry_Ipv4_Protocol_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Acl_AclSet_AclEntry_Ipv4) To_Acl_AclSet_AclEntry_Ipv4_Protocol_Union(i interface{}) (Acl_AclSet_AclEntry_Ipv4_Protocol_Union, error) {
	if v, ok := i.(Acl_AclSet_AclEntry_Ipv4_Protocol_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Acl_AclSet_AclEntry_Ipv4_Protocol_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_IP_PROTOCOL, uint8]", i, i)
}

// Acl_AclSet_AclEntry_Ipv6_Protocol_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/ipv6/state/protocol within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8].
type Acl_AclSet_AclEntry_Ipv6_Protocol_Union interface {
	// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8]
	Documentation_for_Acl_AclSet_AclEntry_Ipv6_Protocol_Union()
}

// Documentation_for_Acl_AclSet_AclEntry_Ipv6_Protocol_Union ensures that E_PacketMatchTypes_IP_PROTOCOL
// implements the Acl_AclSet_AclEntry_Ipv6_Protocol_Union interface.
func (E_PacketMatchTypes_IP_PROTOCOL) Documentation_for_Acl_AclSet_AclEntry_Ipv6_Protocol_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_Ipv6_Protocol_Union ensures that UnionUint8
// implements the Acl_AclSet_AclEntry_Ipv6_Protocol_Union interface.
func (UnionUint8) Documentation_for_Acl_AclSet_AclEntry_Ipv6_Protocol_Union() {}

// To_Acl_AclSet_AclEntry_Ipv6_Protocol_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Acl_AclSet_AclEntry_Ipv6_Protocol_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Acl_AclSet_AclEntry_Ipv6) To_Acl_AclSet_AclEntry_Ipv6_Protocol_Union(i interface{}) (Acl_AclSet_AclEntry_Ipv6_Protocol_Union, error) {
	if v, ok := i.(Acl_AclSet_AclEntry_Ipv6_Protocol_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Acl_AclSet_AclEntry_Ipv6_Protocol_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_IP_PROTOCOL, uint8]", i, i)
}

// Acl_AclSet_AclEntry_L2_Ethertype_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/l2/state/ethertype within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_ETHERTYPE, UnionUint16].
type Acl_AclSet_AclEntry_L2_Ethertype_Union interface {
	// Union type can be one of [E_PacketMatchTypes_ETHERTYPE, UnionUint16]
	Documentation_for_Acl_AclSet_AclEntry_L2_Ethertype_Union()
}

// Documentation_for_Acl_AclSet_AclEntry_L2_Ethertype_Union ensures that E_PacketMatchTypes_ETHERTYPE
// implements the Acl_AclSet_AclEntry_L2_Ethertype_Union interface.
func (E_PacketMatchTypes_ETHERTYPE) Documentation_for_Acl_AclSet_AclEntry_L2_Ethertype_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_L2_Ethertype_Union ensures that UnionUint16
// implements the Acl_AclSet_AclEntry_L2_Ethertype_Union interface.
func (UnionUint16) Documentation_for_Acl_AclSet_AclEntry_L2_Ethertype_Union() {}

// To_Acl_AclSet_AclEntry_L2_Ethertype_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Acl_AclSet_AclEntry_L2_Ethertype_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Acl_AclSet_AclEntry_L2) To_Acl_AclSet_AclEntry_L2_Ethertype_Union(i interface{}) (Acl_AclSet_AclEntry_L2_Ethertype_Union, error) {
	if v, ok := i.(Acl_AclSet_AclEntry_L2_Ethertype_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Acl_AclSet_AclEntry_L2_Ethertype_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_ETHERTYPE, uint16]", i, i)
}

// Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/mpls/state/end-label-value within the YANG schema.
// Union type can be one of [E_Mpls_EndLabelValue, UnionUint32].
type Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union interface {
	// Union type can be one of [E_Mpls_EndLabelValue, UnionUint32]
	Documentation_for_Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union()
}

// Documentation_for_Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union ensures that E_Mpls_EndLabelValue
// implements the Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union interface.
func (E_Mpls_EndLabelValue) Documentation_for_Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union ensures that UnionUint32
// implements the Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union interface.
func (UnionUint32) Documentation_for_Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union() {}

// To_Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Acl_AclSet_AclEntry_Mpls) To_Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union(i interface{}) (Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union, error) {
	if v, ok := i.(Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Acl_AclSet_AclEntry_Mpls_EndLabelValue_Union, unknown union type, got: %T, want any of [E_Mpls_EndLabelValue, uint32]", i, i)
}

// Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/mpls/state/start-label-value within the YANG schema.
// Union type can be one of [E_Mpls_StartLabelValue, UnionUint32].
type Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union interface {
	// Union type can be one of [E_Mpls_StartLabelValue, UnionUint32]
	Documentation_for_Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union()
}

// Documentation_for_Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union ensures that E_Mpls_StartLabelValue
// implements the Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union interface.
func (E_Mpls_StartLabelValue) Documentation_for_Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union ensures that UnionUint32
// implements the Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union interface.
func (UnionUint32) Documentation_for_Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union() {}

// To_Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Acl_AclSet_AclEntry_Mpls) To_Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union(i interface{}) (Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union, error) {
	if v, ok := i.(Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Acl_AclSet_AclEntry_Mpls_StartLabelValue_Union, unknown union type, got: %T, want any of [E_Mpls_StartLabelValue, uint32]", i, i)
}

// Acl_AclSet_AclEntry_Transport_DestinationPort_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/transport/state/destination-port within the YANG schema.
// Union type can be one of [E_Transport_DestinationPort, UnionString, UnionUint16].
type Acl_AclSet_AclEntry_Transport_DestinationPort_Union interface {
	// Union type can be one of [E_Transport_DestinationPort, UnionString, UnionUint16]
	Documentation_for_Acl_AclSet_AclEntry_Transport_DestinationPort_Union()
}

// Documentation_for_Acl_AclSet_AclEntry_Transport_DestinationPort_Union ensures that E_Transport_DestinationPort
// implements the Acl_AclSet_AclEntry_Transport_DestinationPort_Union interface.
func (E_Transport_DestinationPort) Documentation_for_Acl_AclSet_AclEntry_Transport_DestinationPort_Union() {
}

// Documentation_for_Acl_AclSet_AclEntry_Transport_DestinationPort_Union ensures that UnionString
// implements the Acl_AclSet_AclEntry_Transport_DestinationPort_Union interface.
func (UnionString) Documentation_for_Acl_AclSet_AclEntry_Transport_DestinationPort_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_Transport_DestinationPort_Union ensures that UnionUint16
// implements the Acl_AclSet_AclEntry_Transport_DestinationPort_Union interface.
func (UnionUint16) Documentation_for_Acl_AclSet_AclEntry_Transport_DestinationPort_Union() {}

// To_Acl_AclSet_AclEntry_Transport_DestinationPort_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Acl_AclSet_AclEntry_Transport_DestinationPort_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Acl_AclSet_AclEntry_Transport) To_Acl_AclSet_AclEntry_Transport_DestinationPort_Union(i interface{}) (Acl_AclSet_AclEntry_Transport_DestinationPort_Union, error) {
	if v, ok := i.(Acl_AclSet_AclEntry_Transport_DestinationPort_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Acl_AclSet_AclEntry_Transport_DestinationPort_Union, unknown union type, got: %T, want any of [E_Transport_DestinationPort, string, uint16]", i, i)
}

// Acl_AclSet_AclEntry_Transport_SourcePort_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-acl/acl/acl-sets/acl-set/acl-entries/acl-entry/transport/state/source-port within the YANG schema.
// Union type can be one of [E_Transport_SourcePort, UnionString, UnionUint16].
type Acl_AclSet_AclEntry_Transport_SourcePort_Union interface {
	// Union type can be one of [E_Transport_SourcePort, UnionString, UnionUint16]
	Documentation_for_Acl_AclSet_AclEntry_Transport_SourcePort_Union()
}

// Documentation_for_Acl_AclSet_AclEntry_Transport_SourcePort_Union ensures that E_Transport_SourcePort
// implements the Acl_AclSet_AclEntry_Transport_SourcePort_Union interface.
func (E_Transport_SourcePort) Documentation_for_Acl_AclSet_AclEntry_Transport_SourcePort_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_Transport_SourcePort_Union ensures that UnionString
// implements the Acl_AclSet_AclEntry_Transport_SourcePort_Union interface.
func (UnionString) Documentation_for_Acl_AclSet_AclEntry_Transport_SourcePort_Union() {}

// Documentation_for_Acl_AclSet_AclEntry_Transport_SourcePort_Union ensures that UnionUint16
// implements the Acl_AclSet_AclEntry_Transport_SourcePort_Union interface.
func (UnionUint16) Documentation_for_Acl_AclSet_AclEntry_Transport_SourcePort_Union() {}

// To_Acl_AclSet_AclEntry_Transport_SourcePort_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Acl_AclSet_AclEntry_Transport_SourcePort_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Acl_AclSet_AclEntry_Transport) To_Acl_AclSet_AclEntry_Transport_SourcePort_Union(i interface{}) (Acl_AclSet_AclEntry_Transport_SourcePort_Union, error) {
	if v, ok := i.(Acl_AclSet_AclEntry_Transport_SourcePort_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Acl_AclSet_AclEntry_Transport_SourcePort_Union, unknown union type, got: %T, want any of [E_Transport_SourcePort, string, uint16]", i, i)
}

// Component_Type_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-platform/components/component/state/type within the YANG schema.
// Union type can be one of [E_PlatformTypes_OPENCONFIG_HARDWARE_COMPONENT, E_PlatformTypes_OPENCONFIG_SOFTWARE_COMPONENT].
type Component_Type_Union interface {
	// Union type can be one of [E_PlatformTypes_OPENCONFIG_HARDWARE_COMPONENT, E_PlatformTypes_OPENCONFIG_SOFTWARE_COMPONENT]
	Documentation_for_Component_Type_Union()
}

// Documentation_for_Component_Type_Union ensures that E_PlatformTypes_OPENCONFIG_HARDWARE_COMPONENT
// implements the Component_Type_Union interface.
func (E_PlatformTypes_OPENCONFIG_HARDWARE_COMPONENT) Documentation_for_Component_Type_Union() {}

// Documentation_for_Component_Type_Union ensures that E_PlatformTypes_OPENCONFIG_SOFTWARE_COMPONENT
// implements the Component_Type_Union interface.
func (E_PlatformTypes_OPENCONFIG_SOFTWARE_COMPONENT) Documentation_for_Component_Type_Union() {}

// To_Component_Type_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Component_Type_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Component) To_Component_Type_Union(i interface{}) (Component_Type_Union, error) {
	if v, ok := i.(Component_Type_Union); ok {
		return v, nil
	}
	return nil, fmt.Errorf("cannot convert %v to Component_Type_Union, unknown union type, got: %T, want any of [E_PlatformTypes_OPENCONFIG_HARDWARE_COMPONENT, E_PlatformTypes_OPENCONFIG_SOFTWARE_COMPONENT]", i, i)
}

// Component_Property_Value_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-platform/components/component/properties/property/state/value within the YANG schema.
// Union type can be one of [UnionBool, UnionFloat64, UnionInt64, UnionString, UnionUint64].
type Component_Property_Value_Union interface {
	// Union type can be one of [UnionBool, UnionFloat64, UnionInt64, UnionString, UnionUint64]
	Documentation_for_Component_Property_Value_Union()
}

// Documentation_for_Component_Property_Value_Union ensures that UnionBool
// implements the Component_Property_Value_Union interface.
func (UnionBool) Documentation_for_Component_Property_Value_Union() {}

// Documentation_for_Component_Property_Value_Union ensures that UnionFloat64
// implements the Component_Property_Value_Union interface.
func (UnionFloat64) Documentation_for_Component_Property_Value_Union() {}

// Documentation_for_Component_Property_Value_Union ensures that UnionInt64
// implements the Component_Property_Value_Union interface.
func (UnionInt64) Documentation_for_Component_Property_Value_Union() {}

// Documentation_for_Component_Property_Value_Union ensures that UnionString
// implements the Component_Property_Value_Union interface.
func (UnionString) Documentation_for_Component_Property_Value_Union() {}

// Documentation_for_Component_Property_Value_Union ensures that UnionUint64
// implements the Component_Property_Value_Union interface.
func (UnionUint64) Documentation_for_Component_Property_Value_Union() {}

// To_Component_Property_Value_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Component_Property_Value_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Component_Property) To_Component_Property_Value_Union(i interface{}) (Component_Property_Value_Union, error) {
	if v, ok := i.(Component_Property_Value_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case bool:
		return UnionBool(v), nil
	case float64:
		return UnionFloat64(v), nil
	case int64:
		return UnionInt64(v), nil
	case string:
		return UnionString(v), nil
	case uint64:
		return UnionUint64(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Component_Property_Value_Union, unknown union type, got: %T, want any of [bool, float64, int64, string, uint64]", i, i)
}

// DefinedSets_PortSet_Port_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-defined-sets/defined-sets/port-sets/port-set/state/port within the YANG schema.
// Union type can be one of [E_PortSet_Port, UnionString, UnionUint16].
type DefinedSets_PortSet_Port_Union interface {
	// Union type can be one of [E_PortSet_Port, UnionString, UnionUint16]
	Documentation_for_DefinedSets_PortSet_Port_Union()
}

// Documentation_for_DefinedSets_PortSet_Port_Union ensures that E_PortSet_Port
// implements the DefinedSets_PortSet_Port_Union interface.
func (E_PortSet_Port) Documentation_for_DefinedSets_PortSet_Port_Union() {}

// Documentation_for_DefinedSets_PortSet_Port_Union ensures that UnionString
// implements the DefinedSets_PortSet_Port_Union interface.
func (UnionString) Documentation_for_DefinedSets_PortSet_Port_Union() {}

// Documentation_for_DefinedSets_PortSet_Port_Union ensures that UnionUint16
// implements the DefinedSets_PortSet_Port_Union interface.
func (UnionUint16) Documentation_for_DefinedSets_PortSet_Port_Union() {}

// To_DefinedSets_PortSet_Port_Union takes an input interface{} and attempts to convert it to a struct
// which implements the DefinedSets_PortSet_Port_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *DefinedSets_PortSet) To_DefinedSets_PortSet_Port_Union(i interface{}) (DefinedSets_PortSet_Port_Union, error) {
	if v, ok := i.(DefinedSets_PortSet_Port_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to DefinedSets_PortSet_Port_Union, unknown union type, got: %T, want any of [E_PortSet_Port, string, uint16]", i, i)
}

// Flow_MplsLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-ate-flow/flows/flow/state/mpls-label within the YANG schema.
// Union type can be one of [E_Flow_MplsLabel, UnionUint32].
type Flow_MplsLabel_Union interface {
	// Union type can be one of [E_Flow_MplsLabel, UnionUint32]
	Documentation_for_Flow_MplsLabel_Union()
}

// Documentation_for_Flow_MplsLabel_Union ensures that E_Flow_MplsLabel
// implements the Flow_MplsLabel_Union interface.
func (E_Flow_MplsLabel) Documentation_for_Flow_MplsLabel_Union() {}

// Documentation_for_Flow_MplsLabel_Union ensures that UnionUint32
// implements the Flow_MplsLabel_Union interface.
func (UnionUint32) Documentation_for_Flow_MplsLabel_Union() {}

// To_Flow_MplsLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Flow_MplsLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Flow) To_Flow_MplsLabel_Union(i interface{}) (Flow_MplsLabel_Union, error) {
	if v, ok := i.(Flow_MplsLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Flow_MplsLabel_Union, unknown union type, got: %T, want any of [E_Flow_MplsLabel, uint32]", i, i)
}

// Flow_IngressTracking_MplsLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-ate-flow/flows/flow/ingress-tracking/ingress-tracking/state/mpls-label within the YANG schema.
// Union type can be one of [E_IngressTracking_MplsLabel, UnionUint32].
type Flow_IngressTracking_MplsLabel_Union interface {
	// Union type can be one of [E_IngressTracking_MplsLabel, UnionUint32]
	Documentation_for_Flow_IngressTracking_MplsLabel_Union()
}

// Documentation_for_Flow_IngressTracking_MplsLabel_Union ensures that E_IngressTracking_MplsLabel
// implements the Flow_IngressTracking_MplsLabel_Union interface.
func (E_IngressTracking_MplsLabel) Documentation_for_Flow_IngressTracking_MplsLabel_Union() {}

// Documentation_for_Flow_IngressTracking_MplsLabel_Union ensures that UnionUint32
// implements the Flow_IngressTracking_MplsLabel_Union interface.
func (UnionUint32) Documentation_for_Flow_IngressTracking_MplsLabel_Union() {}

// To_Flow_IngressTracking_MplsLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Flow_IngressTracking_MplsLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Flow_IngressTracking) To_Flow_IngressTracking_MplsLabel_Union(i interface{}) (Flow_IngressTracking_MplsLabel_Union, error) {
	if v, ok := i.(Flow_IngressTracking_MplsLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Flow_IngressTracking_MplsLabel_Union, unknown union type, got: %T, want any of [E_IngressTracking_MplsLabel, uint32]", i, i)
}

// Interface_Aggregation_SwitchedVlan_TrunkVlans_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-interfaces/interfaces/interface/aggregation/switched-vlan/state/trunk-vlans within the YANG schema.
// Union type can be one of [UnionString, UnionUint16].
type Interface_Aggregation_SwitchedVlan_TrunkVlans_Union interface {
	// Union type can be one of [UnionString, UnionUint16]
	Documentation_for_Interface_Aggregation_SwitchedVlan_TrunkVlans_Union()
}

// Documentation_for_Interface_Aggregation_SwitchedVlan_TrunkVlans_Union ensures that UnionString
// implements the Interface_Aggregation_SwitchedVlan_TrunkVlans_Union interface.
func (UnionString) Documentation_for_Interface_Aggregation_SwitchedVlan_TrunkVlans_Union() {}

// Documentation_for_Interface_Aggregation_SwitchedVlan_TrunkVlans_Union ensures that UnionUint16
// implements the Interface_Aggregation_SwitchedVlan_TrunkVlans_Union interface.
func (UnionUint16) Documentation_for_Interface_Aggregation_SwitchedVlan_TrunkVlans_Union() {}

// To_Interface_Aggregation_SwitchedVlan_TrunkVlans_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Interface_Aggregation_SwitchedVlan_TrunkVlans_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Interface_Aggregation_SwitchedVlan) To_Interface_Aggregation_SwitchedVlan_TrunkVlans_Union(i interface{}) (Interface_Aggregation_SwitchedVlan_TrunkVlans_Union, error) {
	if v, ok := i.(Interface_Aggregation_SwitchedVlan_TrunkVlans_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Interface_Aggregation_SwitchedVlan_TrunkVlans_Union, unknown union type, got: %T, want any of [string, uint16]", i, i)
}

// Interface_Ethernet_SwitchedVlan_TrunkVlans_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-interfaces/interfaces/interface/ethernet/switched-vlan/state/trunk-vlans within the YANG schema.
// Union type can be one of [UnionString, UnionUint16].
type Interface_Ethernet_SwitchedVlan_TrunkVlans_Union interface {
	// Union type can be one of [UnionString, UnionUint16]
	Documentation_for_Interface_Ethernet_SwitchedVlan_TrunkVlans_Union()
}

// Documentation_for_Interface_Ethernet_SwitchedVlan_TrunkVlans_Union ensures that UnionString
// implements the Interface_Ethernet_SwitchedVlan_TrunkVlans_Union interface.
func (UnionString) Documentation_for_Interface_Ethernet_SwitchedVlan_TrunkVlans_Union() {}

// Documentation_for_Interface_Ethernet_SwitchedVlan_TrunkVlans_Union ensures that UnionUint16
// implements the Interface_Ethernet_SwitchedVlan_TrunkVlans_Union interface.
func (UnionUint16) Documentation_for_Interface_Ethernet_SwitchedVlan_TrunkVlans_Union() {}

// To_Interface_Ethernet_SwitchedVlan_TrunkVlans_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Interface_Ethernet_SwitchedVlan_TrunkVlans_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Interface_Ethernet_SwitchedVlan) To_Interface_Ethernet_SwitchedVlan_TrunkVlans_Union(i interface{}) (Interface_Ethernet_SwitchedVlan_TrunkVlans_Union, error) {
	if v, ok := i.(Interface_Ethernet_SwitchedVlan_TrunkVlans_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Interface_Ethernet_SwitchedVlan_TrunkVlans_Union, unknown union type, got: %T, want any of [string, uint16]", i, i)
}

// Interface_RoutedVlan_Vlan_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-interfaces/interfaces/interface/routed-vlan/state/vlan within the YANG schema.
// Union type can be one of [UnionString, UnionUint16].
type Interface_RoutedVlan_Vlan_Union interface {
	// Union type can be one of [UnionString, UnionUint16]
	Documentation_for_Interface_RoutedVlan_Vlan_Union()
}

// Documentation_for_Interface_RoutedVlan_Vlan_Union ensures that UnionString
// implements the Interface_RoutedVlan_Vlan_Union interface.
func (UnionString) Documentation_for_Interface_RoutedVlan_Vlan_Union() {}

// Documentation_for_Interface_RoutedVlan_Vlan_Union ensures that UnionUint16
// implements the Interface_RoutedVlan_Vlan_Union interface.
func (UnionUint16) Documentation_for_Interface_RoutedVlan_Vlan_Union() {}

// To_Interface_RoutedVlan_Vlan_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Interface_RoutedVlan_Vlan_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Interface_RoutedVlan) To_Interface_RoutedVlan_Vlan_Union(i interface{}) (Interface_RoutedVlan_Vlan_Union, error) {
	if v, ok := i.(Interface_RoutedVlan_Vlan_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Interface_RoutedVlan_Vlan_Union, unknown union type, got: %T, want any of [string, uint16]", i, i)
}

// Interface_Subinterface_Vlan_VlanId_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-interfaces/interfaces/interface/subinterfaces/subinterface/vlan/state/vlan-id within the YANG schema.
// Union type can be one of [UnionString, UnionUint16].
type Interface_Subinterface_Vlan_VlanId_Union interface {
	// Union type can be one of [UnionString, UnionUint16]
	Documentation_for_Interface_Subinterface_Vlan_VlanId_Union()
}

// Documentation_for_Interface_Subinterface_Vlan_VlanId_Union ensures that UnionString
// implements the Interface_Subinterface_Vlan_VlanId_Union interface.
func (UnionString) Documentation_for_Interface_Subinterface_Vlan_VlanId_Union() {}

// Documentation_for_Interface_Subinterface_Vlan_VlanId_Union ensures that UnionUint16
// implements the Interface_Subinterface_Vlan_VlanId_Union interface.
func (UnionUint16) Documentation_for_Interface_Subinterface_Vlan_VlanId_Union() {}

// To_Interface_Subinterface_Vlan_VlanId_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Interface_Subinterface_Vlan_VlanId_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Interface_Subinterface_Vlan) To_Interface_Subinterface_Vlan_VlanId_Union(i interface{}) (Interface_Subinterface_Vlan_VlanId_Union, error) {
	if v, ok := i.(Interface_Subinterface_Vlan_VlanId_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Interface_Subinterface_Vlan_VlanId_Union, unknown union type, got: %T, want any of [string, uint16]", i, i)
}

// Keychain_Tolerance_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-keychain/keychains/keychain/state/tolerance within the YANG schema.
// Union type can be one of [E_Keychain_Tolerance, UnionUint32].
type Keychain_Tolerance_Union interface {
	// Union type can be one of [E_Keychain_Tolerance, UnionUint32]
	Documentation_for_Keychain_Tolerance_Union()
}

// Documentation_for_Keychain_Tolerance_Union ensures that E_Keychain_Tolerance
// implements the Keychain_Tolerance_Union interface.
func (E_Keychain_Tolerance) Documentation_for_Keychain_Tolerance_Union() {}

// Documentation_for_Keychain_Tolerance_Union ensures that UnionUint32
// implements the Keychain_Tolerance_Union interface.
func (UnionUint32) Documentation_for_Keychain_Tolerance_Union() {}

// To_Keychain_Tolerance_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Keychain_Tolerance_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Keychain) To_Keychain_Tolerance_Union(i interface{}) (Keychain_Tolerance_Union, error) {
	if v, ok := i.(Keychain_Tolerance_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Keychain_Tolerance_Union, unknown union type, got: %T, want any of [E_Keychain_Tolerance, uint32]", i, i)
}

// Keychain_Key_KeyId_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-keychain/keychains/keychain/keys/key/state/key-id within the YANG schema.
// Union type can be one of [UnionString, UnionUint64].
type Keychain_Key_KeyId_Union interface {
	// Union type can be one of [UnionString, UnionUint64]
	Documentation_for_Keychain_Key_KeyId_Union()
}

// Documentation_for_Keychain_Key_KeyId_Union ensures that UnionString
// implements the Keychain_Key_KeyId_Union interface.
func (UnionString) Documentation_for_Keychain_Key_KeyId_Union() {}

// Documentation_for_Keychain_Key_KeyId_Union ensures that UnionUint64
// implements the Keychain_Key_KeyId_Union interface.
func (UnionUint64) Documentation_for_Keychain_Key_KeyId_Union() {}

// To_Keychain_Key_KeyId_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Keychain_Key_KeyId_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Keychain_Key) To_Keychain_Key_KeyId_Union(i interface{}) (Keychain_Key_KeyId_Union, error) {
	if v, ok := i.(Keychain_Key_KeyId_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint64:
		return UnionUint64(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Keychain_Key_KeyId_Union, unknown union type, got: %T, want any of [string, uint64]", i, i)
}

// NetworkInstance_Afts_LabelEntry_Label_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/label within the YANG schema.
// Union type can be one of [E_LabelEntry_Label, UnionUint32].
type NetworkInstance_Afts_LabelEntry_Label_Union interface {
	// Union type can be one of [E_LabelEntry_Label, UnionUint32]
	Documentation_for_NetworkInstance_Afts_LabelEntry_Label_Union()
}

// Documentation_for_NetworkInstance_Afts_LabelEntry_Label_Union ensures that E_LabelEntry_Label
// implements the NetworkInstance_Afts_LabelEntry_Label_Union interface.
func (E_LabelEntry_Label) Documentation_for_NetworkInstance_Afts_LabelEntry_Label_Union() {}

// Documentation_for_NetworkInstance_Afts_LabelEntry_Label_Union ensures that UnionUint32
// implements the NetworkInstance_Afts_LabelEntry_Label_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Afts_LabelEntry_Label_Union() {}

// To_NetworkInstance_Afts_LabelEntry_Label_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Afts_LabelEntry_Label_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Afts_LabelEntry) To_NetworkInstance_Afts_LabelEntry_Label_Union(i interface{}) (NetworkInstance_Afts_LabelEntry_Label_Union, error) {
	if v, ok := i.(NetworkInstance_Afts_LabelEntry_Label_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Afts_LabelEntry_Label_Union, unknown union type, got: %T, want any of [E_LabelEntry_Label, uint32]", i, i)
}

// NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/afts/mpls/label-entry/state/popped-mpls-label-stack within the YANG schema.
// Union type can be one of [E_LabelEntry_PoppedMplsLabelStack, UnionUint32].
type NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union interface {
	// Union type can be one of [E_LabelEntry_PoppedMplsLabelStack, UnionUint32]
	Documentation_for_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union()
}

// Documentation_for_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union ensures that E_LabelEntry_PoppedMplsLabelStack
// implements the NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union interface.
func (E_LabelEntry_PoppedMplsLabelStack) Documentation_for_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union() {
}

// Documentation_for_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union ensures that UnionUint32
// implements the NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union() {}

// To_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Afts_LabelEntry) To_NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union(i interface{}) (NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union, error) {
	if v, ok := i.(NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Afts_LabelEntry_PoppedMplsLabelStack_Union, unknown union type, got: %T, want any of [E_LabelEntry_PoppedMplsLabelStack, uint32]", i, i)
}

// NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/afts/next-hops/next-hop/state/pushed-mpls-label-stack within the YANG schema.
// Union type can be one of [E_NextHop_PushedMplsLabelStack, UnionUint32].
type NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union interface {
	// Union type can be one of [E_NextHop_PushedMplsLabelStack, UnionUint32]
	Documentation_for_NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union()
}

// Documentation_for_NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union ensures that E_NextHop_PushedMplsLabelStack
// implements the NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union interface.
func (E_NextHop_PushedMplsLabelStack) Documentation_for_NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union() {
}

// Documentation_for_NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union ensures that UnionUint32
// implements the NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union() {}

// To_NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Afts_NextHop) To_NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union(i interface{}) (NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union, error) {
	if v, ok := i.(NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Afts_NextHop_PushedMplsLabelStack_Union, unknown union type, got: %T, want any of [E_NextHop_PushedMplsLabelStack, uint32]", i, i)
}

// NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/ip-protocol within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8].
type NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union interface {
	// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8]
	Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union()
}

// Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union ensures that E_PacketMatchTypes_IP_PROTOCOL
// implements the NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union interface.
func (E_PacketMatchTypes_IP_PROTOCOL) Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union() {
}

// Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union ensures that UnionUint8
// implements the NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union interface.
func (UnionUint8) Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union() {}

// To_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) To_NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union(i interface{}) (NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union, error) {
	if v, ok := i.(NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Afts_PolicyForwardingEntry_IpProtocol_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_IP_PROTOCOL, uint8]", i, i)
}

// NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/afts/policy-forwarding/policy-forwarding-entry/state/mpls-label within the YANG schema.
// Union type can be one of [E_PolicyForwardingEntry_MplsLabel, UnionUint32].
type NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union interface {
	// Union type can be one of [E_PolicyForwardingEntry_MplsLabel, UnionUint32]
	Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union()
}

// Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union ensures that E_PolicyForwardingEntry_MplsLabel
// implements the NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union interface.
func (E_PolicyForwardingEntry_MplsLabel) Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union() {
}

// Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union() {}

// To_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Afts_PolicyForwardingEntry) To_NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union(i interface{}) (NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Afts_PolicyForwardingEntry_MplsLabel_Union, unknown union type, got: %T, want any of [E_PolicyForwardingEntry_MplsLabel, uint32]", i, i)
}

// NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/connection-points/connection-point/endpoints/endpoint/vxlan/endpoint-vnis/endpoint-vni/state/multidestination-traffic within the YANG schema.
// Union type can be one of [E_EndpointVni_MultidestinationTraffic, UnionString].
type NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union interface {
	// Union type can be one of [E_EndpointVni_MultidestinationTraffic, UnionString]
	Documentation_for_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union()
}

// Documentation_for_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union ensures that E_EndpointVni_MultidestinationTraffic
// implements the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union interface.
func (E_EndpointVni_MultidestinationTraffic) Documentation_for_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union() {
}

// Documentation_for_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union ensures that UnionString
// implements the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union interface.
func (UnionString) Documentation_for_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union() {
}

// To_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni) To_NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union(i interface{}) (NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union, error) {
	if v, ok := i.(NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_ConnectionPoint_Endpoint_Vxlan_EndpointVni_MultidestinationTraffic_Union, unknown union type, got: %T, want any of [E_EndpointVni_MultidestinationTraffic, string]", i, i)
}

// NetworkInstance_Evpn_EthernetSegment_Esi_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/evpn/ethernet-segments/ethernet-segment/state/esi within the YANG schema.
// Union type can be one of [E_EthernetSegment_Esi, UnionString].
type NetworkInstance_Evpn_EthernetSegment_Esi_Union interface {
	// Union type can be one of [E_EthernetSegment_Esi, UnionString]
	Documentation_for_NetworkInstance_Evpn_EthernetSegment_Esi_Union()
}

// Documentation_for_NetworkInstance_Evpn_EthernetSegment_Esi_Union ensures that E_EthernetSegment_Esi
// implements the NetworkInstance_Evpn_EthernetSegment_Esi_Union interface.
func (E_EthernetSegment_Esi) Documentation_for_NetworkInstance_Evpn_EthernetSegment_Esi_Union() {}

// Documentation_for_NetworkInstance_Evpn_EthernetSegment_Esi_Union ensures that UnionString
// implements the NetworkInstance_Evpn_EthernetSegment_Esi_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Evpn_EthernetSegment_Esi_Union() {}

// To_NetworkInstance_Evpn_EthernetSegment_Esi_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Evpn_EthernetSegment_Esi_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Evpn_EthernetSegment) To_NetworkInstance_Evpn_EthernetSegment_Esi_Union(i interface{}) (NetworkInstance_Evpn_EthernetSegment_Esi_Union, error) {
	if v, ok := i.(NetworkInstance_Evpn_EthernetSegment_Esi_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Evpn_EthernetSegment_Esi_Union, unknown union type, got: %T, want any of [E_EthernetSegment_Esi, string]", i, i)
}

// NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/state/route-distinguisher within the YANG schema.
// Union type can be one of [E_EvpnInstance_RouteDistinguisher, UnionString].
type NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union interface {
	// Union type can be one of [E_EvpnInstance_RouteDistinguisher, UnionString]
	Documentation_for_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union()
}

// Documentation_for_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union ensures that E_EvpnInstance_RouteDistinguisher
// implements the NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union interface.
func (E_EvpnInstance_RouteDistinguisher) Documentation_for_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union() {
}

// Documentation_for_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union ensures that UnionString
// implements the NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union() {}

// To_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Evpn_EvpnInstance) To_NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union(i interface{}) (NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union, error) {
	if v, ok := i.(NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Evpn_EvpnInstance_RouteDistinguisher_Union, unknown union type, got: %T, want any of [E_EvpnInstance_RouteDistinguisher, string]", i, i)
}

// NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/export-route-target within the YANG schema.
// Union type can be one of [E_ImportExportPolicy_ExportRouteTarget, UnionString].
type NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union interface {
	// Union type can be one of [E_ImportExportPolicy_ExportRouteTarget, UnionString]
	Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union()
}

// Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union ensures that E_ImportExportPolicy_ExportRouteTarget
// implements the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union interface.
func (E_ImportExportPolicy_ExportRouteTarget) Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union() {
}

// Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union ensures that UnionString
// implements the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union() {
}

// To_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) To_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union(i interface{}) (NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union, error) {
	if v, ok := i.(NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ExportRouteTarget_Union, unknown union type, got: %T, want any of [E_ImportExportPolicy_ExportRouteTarget, string]", i, i)
}

// NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/evpn/evpn-instances/evpn-instance/import-export-policy/state/import-route-target within the YANG schema.
// Union type can be one of [E_ImportExportPolicy_ImportRouteTarget, UnionString].
type NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union interface {
	// Union type can be one of [E_ImportExportPolicy_ImportRouteTarget, UnionString]
	Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union()
}

// Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union ensures that E_ImportExportPolicy_ImportRouteTarget
// implements the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union interface.
func (E_ImportExportPolicy_ImportRouteTarget) Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union() {
}

// Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union ensures that UnionString
// implements the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union() {
}

// To_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy) To_NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union(i interface{}) (NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union, error) {
	if v, ok := i.(NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Evpn_EvpnInstance_ImportExportPolicy_ImportRouteTarget_Union, unknown union type, got: %T, want any of [E_ImportExportPolicy_ImportRouteTarget, string]", i, i)
}

// NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/state/export-route-target within the YANG schema.
// Union type can be one of [E_ImportExportPolicy_ExportRouteTarget, UnionString].
type NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union interface {
	// Union type can be one of [E_ImportExportPolicy_ExportRouteTarget, UnionString]
	Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union()
}

// Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union ensures that E_ImportExportPolicy_ExportRouteTarget
// implements the NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union interface.
func (E_ImportExportPolicy_ExportRouteTarget) Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union() {
}

// Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union ensures that UnionString
// implements the NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union interface.
func (UnionString) Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union() {
}

// To_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) To_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union(i interface{}) (NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union, error) {
	if v, ok := i.(NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_InterInstancePolicies_ImportExportPolicy_ExportRouteTarget_Union, unknown union type, got: %T, want any of [E_ImportExportPolicy_ExportRouteTarget, string]", i, i)
}

// NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/inter-instance-policies/import-export-policy/state/import-route-target within the YANG schema.
// Union type can be one of [E_ImportExportPolicy_ImportRouteTarget, UnionString].
type NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union interface {
	// Union type can be one of [E_ImportExportPolicy_ImportRouteTarget, UnionString]
	Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union()
}

// Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union ensures that E_ImportExportPolicy_ImportRouteTarget
// implements the NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union interface.
func (E_ImportExportPolicy_ImportRouteTarget) Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union() {
}

// Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union ensures that UnionString
// implements the NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union interface.
func (UnionString) Documentation_for_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union() {
}

// To_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_InterInstancePolicies_ImportExportPolicy) To_NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union(i interface{}) (NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union, error) {
	if v, ok := i.(NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_InterInstancePolicies_ImportExportPolicy_ImportRouteTarget_Union, unknown union type, got: %T, want any of [E_ImportExportPolicy_ImportRouteTarget, string]", i, i)
}

// NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/state/lower-bound within the YANG schema.
// Union type can be one of [E_ReservedLabelBlock_LowerBound, UnionUint32].
type NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union interface {
	// Union type can be one of [E_ReservedLabelBlock_LowerBound, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union()
}

// Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union ensures that E_ReservedLabelBlock_LowerBound
// implements the NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union interface.
func (E_ReservedLabelBlock_LowerBound) Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union() {
}

// To_NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) To_NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union(i interface{}) (NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Global_ReservedLabelBlock_LowerBound_Union, unknown union type, got: %T, want any of [E_ReservedLabelBlock_LowerBound, uint32]", i, i)
}

// NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/global/reserved-label-blocks/reserved-label-block/state/upper-bound within the YANG schema.
// Union type can be one of [E_ReservedLabelBlock_UpperBound, UnionUint32].
type NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union interface {
	// Union type can be one of [E_ReservedLabelBlock_UpperBound, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union()
}

// Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union ensures that E_ReservedLabelBlock_UpperBound
// implements the NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union interface.
func (E_ReservedLabelBlock_UpperBound) Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union() {
}

// To_NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Global_ReservedLabelBlock) To_NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union(i interface{}) (NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Global_ReservedLabelBlock_UpperBound_Union, unknown union type, got: %T, want any of [E_ReservedLabelBlock_UpperBound, uint32]", i, i)
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/incoming-label within the YANG schema.
// Union type can be one of [E_Egress_IncomingLabel, UnionUint32].
type NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union interface {
	// Union type can be one of [E_Egress_IncomingLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union ensures that E_Egress_IncomingLabel
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union interface.
func (E_Egress_IncomingLabel) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union() {
}

// To_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) To_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union(i interface{}) (NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Lsps_StaticLsp_Egress_IncomingLabel_Union, unknown union type, got: %T, want any of [E_Egress_IncomingLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/egress/state/push-label within the YANG schema.
// Union type can be one of [E_Egress_PushLabel, UnionUint32].
type NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union interface {
	// Union type can be one of [E_Egress_PushLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union ensures that E_Egress_PushLabel
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union interface.
func (E_Egress_PushLabel) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union() {}

// To_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Egress) To_NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union(i interface{}) (NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Lsps_StaticLsp_Egress_PushLabel_Union, unknown union type, got: %T, want any of [E_Egress_PushLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/incoming-label within the YANG schema.
// Union type can be one of [E_Ingress_IncomingLabel, UnionUint32].
type NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union interface {
	// Union type can be one of [E_Ingress_IncomingLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union ensures that E_Ingress_IncomingLabel
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union interface.
func (E_Ingress_IncomingLabel) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union() {
}

// To_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) To_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union(i interface{}) (NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_IncomingLabel_Union, unknown union type, got: %T, want any of [E_Ingress_IncomingLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/ingress/state/push-label within the YANG schema.
// Union type can be one of [E_Ingress_PushLabel, UnionUint32].
type NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union interface {
	// Union type can be one of [E_Ingress_PushLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union ensures that E_Ingress_PushLabel
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union interface.
func (E_Ingress_PushLabel) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union() {}

// To_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Ingress) To_NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union(i interface{}) (NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Lsps_StaticLsp_Ingress_PushLabel_Union, unknown union type, got: %T, want any of [E_Ingress_PushLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/incoming-label within the YANG schema.
// Union type can be one of [E_Transit_IncomingLabel, UnionUint32].
type NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union interface {
	// Union type can be one of [E_Transit_IncomingLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union ensures that E_Transit_IncomingLabel
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union interface.
func (E_Transit_IncomingLabel) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union() {
}

// To_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) To_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union(i interface{}) (NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Lsps_StaticLsp_Transit_IncomingLabel_Union, unknown union type, got: %T, want any of [E_Transit_IncomingLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/lsps/static-lsps/static-lsp/transit/state/push-label within the YANG schema.
// Union type can be one of [E_Transit_PushLabel, UnionUint32].
type NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union interface {
	// Union type can be one of [E_Transit_PushLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union ensures that E_Transit_PushLabel
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union interface.
func (E_Transit_PushLabel) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union() {}

// To_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_Lsps_StaticLsp_Transit) To_NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union(i interface{}) (NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_Lsps_StaticLsp_Transit_PushLabel_Union, unknown union type, got: %T, want any of [E_Transit_PushLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/interface-attributes/interface/bandwidth-reservations/bandwidth-reservation/state/priority within the YANG schema.
// Union type can be one of [E_BandwidthReservation_Priority, UnionUint8].
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union interface {
	// Union type can be one of [E_BandwidthReservation_Priority, UnionUint8]
	Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union()
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union ensures that E_BandwidthReservation_Priority
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union interface.
func (E_BandwidthReservation_Priority) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union() {
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union ensures that UnionUint8
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union interface.
func (UnionUint8) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union() {
}

// To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation) To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union(i interface{}) (NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Interface_BandwidthReservation_Priority_Union, unknown union type, got: %T, want any of [E_BandwidthReservation_Priority, uint8]", i, i)
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-in within the YANG schema.
// Union type can be one of [E_Session_LabelIn, UnionUint32].
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union interface {
	// Union type can be one of [E_Session_LabelIn, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union()
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union ensures that E_Session_LabelIn
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union interface.
func (E_Session_LabelIn) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union() {
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union() {
}

// To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union(i interface{}) (NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelIn_Union, unknown union type, got: %T, want any of [E_Session_LabelIn, uint32]", i, i)
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/state/label-out within the YANG schema.
// Union type can be one of [E_Session_LabelOut, UnionUint32].
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union interface {
	// Union type can be one of [E_Session_LabelOut, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union()
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union ensures that E_Session_LabelOut
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union interface.
func (E_Session_LabelOut) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union() {
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union() {
}

// To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session) To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union(i interface{}) (NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_LabelOut_Union, unknown union type, got: %T, want any of [E_Session_LabelOut, uint32]", i, i)
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/explicit-route-objects/explicit-route-object/state/label within the YANG schema.
// Union type can be one of [E_ExplicitRouteObject_Label, UnionUint32].
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union interface {
	// Union type can be one of [E_ExplicitRouteObject_Label, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union()
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union ensures that E_ExplicitRouteObject_Label
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union interface.
func (E_ExplicitRouteObject_Label) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union() {
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union() {
}

// To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject) To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union(i interface{}) (NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_ExplicitRouteObject_Label_Union, unknown union type, got: %T, want any of [E_ExplicitRouteObject_Label, uint32]", i, i)
}

// NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/rsvp-te/sessions/session/record-route-objects/record-route-object/state/reported-label within the YANG schema.
// Union type can be one of [E_RecordRouteObject_ReportedLabel, UnionUint32].
type NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union interface {
	// Union type can be one of [E_RecordRouteObject_ReportedLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union ensures that E_RecordRouteObject_ReportedLabel
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union interface.
func (E_RecordRouteObject_ReportedLabel) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union() {
}

// To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject) To_NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union(i interface{}) (NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_SignalingProtocols_RsvpTe_Session_RecordRouteObject_ReportedLabel_Union, unknown union type, got: %T, want any of [E_RecordRouteObject_ReportedLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/aggregate-sid-counters/aggregate-sid-counter/state/mpls-label within the YANG schema.
// Union type can be one of [E_AggregateSidCounter_MplsLabel, UnionUint32].
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union interface {
	// Union type can be one of [E_AggregateSidCounter_MplsLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union ensures that E_AggregateSidCounter_MplsLabel
// implements the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union interface.
func (E_AggregateSidCounter_MplsLabel) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union() {
}

// To_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter) To_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union(i interface{}) (NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_AggregateSidCounter_MplsLabel_Union, unknown union type, got: %T, want any of [E_AggregateSidCounter_MplsLabel, uint32]", i, i)
}

// NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/mpls/signaling-protocols/segment-routing/interfaces/interface/sid-counters/sid-counter/state/mpls-label within the YANG schema.
// Union type can be one of [E_SidCounter_MplsLabel, UnionUint32].
type NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union interface {
	// Union type can be one of [E_SidCounter_MplsLabel, UnionUint32]
	Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union()
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union ensures that E_SidCounter_MplsLabel
// implements the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union interface.
func (E_SidCounter_MplsLabel) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union() {
}

// Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union ensures that UnionUint32
// implements the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union() {
}

// To_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter) To_NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union(i interface{}) (NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union, error) {
	if v, ok := i.(NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Mpls_SignalingProtocols_SegmentRouting_Interface_SidCounter_MplsLabel_Union, unknown union type, got: %T, want any of [E_SidCounter_MplsLabel, uint32]", i, i)
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/ipv4/state/protocol within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8].
type NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union interface {
	// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8]
	Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union()
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union ensures that E_PacketMatchTypes_IP_PROTOCOL
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union interface.
func (E_PacketMatchTypes_IP_PROTOCOL) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union() {
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union ensures that UnionUint8
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union interface.
func (UnionUint8) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union() {
}

// To_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4) To_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union(i interface{}) (NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union, error) {
	if v, ok := i.(NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_PolicyForwarding_Policy_Rule_Ipv4_Protocol_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_IP_PROTOCOL, uint8]", i, i)
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/ipv6/state/protocol within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8].
type NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union interface {
	// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8]
	Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union()
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union ensures that E_PacketMatchTypes_IP_PROTOCOL
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union interface.
func (E_PacketMatchTypes_IP_PROTOCOL) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union() {
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union ensures that UnionUint8
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union interface.
func (UnionUint8) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union() {
}

// To_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6) To_NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union(i interface{}) (NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union, error) {
	if v, ok := i.(NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_PolicyForwarding_Policy_Rule_Ipv6_Protocol_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_IP_PROTOCOL, uint8]", i, i)
}

// NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/l2/state/ethertype within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_ETHERTYPE, UnionUint16].
type NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union interface {
	// Union type can be one of [E_PacketMatchTypes_ETHERTYPE, UnionUint16]
	Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union()
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union ensures that E_PacketMatchTypes_ETHERTYPE
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union interface.
func (E_PacketMatchTypes_ETHERTYPE) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union() {
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union ensures that UnionUint16
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union interface.
func (UnionUint16) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union() {
}

// To_NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_L2) To_NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union(i interface{}) (NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union, error) {
	if v, ok := i.(NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_PolicyForwarding_Policy_Rule_L2_Ethertype_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_ETHERTYPE, uint16]", i, i)
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/transport/state/destination-port within the YANG schema.
// Union type can be one of [E_Transport_DestinationPort, UnionString, UnionUint16].
type NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union interface {
	// Union type can be one of [E_Transport_DestinationPort, UnionString, UnionUint16]
	Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union()
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union ensures that E_Transport_DestinationPort
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union interface.
func (E_Transport_DestinationPort) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union() {
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union ensures that UnionString
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union interface.
func (UnionString) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union() {
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union ensures that UnionUint16
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union interface.
func (UnionUint16) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union() {
}

// To_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) To_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union(i interface{}) (NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union, error) {
	if v, ok := i.(NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_PolicyForwarding_Policy_Rule_Transport_DestinationPort_Union, unknown union type, got: %T, want any of [E_Transport_DestinationPort, string, uint16]", i, i)
}

// NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/transport/state/source-port within the YANG schema.
// Union type can be one of [E_Transport_SourcePort, UnionString, UnionUint16].
type NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union interface {
	// Union type can be one of [E_Transport_SourcePort, UnionString, UnionUint16]
	Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union()
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union ensures that E_Transport_SourcePort
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union interface.
func (E_Transport_SourcePort) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union() {
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union ensures that UnionString
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union interface.
func (UnionString) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union() {
}

// Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union ensures that UnionUint16
// implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union interface.
func (UnionUint16) Documentation_for_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union() {
}

// To_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_PolicyForwarding_Policy_Rule_Transport) To_NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union(i interface{}) (NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union, error) {
	if v, ok := i.(NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_PolicyForwarding_Policy_Rule_Transport_SourcePort_Union, unknown union type, got: %T, want any of [E_Transport_SourcePort, string, uint16]", i, i)
}

// NetworkInstance_Protocol_Aggregate_SetTag_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/local-aggregates/aggregate/state/set-tag within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Aggregate_SetTag_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Aggregate_SetTag_Union()
}

// Documentation_for_NetworkInstance_Protocol_Aggregate_SetTag_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Aggregate_SetTag_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Aggregate_SetTag_Union() {}

// Documentation_for_NetworkInstance_Protocol_Aggregate_SetTag_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Aggregate_SetTag_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Aggregate_SetTag_Union() {}

// To_NetworkInstance_Protocol_Aggregate_SetTag_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Aggregate_SetTag_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Aggregate) To_NetworkInstance_Protocol_Aggregate_SetTag_Union(i interface{}) (NetworkInstance_Protocol_Aggregate_SetTag_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Aggregate_SetTag_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Aggregate_SetTag_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/neighbors/neighbor/route-reflector/state/route-reflector-cluster-id within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union() {
}

// To_NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector) To_NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union(i interface{}) (NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_Neighbor_RouteReflector_RouteReflectorClusterId_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/peer-groups/peer-group/route-reflector/state/route-reflector-cluster-id within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union() {
}

// To_NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector) To_NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union(i interface{}) (NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_PeerGroup_RouteReflector_RouteReflectorClusterId_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/afi-safis/afi-safi/ipv4-unicast/loc-rib/routes/route/state/origin within the YANG schema.
// Union type can be one of [E_PolicyTypes_INSTALL_PROTOCOL_TYPE, UnionString].
type NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union interface {
	// Union type can be one of [E_PolicyTypes_INSTALL_PROTOCOL_TYPE, UnionString]
	Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union ensures that E_PolicyTypes_INSTALL_PROTOCOL_TYPE
// implements the NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union interface.
func (E_PolicyTypes_INSTALL_PROTOCOL_TYPE) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union() {
}

// To_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route) To_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union(i interface{}) (NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv4Unicast_LocRib_Route_Origin_Union, unknown union type, got: %T, want any of [E_PolicyTypes_INSTALL_PROTOCOL_TYPE, string]", i, i)
}

// NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/afi-safis/afi-safi/ipv6-unicast/loc-rib/routes/route/state/origin within the YANG schema.
// Union type can be one of [E_PolicyTypes_INSTALL_PROTOCOL_TYPE, UnionString].
type NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union interface {
	// Union type can be one of [E_PolicyTypes_INSTALL_PROTOCOL_TYPE, UnionString]
	Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union ensures that E_PolicyTypes_INSTALL_PROTOCOL_TYPE
// implements the NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union interface.
func (E_PolicyTypes_INSTALL_PROTOCOL_TYPE) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union() {
}

// To_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route) To_NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union(i interface{}) (NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_Rib_AfiSafi_Ipv6Unicast_LocRib_Route_Origin_Union, unknown union type, got: %T, want any of [E_PolicyTypes_INSTALL_PROTOCOL_TYPE, string]", i, i)
}

// NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/state/binding-sid within the YANG schema.
// Union type can be one of [E_Subtlv_BindingSid, UnionString, UnionUint32].
type NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union interface {
	// Union type can be one of [E_Subtlv_BindingSid, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union ensures that E_Subtlv_BindingSid
// implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union interface.
func (E_Subtlv_BindingSid) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union() {
}

// To_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv) To_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union(i interface{}) (NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_BindingSid_Union, unknown union type, got: %T, want any of [E_Subtlv_BindingSid, string, uint32]", i, i)
}

// NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/attr-sets/attr-set/tunnel-encapsulation/tunnels/tunnel/subtlvs/subtlv/segment-lists/segment-list/segments/segment/state/sid within the YANG schema.
// Union type can be one of [E_Segment_Sid, UnionString, UnionUint32].
type NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union interface {
	// Union type can be one of [E_Segment_Sid, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union ensures that E_Segment_Sid
// implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union interface.
func (E_Segment_Sid) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union() {
}

// To_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment) To_NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union(i interface{}) (NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_Rib_AttrSet_TunnelEncapsulation_Tunnel_Subtlv_SegmentList_Segment_Sid_Union, unknown union type, got: %T, want any of [E_Segment_Sid, string, uint32]", i, i)
}

// NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/communities/community/state/community within the YANG schema.
// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString, UnionUint32].
type NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union interface {
	// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union ensures that E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY
// implements the NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union interface.
func (E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union() {}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union() {}

// To_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_Rib_Community) To_NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union(i interface{}) (NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_Rib_Community_Community_Union, unknown union type, got: %T, want any of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, string, uint32]", i, i)
}

// NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/bgp/rib/ext-communities/ext-community/state/ext-community within the YANG schema.
// Union type can be one of [Binary, UnionString].
type NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union interface {
	// Union type can be one of [Binary, UnionString]
	Documentation_for_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union()
}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union ensures that Binary
// implements the NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union interface.
func (Binary) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union() {}

// Documentation_for_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union() {
}

// To_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Bgp_Rib_ExtCommunity) To_NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union(i interface{}) (NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case []byte:
		return Binary(v), nil
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Bgp_Rib_ExtCommunity_ExtCommunity_Union, unknown union type, got: %T, want any of [Binary, string]", i, i)
}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/allocated-dynamic-local within the YANG schema.
// Union type can be one of [E_AdjacencySid_AllocatedDynamicLocal, UnionString, UnionUint32].
type NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union interface {
	// Union type can be one of [E_AdjacencySid_AllocatedDynamicLocal, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union()
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union ensures that E_AdjacencySid_AllocatedDynamicLocal
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union interface.
func (E_AdjacencySid_AllocatedDynamicLocal) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union() {
}

// To_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) To_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union(i interface{}) (NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_AllocatedDynamicLocal_Union, unknown union type, got: %T, want any of [E_AdjacencySid_AllocatedDynamicLocal, string, uint32]", i, i)
}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/adjacency-sids/adjacency-sid/state/sid-id within the YANG schema.
// Union type can be one of [E_AdjacencySid_SidId, UnionString, UnionUint32].
type NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union interface {
	// Union type can be one of [E_AdjacencySid_SidId, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union()
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union ensures that E_AdjacencySid_SidId
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union interface.
func (E_AdjacencySid_SidId) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union() {
}

// To_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid) To_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union(i interface{}) (NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_AdjacencySid_SidId_Union, unknown union type, got: %T, want any of [E_AdjacencySid_SidId, string, uint32]", i, i)
}

// NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/levels/level/afi-safi/af/segment-routing/prefix-sids/prefix-sid/state/sid-id within the YANG schema.
// Union type can be one of [E_PrefixSid_SidId, UnionString, UnionUint32].
type NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union interface {
	// Union type can be one of [E_PrefixSid_SidId, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union()
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union ensures that E_PrefixSid_SidId
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union interface.
func (E_PrefixSid_SidId) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union() {
}

// To_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid) To_NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union(i interface{}) (NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Isis_Interface_Level_Af_SegmentRouting_PrefixSid_SidId_Union, unknown union type, got: %T, want any of [E_PrefixSid_SidId, string, uint32]", i, i)
}

// NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/interfaces/interface/weighted-ecmp/state/load-balancing-weight within the YANG schema.
// Union type can be one of [E_WeightedEcmp_LoadBalancingWeight, UnionUint32].
type NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union interface {
	// Union type can be one of [E_WeightedEcmp_LoadBalancingWeight, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union()
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union ensures that E_WeightedEcmp_LoadBalancingWeight
// implements the NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union interface.
func (E_WeightedEcmp_LoadBalancingWeight) Documentation_for_NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union() {
}

// To_NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Isis_Interface_WeightedEcmp) To_NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union(i interface{}) (NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Isis_Interface_WeightedEcmp_LoadBalancingWeight_Union, unknown union type, got: %T, want any of [E_WeightedEcmp_LoadBalancingWeight, uint32]", i, i)
}

// NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/isis/levels/level/link-state-database/lsp/tlvs/tlv/router-capabilities/capability/subtlvs/subtlv/segment-routing-capability/srgb-descriptors/srgb-descriptor/state/label within the YANG schema.
// Union type can be one of [E_SrgbDescriptor_Label, UnionUint32].
type NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union interface {
	// Union type can be one of [E_SrgbDescriptor_Label, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union()
}

// Documentation_for_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union ensures that E_SrgbDescriptor_Label
// implements the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union interface.
func (E_SrgbDescriptor_Label) Documentation_for_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union() {
}

// To_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor) To_NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union(i interface{}) (NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Isis_Level_Lsp_Tlv_Capability_Subtlv_SegmentRoutingCapability_SrgbDescriptor_Label_Union, unknown union type, got: %T, want any of [E_SrgbDescriptor_Label, uint32]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/state/identifier within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union() {}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union() {}

// To_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area) To_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/state/identifier within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union() {}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union() {}

// To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb) To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Lsdb_Identifier_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/opaque-lsa/extended-link/state/link-data within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union() {
}

// To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink) To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_ExtendedLink_LinkData_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/opaque-lsa/router-information/tlvs/tlv/state/type within the YANG schema.
// Union type can be one of [E_OspfTypes_RI_LSA_TLV_TYPES, E_RouterInformation_Tlv_Type].
type NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union interface {
	// Union type can be one of [E_OspfTypes_RI_LSA_TLV_TYPES, E_RouterInformation_Tlv_Type]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union ensures that E_OspfTypes_RI_LSA_TLV_TYPES
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union interface.
func (E_OspfTypes_RI_LSA_TLV_TYPES) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union ensures that E_RouterInformation_Tlv_Type
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union interface.
func (E_RouterInformation_Tlv_Type) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union() {
}

// To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv) To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union); ok {
		return v, nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_Type_Union, unknown union type, got: %T, want any of [E_OspfTypes_RI_LSA_TLV_TYPES, E_RouterInformation_Tlv_Type]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/opaque-lsa/router-information/tlvs/tlv/segment-routing-sid-label-range/tlvs/tlv/state/type within the YANG schema.
// Union type can be one of [E_OspfTypes_OSPF_RI_SR_SID_LABEL_TLV_TYPES, E_SegmentRoutingSidLabelRange_Tlv_Type].
type NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union interface {
	// Union type can be one of [E_OspfTypes_OSPF_RI_SR_SID_LABEL_TLV_TYPES, E_SegmentRoutingSidLabelRange_Tlv_Type]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union ensures that E_OspfTypes_OSPF_RI_SR_SID_LABEL_TLV_TYPES
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union interface.
func (E_OspfTypes_OSPF_RI_SR_SID_LABEL_TLV_TYPES) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union ensures that E_SegmentRoutingSidLabelRange_Tlv_Type
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union interface.
func (E_SegmentRoutingSidLabelRange_Tlv_Type) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union() {
}

// To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv) To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union); ok {
		return v, nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_RouterInformation_Tlv_SegmentRoutingSidLabelRange_Tlv_Type_Union, unknown union type, got: %T, want any of [E_OspfTypes_OSPF_RI_SR_SID_LABEL_TLV_TYPES, E_SegmentRoutingSidLabelRange_Tlv_Type]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/opaque-lsa/traffic-engineering/tlvs/tlv/link/sub-tlvs/sub-tlv/state/type within the YANG schema.
// Union type can be one of [E_Link_SubTlv_Type, E_OspfTypes_OSPF_TE_LINK_TLV_TYPE].
type NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union interface {
	// Union type can be one of [E_Link_SubTlv_Type, E_OspfTypes_OSPF_TE_LINK_TLV_TYPE]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union ensures that E_Link_SubTlv_Type
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union interface.
func (E_Link_SubTlv_Type) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union ensures that E_OspfTypes_OSPF_TE_LINK_TLV_TYPE
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union interface.
func (E_OspfTypes_OSPF_TE_LINK_TLV_TYPE) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union() {
}

// To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv) To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union); ok {
		return v, nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_Link_SubTlv_Type_Union, unknown union type, got: %T, want any of [E_Link_SubTlv_Type, E_OspfTypes_OSPF_TE_LINK_TLV_TYPE]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/opaque-lsa/traffic-engineering/tlvs/tlv/node-attribute/sub-tlvs/sub-tlv/state/type within the YANG schema.
// Union type can be one of [E_NodeAttribute_SubTlv_Type, E_OspfTypes_TE_NODE_ATTRIBUTE_TLV_TYPE].
type NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union interface {
	// Union type can be one of [E_NodeAttribute_SubTlv_Type, E_OspfTypes_TE_NODE_ATTRIBUTE_TLV_TYPE]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union ensures that E_NodeAttribute_SubTlv_Type
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union interface.
func (E_NodeAttribute_SubTlv_Type) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union ensures that E_OspfTypes_TE_NODE_ATTRIBUTE_TLV_TYPE
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union interface.
func (E_OspfTypes_TE_NODE_ATTRIBUTE_TLV_TYPE) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union() {
}

// To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv) To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union); ok {
		return v, nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_OpaqueLsa_TrafficEngineering_Tlv_NodeAttribute_SubTlv_Type_Union, unknown union type, got: %T, want any of [E_NodeAttribute_SubTlv_Type, E_OspfTypes_TE_NODE_ATTRIBUTE_TLV_TYPE]", i, i)
}

// NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/ospfv2/areas/area/lsdb/lsa-types/lsa-type/lsas/lsa/router-lsa/state/link-data within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union()
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union() {
}

// To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa) To_NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Lsdb_LsaType_Lsa_RouterLsa_LinkData_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// To_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Ospfv2_Global_InterAreaPropagationPolicy) To_NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union(i interface{}) (NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Ospfv2_Area_Identifier_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Static_SetTag_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/static-routes/static/state/set-tag within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type NetworkInstance_Protocol_Static_SetTag_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_NetworkInstance_Protocol_Static_SetTag_Union()
}

// Documentation_for_NetworkInstance_Protocol_Static_SetTag_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Static_SetTag_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Static_SetTag_Union() {}

// Documentation_for_NetworkInstance_Protocol_Static_SetTag_Union ensures that UnionUint32
// implements the NetworkInstance_Protocol_Static_SetTag_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_Protocol_Static_SetTag_Union() {}

// To_NetworkInstance_Protocol_Static_SetTag_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Static_SetTag_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Static) To_NetworkInstance_Protocol_Static_SetTag_Union(i interface{}) (NetworkInstance_Protocol_Static_SetTag_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Static_SetTag_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Static_SetTag_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// NetworkInstance_Protocol_Static_NextHop_NextHop_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/protocols/protocol/static-routes/static/next-hops/next-hop/state/next-hop within the YANG schema.
// Union type can be one of [E_LocalRouting_LOCAL_DEFINED_NEXT_HOP, UnionString].
type NetworkInstance_Protocol_Static_NextHop_NextHop_Union interface {
	// Union type can be one of [E_LocalRouting_LOCAL_DEFINED_NEXT_HOP, UnionString]
	Documentation_for_NetworkInstance_Protocol_Static_NextHop_NextHop_Union()
}

// Documentation_for_NetworkInstance_Protocol_Static_NextHop_NextHop_Union ensures that E_LocalRouting_LOCAL_DEFINED_NEXT_HOP
// implements the NetworkInstance_Protocol_Static_NextHop_NextHop_Union interface.
func (E_LocalRouting_LOCAL_DEFINED_NEXT_HOP) Documentation_for_NetworkInstance_Protocol_Static_NextHop_NextHop_Union() {
}

// Documentation_for_NetworkInstance_Protocol_Static_NextHop_NextHop_Union ensures that UnionString
// implements the NetworkInstance_Protocol_Static_NextHop_NextHop_Union interface.
func (UnionString) Documentation_for_NetworkInstance_Protocol_Static_NextHop_NextHop_Union() {}

// To_NetworkInstance_Protocol_Static_NextHop_NextHop_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_Protocol_Static_NextHop_NextHop_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_Protocol_Static_NextHop) To_NetworkInstance_Protocol_Static_NextHop_NextHop_Union(i interface{}) (NetworkInstance_Protocol_Static_NextHop_NextHop_Union, error) {
	if v, ok := i.(NetworkInstance_Protocol_Static_NextHop_NextHop_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_Protocol_Static_NextHop_NextHop_Union, unknown union type, got: %T, want any of [E_LocalRouting_LOCAL_DEFINED_NEXT_HOP, string]", i, i)
}

// NetworkInstance_SegmentRouting_TePolicy_Bsid_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/segment-routing/te-policies/te-policy/state/bsid within the YANG schema.
// Union type can be one of [E_TePolicy_Bsid, UnionString, UnionUint32].
type NetworkInstance_SegmentRouting_TePolicy_Bsid_Union interface {
	// Union type can be one of [E_TePolicy_Bsid, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union()
}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union ensures that E_TePolicy_Bsid
// implements the NetworkInstance_SegmentRouting_TePolicy_Bsid_Union interface.
func (E_TePolicy_Bsid) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union() {}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union ensures that UnionString
// implements the NetworkInstance_SegmentRouting_TePolicy_Bsid_Union interface.
func (UnionString) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union() {}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union ensures that UnionUint32
// implements the NetworkInstance_SegmentRouting_TePolicy_Bsid_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union() {}

// To_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_SegmentRouting_TePolicy_Bsid_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_SegmentRouting_TePolicy) To_NetworkInstance_SegmentRouting_TePolicy_Bsid_Union(i interface{}) (NetworkInstance_SegmentRouting_TePolicy_Bsid_Union, error) {
	if v, ok := i.(NetworkInstance_SegmentRouting_TePolicy_Bsid_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_SegmentRouting_TePolicy_Bsid_Union, unknown union type, got: %T, want any of [E_TePolicy_Bsid, string, uint32]", i, i)
}

// NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/segment-routing/te-policies/te-policy/candidate-paths/candidate-path/segment-lists/segment-list/next-hops/next-hop/state/pushed-mpls-label-stack within the YANG schema.
// Union type can be one of [E_NextHop_PushedMplsLabelStack, UnionUint32].
type NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union interface {
	// Union type can be one of [E_NextHop_PushedMplsLabelStack, UnionUint32]
	Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union()
}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union ensures that E_NextHop_PushedMplsLabelStack
// implements the NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union interface.
func (E_NextHop_PushedMplsLabelStack) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union() {
}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union ensures that UnionUint32
// implements the NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union() {
}

// To_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop) To_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union(i interface{}) (NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union, error) {
	if v, ok := i.(NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_NextHop_PushedMplsLabelStack_Union, unknown union type, got: %T, want any of [E_NextHop_PushedMplsLabelStack, uint32]", i, i)
}

// NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-network-instance/network-instances/network-instance/segment-routing/te-policies/te-policy/candidate-paths/candidate-path/segment-lists/segment-list/sids/sid/state/value within the YANG schema.
// Union type can be one of [E_Sid_Value, UnionString, UnionUint32].
type NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union interface {
	// Union type can be one of [E_Sid_Value, UnionString, UnionUint32]
	Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union()
}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union ensures that E_Sid_Value
// implements the NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union interface.
func (E_Sid_Value) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union() {
}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union ensures that UnionString
// implements the NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union interface.
func (UnionString) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union() {
}

// Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union ensures that UnionUint32
// implements the NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union interface.
func (UnionUint32) Documentation_for_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union() {
}

// To_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union takes an input interface{} and attempts to convert it to a struct
// which implements the NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid) To_NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union(i interface{}) (NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union, error) {
	if v, ok := i.(NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to NetworkInstance_SegmentRouting_TePolicy_CandidatePath_SegmentList_Sid_Value_Union, unknown union type, got: %T, want any of [E_Sid_Value, string, uint32]", i, i)
}

// Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-qos/qos/classifiers/classifier/terms/term/conditions/ipv4/state/protocol within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8].
type Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union interface {
	// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8]
	Documentation_for_Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union()
}

// Documentation_for_Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union ensures that E_PacketMatchTypes_IP_PROTOCOL
// implements the Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union interface.
func (E_PacketMatchTypes_IP_PROTOCOL) Documentation_for_Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union ensures that UnionUint8
// implements the Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union interface.
func (UnionUint8) Documentation_for_Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union() {}

// To_Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Qos_Classifier_Term_Conditions_Ipv4) To_Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union(i interface{}) (Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union, error) {
	if v, ok := i.(Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Qos_Classifier_Term_Conditions_Ipv4_Protocol_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_IP_PROTOCOL, uint8]", i, i)
}

// Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-qos/qos/classifiers/classifier/terms/term/conditions/ipv6/state/protocol within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8].
type Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union interface {
	// Union type can be one of [E_PacketMatchTypes_IP_PROTOCOL, UnionUint8]
	Documentation_for_Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union()
}

// Documentation_for_Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union ensures that E_PacketMatchTypes_IP_PROTOCOL
// implements the Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union interface.
func (E_PacketMatchTypes_IP_PROTOCOL) Documentation_for_Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union ensures that UnionUint8
// implements the Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union interface.
func (UnionUint8) Documentation_for_Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union() {}

// To_Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Qos_Classifier_Term_Conditions_Ipv6) To_Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union(i interface{}) (Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union, error) {
	if v, ok := i.(Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint8:
		return UnionUint8(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Qos_Classifier_Term_Conditions_Ipv6_Protocol_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_IP_PROTOCOL, uint8]", i, i)
}

// Qos_Classifier_Term_Conditions_L2_Ethertype_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-qos/qos/classifiers/classifier/terms/term/conditions/l2/state/ethertype within the YANG schema.
// Union type can be one of [E_PacketMatchTypes_ETHERTYPE, UnionUint16].
type Qos_Classifier_Term_Conditions_L2_Ethertype_Union interface {
	// Union type can be one of [E_PacketMatchTypes_ETHERTYPE, UnionUint16]
	Documentation_for_Qos_Classifier_Term_Conditions_L2_Ethertype_Union()
}

// Documentation_for_Qos_Classifier_Term_Conditions_L2_Ethertype_Union ensures that E_PacketMatchTypes_ETHERTYPE
// implements the Qos_Classifier_Term_Conditions_L2_Ethertype_Union interface.
func (E_PacketMatchTypes_ETHERTYPE) Documentation_for_Qos_Classifier_Term_Conditions_L2_Ethertype_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_L2_Ethertype_Union ensures that UnionUint16
// implements the Qos_Classifier_Term_Conditions_L2_Ethertype_Union interface.
func (UnionUint16) Documentation_for_Qos_Classifier_Term_Conditions_L2_Ethertype_Union() {}

// To_Qos_Classifier_Term_Conditions_L2_Ethertype_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Qos_Classifier_Term_Conditions_L2_Ethertype_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Qos_Classifier_Term_Conditions_L2) To_Qos_Classifier_Term_Conditions_L2_Ethertype_Union(i interface{}) (Qos_Classifier_Term_Conditions_L2_Ethertype_Union, error) {
	if v, ok := i.(Qos_Classifier_Term_Conditions_L2_Ethertype_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Qos_Classifier_Term_Conditions_L2_Ethertype_Union, unknown union type, got: %T, want any of [E_PacketMatchTypes_ETHERTYPE, uint16]", i, i)
}

// Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-qos/qos/classifiers/classifier/terms/term/conditions/mpls/state/end-label-value within the YANG schema.
// Union type can be one of [E_Mpls_EndLabelValue, UnionUint32].
type Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union interface {
	// Union type can be one of [E_Mpls_EndLabelValue, UnionUint32]
	Documentation_for_Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union()
}

// Documentation_for_Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union ensures that E_Mpls_EndLabelValue
// implements the Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union interface.
func (E_Mpls_EndLabelValue) Documentation_for_Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union ensures that UnionUint32
// implements the Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union interface.
func (UnionUint32) Documentation_for_Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union() {}

// To_Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Qos_Classifier_Term_Conditions_Mpls) To_Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union(i interface{}) (Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union, error) {
	if v, ok := i.(Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Qos_Classifier_Term_Conditions_Mpls_EndLabelValue_Union, unknown union type, got: %T, want any of [E_Mpls_EndLabelValue, uint32]", i, i)
}

// Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-qos/qos/classifiers/classifier/terms/term/conditions/mpls/state/start-label-value within the YANG schema.
// Union type can be one of [E_Mpls_StartLabelValue, UnionUint32].
type Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union interface {
	// Union type can be one of [E_Mpls_StartLabelValue, UnionUint32]
	Documentation_for_Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union()
}

// Documentation_for_Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union ensures that E_Mpls_StartLabelValue
// implements the Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union interface.
func (E_Mpls_StartLabelValue) Documentation_for_Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union ensures that UnionUint32
// implements the Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union interface.
func (UnionUint32) Documentation_for_Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union() {}

// To_Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Qos_Classifier_Term_Conditions_Mpls) To_Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union(i interface{}) (Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union, error) {
	if v, ok := i.(Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Qos_Classifier_Term_Conditions_Mpls_StartLabelValue_Union, unknown union type, got: %T, want any of [E_Mpls_StartLabelValue, uint32]", i, i)
}

// Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-qos/qos/classifiers/classifier/terms/term/conditions/transport/state/destination-port within the YANG schema.
// Union type can be one of [E_Transport_DestinationPort, UnionString, UnionUint16].
type Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union interface {
	// Union type can be one of [E_Transport_DestinationPort, UnionString, UnionUint16]
	Documentation_for_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union()
}

// Documentation_for_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union ensures that E_Transport_DestinationPort
// implements the Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union interface.
func (E_Transport_DestinationPort) Documentation_for_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union ensures that UnionString
// implements the Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union interface.
func (UnionString) Documentation_for_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union ensures that UnionUint16
// implements the Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union interface.
func (UnionUint16) Documentation_for_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union() {
}

// To_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Qos_Classifier_Term_Conditions_Transport) To_Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union(i interface{}) (Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union, error) {
	if v, ok := i.(Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Qos_Classifier_Term_Conditions_Transport_DestinationPort_Union, unknown union type, got: %T, want any of [E_Transport_DestinationPort, string, uint16]", i, i)
}

// Qos_Classifier_Term_Conditions_Transport_SourcePort_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-qos/qos/classifiers/classifier/terms/term/conditions/transport/state/source-port within the YANG schema.
// Union type can be one of [E_Transport_SourcePort, UnionString, UnionUint16].
type Qos_Classifier_Term_Conditions_Transport_SourcePort_Union interface {
	// Union type can be one of [E_Transport_SourcePort, UnionString, UnionUint16]
	Documentation_for_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union()
}

// Documentation_for_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union ensures that E_Transport_SourcePort
// implements the Qos_Classifier_Term_Conditions_Transport_SourcePort_Union interface.
func (E_Transport_SourcePort) Documentation_for_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union() {
}

// Documentation_for_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union ensures that UnionString
// implements the Qos_Classifier_Term_Conditions_Transport_SourcePort_Union interface.
func (UnionString) Documentation_for_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union() {}

// Documentation_for_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union ensures that UnionUint16
// implements the Qos_Classifier_Term_Conditions_Transport_SourcePort_Union interface.
func (UnionUint16) Documentation_for_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union() {}

// To_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union takes an input interface{} and attempts to convert it to a struct
// which implements the Qos_Classifier_Term_Conditions_Transport_SourcePort_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *Qos_Classifier_Term_Conditions_Transport) To_Qos_Classifier_Term_Conditions_Transport_SourcePort_Union(i interface{}) (Qos_Classifier_Term_Conditions_Transport_SourcePort_Union, error) {
	if v, ok := i.(Qos_Classifier_Term_Conditions_Transport_SourcePort_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint16:
		return UnionUint16(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to Qos_Classifier_Term_Conditions_Transport_SourcePort_Union, unknown union type, got: %T, want any of [E_Transport_SourcePort, string, uint16]", i, i)
}

// RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-routing-policy/routing-policy/defined-sets/bgp-defined-sets/community-sets/community-set/state/community-member within the YANG schema.
// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString, UnionUint32].
type RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union interface {
	// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString, UnionUint32]
	Documentation_for_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union()
}

// Documentation_for_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union ensures that E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY
// implements the RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union interface.
func (E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY) Documentation_for_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union() {
}

// Documentation_for_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union ensures that UnionString
// implements the RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union interface.
func (UnionString) Documentation_for_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union() {
}

// Documentation_for_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union ensures that UnionUint32
// implements the RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union interface.
func (UnionUint32) Documentation_for_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union() {
}

// To_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union takes an input interface{} and attempts to convert it to a struct
// which implements the RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet) To_RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union(i interface{}) (RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union, error) {
	if v, ok := i.(RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to RoutingPolicy_DefinedSets_BgpDefinedSets_CommunitySet_CommunityMember_Union, unknown union type, got: %T, want any of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, string, uint32]", i, i)
}

// RoutingPolicy_DefinedSets_TagSet_TagValue_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-routing-policy/routing-policy/defined-sets/tag-sets/tag-set/state/tag-value within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type RoutingPolicy_DefinedSets_TagSet_TagValue_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_RoutingPolicy_DefinedSets_TagSet_TagValue_Union()
}

// Documentation_for_RoutingPolicy_DefinedSets_TagSet_TagValue_Union ensures that UnionString
// implements the RoutingPolicy_DefinedSets_TagSet_TagValue_Union interface.
func (UnionString) Documentation_for_RoutingPolicy_DefinedSets_TagSet_TagValue_Union() {}

// Documentation_for_RoutingPolicy_DefinedSets_TagSet_TagValue_Union ensures that UnionUint32
// implements the RoutingPolicy_DefinedSets_TagSet_TagValue_Union interface.
func (UnionUint32) Documentation_for_RoutingPolicy_DefinedSets_TagSet_TagValue_Union() {}

// To_RoutingPolicy_DefinedSets_TagSet_TagValue_Union takes an input interface{} and attempts to convert it to a struct
// which implements the RoutingPolicy_DefinedSets_TagSet_TagValue_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *RoutingPolicy_DefinedSets_TagSet) To_RoutingPolicy_DefinedSets_TagSet_TagValue_Union(i interface{}) (RoutingPolicy_DefinedSets_TagSet_TagValue_Union, error) {
	if v, ok := i.(RoutingPolicy_DefinedSets_TagSet_TagValue_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to RoutingPolicy_DefinedSets_TagSet_TagValue_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-routing-policy/routing-policy/policy-definitions/policy-definition/statements/statement/actions/bgp-actions/state/set-med within the YANG schema.
// Union type can be one of [E_BgpActions_SetMed, UnionString, UnionUint32].
type RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union interface {
	// Union type can be one of [E_BgpActions_SetMed, UnionString, UnionUint32]
	Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union()
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union ensures that E_BgpActions_SetMed
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union interface.
func (E_BgpActions_SetMed) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union() {
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union ensures that UnionString
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union interface.
func (UnionString) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union() {
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union ensures that UnionUint32
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union interface.
func (UnionUint32) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union() {
}

// To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union takes an input interface{} and attempts to convert it to a struct
// which implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions) To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union(i interface{}) (RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union, error) {
	if v, ok := i.(RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetMed_Union, unknown union type, got: %T, want any of [E_BgpActions_SetMed, string, uint32]", i, i)
}

// RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-routing-policy/routing-policy/policy-definitions/policy-definition/statements/statement/actions/bgp-actions/state/set-next-hop within the YANG schema.
// Union type can be one of [E_BgpActions_SetNextHop, UnionString].
type RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union interface {
	// Union type can be one of [E_BgpActions_SetNextHop, UnionString]
	Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union()
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union ensures that E_BgpActions_SetNextHop
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union interface.
func (E_BgpActions_SetNextHop) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union() {
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union ensures that UnionString
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union interface.
func (UnionString) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union() {
}

// To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union takes an input interface{} and attempts to convert it to a struct
// which implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions) To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union(i interface{}) (RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union, error) {
	if v, ok := i.(RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetNextHop_Union, unknown union type, got: %T, want any of [E_BgpActions_SetNextHop, string]", i, i)
}

// RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-routing-policy/routing-policy/policy-definitions/policy-definition/statements/statement/actions/bgp-actions/set-community/inline/state/communities within the YANG schema.
// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString, UnionUint32].
type RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union interface {
	// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString, UnionUint32]
	Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union()
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union ensures that E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union interface.
func (E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union() {
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union ensures that UnionString
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union interface.
func (UnionString) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union() {
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union ensures that UnionUint32
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union interface.
func (UnionUint32) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union() {
}

// To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union takes an input interface{} and attempts to convert it to a struct
// which implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline) To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union(i interface{}) (RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union, error) {
	if v, ok := i.(RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetCommunity_Inline_Communities_Union, unknown union type, got: %T, want any of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, string, uint32]", i, i)
}

// RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-routing-policy/routing-policy/policy-definitions/policy-definition/statements/statement/actions/bgp-actions/set-ext-community/inline/state/communities within the YANG schema.
// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString].
type RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union interface {
	// Union type can be one of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, UnionString]
	Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union()
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union ensures that E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union interface.
func (E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union() {
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union ensures that UnionString
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union interface.
func (UnionString) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union() {
}

// To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union takes an input interface{} and attempts to convert it to a struct
// which implements the RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline) To_RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union(i interface{}) (RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union, error) {
	if v, ok := i.(RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to RoutingPolicy_PolicyDefinition_Statement_Actions_BgpActions_SetExtCommunity_Inline_Communities_Union, unknown union type, got: %T, want any of [E_BgpTypes_BGP_WELL_KNOWN_STD_COMMUNITY, string]", i, i)
}

// RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-routing-policy/routing-policy/policy-definitions/policy-definition/statements/statement/actions/set-tag/inline/state/tag within the YANG schema.
// Union type can be one of [UnionString, UnionUint32].
type RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union interface {
	// Union type can be one of [UnionString, UnionUint32]
	Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union()
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union ensures that UnionString
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union interface.
func (UnionString) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union() {
}

// Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union ensures that UnionUint32
// implements the RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union interface.
func (UnionUint32) Documentation_for_RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union() {
}

// To_RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union takes an input interface{} and attempts to convert it to a struct
// which implements the RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline) To_RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union(i interface{}) (RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union, error) {
	if v, ok := i.(RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to RoutingPolicy_PolicyDefinition_Statement_Actions_SetTag_Inline_Tag_Union, unknown union type, got: %T, want any of [string, uint32]", i, i)
}

// System_Aaa_Accounting_AccountingMethod_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/aaa/accounting/state/accounting-method within the YANG schema.
// Union type can be one of [E_AaaTypes_AAA_METHOD_TYPE, UnionString].
type System_Aaa_Accounting_AccountingMethod_Union interface {
	// Union type can be one of [E_AaaTypes_AAA_METHOD_TYPE, UnionString]
	Documentation_for_System_Aaa_Accounting_AccountingMethod_Union()
}

// Documentation_for_System_Aaa_Accounting_AccountingMethod_Union ensures that E_AaaTypes_AAA_METHOD_TYPE
// implements the System_Aaa_Accounting_AccountingMethod_Union interface.
func (E_AaaTypes_AAA_METHOD_TYPE) Documentation_for_System_Aaa_Accounting_AccountingMethod_Union() {}

// Documentation_for_System_Aaa_Accounting_AccountingMethod_Union ensures that UnionString
// implements the System_Aaa_Accounting_AccountingMethod_Union interface.
func (UnionString) Documentation_for_System_Aaa_Accounting_AccountingMethod_Union() {}

// To_System_Aaa_Accounting_AccountingMethod_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_Aaa_Accounting_AccountingMethod_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_Aaa_Accounting) To_System_Aaa_Accounting_AccountingMethod_Union(i interface{}) (System_Aaa_Accounting_AccountingMethod_Union, error) {
	if v, ok := i.(System_Aaa_Accounting_AccountingMethod_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_Aaa_Accounting_AccountingMethod_Union, unknown union type, got: %T, want any of [E_AaaTypes_AAA_METHOD_TYPE, string]", i, i)
}

// System_Aaa_Authentication_AuthenticationMethod_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/aaa/authentication/state/authentication-method within the YANG schema.
// Union type can be one of [E_AaaTypes_AAA_METHOD_TYPE, UnionString].
type System_Aaa_Authentication_AuthenticationMethod_Union interface {
	// Union type can be one of [E_AaaTypes_AAA_METHOD_TYPE, UnionString]
	Documentation_for_System_Aaa_Authentication_AuthenticationMethod_Union()
}

// Documentation_for_System_Aaa_Authentication_AuthenticationMethod_Union ensures that E_AaaTypes_AAA_METHOD_TYPE
// implements the System_Aaa_Authentication_AuthenticationMethod_Union interface.
func (E_AaaTypes_AAA_METHOD_TYPE) Documentation_for_System_Aaa_Authentication_AuthenticationMethod_Union() {
}

// Documentation_for_System_Aaa_Authentication_AuthenticationMethod_Union ensures that UnionString
// implements the System_Aaa_Authentication_AuthenticationMethod_Union interface.
func (UnionString) Documentation_for_System_Aaa_Authentication_AuthenticationMethod_Union() {}

// To_System_Aaa_Authentication_AuthenticationMethod_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_Aaa_Authentication_AuthenticationMethod_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_Aaa_Authentication) To_System_Aaa_Authentication_AuthenticationMethod_Union(i interface{}) (System_Aaa_Authentication_AuthenticationMethod_Union, error) {
	if v, ok := i.(System_Aaa_Authentication_AuthenticationMethod_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_Aaa_Authentication_AuthenticationMethod_Union, unknown union type, got: %T, want any of [E_AaaTypes_AAA_METHOD_TYPE, string]", i, i)
}

// System_Aaa_Authentication_User_Role_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/aaa/authentication/users/user/state/role within the YANG schema.
// Union type can be one of [E_AaaTypes_SYSTEM_DEFINED_ROLES, UnionString].
type System_Aaa_Authentication_User_Role_Union interface {
	// Union type can be one of [E_AaaTypes_SYSTEM_DEFINED_ROLES, UnionString]
	Documentation_for_System_Aaa_Authentication_User_Role_Union()
}

// Documentation_for_System_Aaa_Authentication_User_Role_Union ensures that E_AaaTypes_SYSTEM_DEFINED_ROLES
// implements the System_Aaa_Authentication_User_Role_Union interface.
func (E_AaaTypes_SYSTEM_DEFINED_ROLES) Documentation_for_System_Aaa_Authentication_User_Role_Union() {
}

// Documentation_for_System_Aaa_Authentication_User_Role_Union ensures that UnionString
// implements the System_Aaa_Authentication_User_Role_Union interface.
func (UnionString) Documentation_for_System_Aaa_Authentication_User_Role_Union() {}

// To_System_Aaa_Authentication_User_Role_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_Aaa_Authentication_User_Role_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_Aaa_Authentication_User) To_System_Aaa_Authentication_User_Role_Union(i interface{}) (System_Aaa_Authentication_User_Role_Union, error) {
	if v, ok := i.(System_Aaa_Authentication_User_Role_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_Aaa_Authentication_User_Role_Union, unknown union type, got: %T, want any of [E_AaaTypes_SYSTEM_DEFINED_ROLES, string]", i, i)
}

// System_Aaa_Authorization_AuthorizationMethod_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/aaa/authorization/state/authorization-method within the YANG schema.
// Union type can be one of [E_AaaTypes_AAA_METHOD_TYPE, UnionString].
type System_Aaa_Authorization_AuthorizationMethod_Union interface {
	// Union type can be one of [E_AaaTypes_AAA_METHOD_TYPE, UnionString]
	Documentation_for_System_Aaa_Authorization_AuthorizationMethod_Union()
}

// Documentation_for_System_Aaa_Authorization_AuthorizationMethod_Union ensures that E_AaaTypes_AAA_METHOD_TYPE
// implements the System_Aaa_Authorization_AuthorizationMethod_Union interface.
func (E_AaaTypes_AAA_METHOD_TYPE) Documentation_for_System_Aaa_Authorization_AuthorizationMethod_Union() {
}

// Documentation_for_System_Aaa_Authorization_AuthorizationMethod_Union ensures that UnionString
// implements the System_Aaa_Authorization_AuthorizationMethod_Union interface.
func (UnionString) Documentation_for_System_Aaa_Authorization_AuthorizationMethod_Union() {}

// To_System_Aaa_Authorization_AuthorizationMethod_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_Aaa_Authorization_AuthorizationMethod_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_Aaa_Authorization) To_System_Aaa_Authorization_AuthorizationMethod_Union(i interface{}) (System_Aaa_Authorization_AuthorizationMethod_Union, error) {
	if v, ok := i.(System_Aaa_Authorization_AuthorizationMethod_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_Aaa_Authorization_AuthorizationMethod_Union, unknown union type, got: %T, want any of [E_AaaTypes_AAA_METHOD_TYPE, string]", i, i)
}

// System_Alarm_TypeId_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/alarms/alarm/state/type-id within the YANG schema.
// Union type can be one of [E_AlarmTypes_OPENCONFIG_ALARM_TYPE_ID, UnionString].
type System_Alarm_TypeId_Union interface {
	// Union type can be one of [E_AlarmTypes_OPENCONFIG_ALARM_TYPE_ID, UnionString]
	Documentation_for_System_Alarm_TypeId_Union()
}

// Documentation_for_System_Alarm_TypeId_Union ensures that E_AlarmTypes_OPENCONFIG_ALARM_TYPE_ID
// implements the System_Alarm_TypeId_Union interface.
func (E_AlarmTypes_OPENCONFIG_ALARM_TYPE_ID) Documentation_for_System_Alarm_TypeId_Union() {}

// Documentation_for_System_Alarm_TypeId_Union ensures that UnionString
// implements the System_Alarm_TypeId_Union interface.
func (UnionString) Documentation_for_System_Alarm_TypeId_Union() {}

// To_System_Alarm_TypeId_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_Alarm_TypeId_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_Alarm) To_System_Alarm_TypeId_Union(i interface{}) (System_Alarm_TypeId_Union, error) {
	if v, ok := i.(System_Alarm_TypeId_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_Alarm_TypeId_Union, unknown union type, got: %T, want any of [E_AlarmTypes_OPENCONFIG_ALARM_TYPE_ID, string]", i, i)
}

// System_Cpu_Index_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/cpus/cpu/state/index within the YANG schema.
// Union type can be one of [E_Cpu_Index, UnionUint32].
type System_Cpu_Index_Union interface {
	// Union type can be one of [E_Cpu_Index, UnionUint32]
	Documentation_for_System_Cpu_Index_Union()
}

// Documentation_for_System_Cpu_Index_Union ensures that E_Cpu_Index
// implements the System_Cpu_Index_Union interface.
func (E_Cpu_Index) Documentation_for_System_Cpu_Index_Union() {}

// Documentation_for_System_Cpu_Index_Union ensures that UnionUint32
// implements the System_Cpu_Index_Union interface.
func (UnionUint32) Documentation_for_System_Cpu_Index_Union() {}

// To_System_Cpu_Index_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_Cpu_Index_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_Cpu) To_System_Cpu_Index_Union(i interface{}) (System_Cpu_Index_Union, error) {
	if v, ok := i.(System_Cpu_Index_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case uint32:
		return UnionUint32(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_Cpu_Index_Union, unknown union type, got: %T, want any of [E_Cpu_Index, uint32]", i, i)
}

// System_GrpcServer_ListenAddresses_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/grpc-servers/grpc-server/state/listen-addresses within the YANG schema.
// Union type can be one of [E_GrpcServer_ListenAddresses, UnionString].
type System_GrpcServer_ListenAddresses_Union interface {
	// Union type can be one of [E_GrpcServer_ListenAddresses, UnionString]
	Documentation_for_System_GrpcServer_ListenAddresses_Union()
}

// Documentation_for_System_GrpcServer_ListenAddresses_Union ensures that E_GrpcServer_ListenAddresses
// implements the System_GrpcServer_ListenAddresses_Union interface.
func (E_GrpcServer_ListenAddresses) Documentation_for_System_GrpcServer_ListenAddresses_Union() {}

// Documentation_for_System_GrpcServer_ListenAddresses_Union ensures that UnionString
// implements the System_GrpcServer_ListenAddresses_Union interface.
func (UnionString) Documentation_for_System_GrpcServer_ListenAddresses_Union() {}

// To_System_GrpcServer_ListenAddresses_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_GrpcServer_ListenAddresses_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_GrpcServer) To_System_GrpcServer_ListenAddresses_Union(i interface{}) (System_GrpcServer_ListenAddresses_Union, error) {
	if v, ok := i.(System_GrpcServer_ListenAddresses_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_GrpcServer_ListenAddresses_Union, unknown union type, got: %T, want any of [E_GrpcServer_ListenAddresses, string]", i, i)
}

// System_License_License_LicenseData_Union is an interface that is implemented by valid types for the union
// for the leaf /openconfig-system/system/license/licenses/license/state/license-data within the YANG schema.
// Union type can be one of [Binary, UnionString].
type System_License_License_LicenseData_Union interface {
	// Union type can be one of [Binary, UnionString]
	Documentation_for_System_License_License_LicenseData_Union()
}

// Documentation_for_System_License_License_LicenseData_Union ensures that Binary
// implements the System_License_License_LicenseData_Union interface.
func (Binary) Documentation_for_System_License_License_LicenseData_Union() {}

// Documentation_for_System_License_License_LicenseData_Union ensures that UnionString
// implements the System_License_License_LicenseData_Union interface.
func (UnionString) Documentation_for_System_License_License_LicenseData_Union() {}

// To_System_License_License_LicenseData_Union takes an input interface{} and attempts to convert it to a struct
// which implements the System_License_License_LicenseData_Union union. It returns an error if the interface{} supplied
// cannot be converted to a type within the union.
func (t *System_License_License) To_System_License_License_LicenseData_Union(i interface{}) (System_License_License_LicenseData_Union, error) {
	if v, ok := i.(System_License_License_LicenseData_Union); ok {
		return v, nil
	}
	switch v := i.(type) {
	case []byte:
		return Binary(v), nil
	case string:
		return UnionString(v), nil
	}
	return nil, fmt.Errorf("cannot convert %v to System_License_License_LicenseData_Union, unknown union type, got: %T, want any of [Binary, string]", i, i)
}
