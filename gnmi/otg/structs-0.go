//go:build go1.18

/*
Package otg is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was true
in this case).

This package was generated by ygnmi version: v0.2.1: (ygot: v0.23.1)
using the following YANG input files:
  - models-yang/models/isis/open-traffic-generator-isis.yang
  - models-yang/models/types/open-traffic-generator-types.yang
  - models-yang/models/flow/open-traffic-generator-flow.yang
  - models-yang/models/discovery/open-traffic-generator-discovery.yang
  - models-yang/models/interface/open-traffic-generator-port.yang
  - models-yang/models/bgp/open-traffic-generator-bgp.yang
  - models-yang/models/lag/open-traffic-generator-lag.yang
  - models-yang/models/lacp/open-traffic-generator-lacp.yang

Imported modules were sourced from:
  - models-yang/models/...
*/
package otg

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Root{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// BgpPeer represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer YANG schema element.
type BgpPeer struct {
	Counters          *BgpPeer_Counters                                            `path:"state/counters" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Name              *string                                                      `path:"state/name|name" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"name" shadow-module:"open-traffic-generator-bgp"`
	SessionState      E_BgpPeer_SessionState                                       `path:"state/session-state" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	UnicastIpv4Prefix map[BgpPeer_UnicastIpv4Prefix_Key]*BgpPeer_UnicastIpv4Prefix `path:"unicast-ipv4-prefixes/unicast-ipv4-prefix" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	UnicastIpv6Prefix map[BgpPeer_UnicastIpv6Prefix_Key]*BgpPeer_UnicastIpv6Prefix `path:"unicast-ipv6-prefixes/unicast-ipv6-prefix" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer) IsYANGGoStruct() {}

// BgpPeer_UnicastIpv4Prefix_Key represents the key for list UnicastIpv4Prefix of element /open-traffic-generator-bgp/bgp-peers/bgp-peer.
type BgpPeer_UnicastIpv4Prefix_Key struct {
	Address      string                     `path:"address"`
	PrefixLength uint32                     `path:"prefix-length"`
	Origin       E_UnicastIpv4Prefix_Origin `path:"origin"`
	PathId       uint32                     `path:"path-id"`
}

// BgpPeer_UnicastIpv6Prefix_Key represents the key for list UnicastIpv6Prefix of element /open-traffic-generator-bgp/bgp-peers/bgp-peer.
type BgpPeer_UnicastIpv6Prefix_Key struct {
	Address      string                     `path:"address"`
	PrefixLength uint32                     `path:"prefix-length"`
	Origin       E_UnicastIpv6Prefix_Origin `path:"origin"`
	PathId       uint32                     `path:"path-id"`
}

// NewUnicastIpv4Prefix creates a new entry in the UnicastIpv4Prefix list of the
// BgpPeer struct. The keys of the list are populated from the input
// arguments.
func (t *BgpPeer) NewUnicastIpv4Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv4Prefix_Origin, PathId uint32) (*BgpPeer_UnicastIpv4Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnicastIpv4Prefix == nil {
		t.UnicastIpv4Prefix = make(map[BgpPeer_UnicastIpv4Prefix_Key]*BgpPeer_UnicastIpv4Prefix)
	}

	key := BgpPeer_UnicastIpv4Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnicastIpv4Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnicastIpv4Prefix", key)
	}

	t.UnicastIpv4Prefix[key] = &BgpPeer_UnicastIpv4Prefix{
		Address:      &Address,
		PrefixLength: &PrefixLength,
		Origin:       Origin,
		PathId:       &PathId,
	}

	return t.UnicastIpv4Prefix[key], nil
}

// GetOrCreateUnicastIpv4Prefix retrieves the value with the specified keys from
// the receiver BgpPeer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *BgpPeer) GetOrCreateUnicastIpv4Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv4Prefix_Origin, PathId uint32) *BgpPeer_UnicastIpv4Prefix {

	key := BgpPeer_UnicastIpv4Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	if v, ok := t.UnicastIpv4Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnicastIpv4Prefix(Address, PrefixLength, Origin, PathId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnicastIpv4Prefix got unexpected error: %v", err))
	}
	return v
}

// GetUnicastIpv4Prefix retrieves the value with the specified key from
// the UnicastIpv4Prefix map field of BgpPeer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *BgpPeer) GetUnicastIpv4Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv4Prefix_Origin, PathId uint32) *BgpPeer_UnicastIpv4Prefix {

	if t == nil {
		return nil
	}

	key := BgpPeer_UnicastIpv4Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	if lm, ok := t.UnicastIpv4Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnicastIpv4Prefix deletes the value with the specified keys from
// the receiver BgpPeer. If there is no such element, the function
// is a no-op.
func (t *BgpPeer) DeleteUnicastIpv4Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv4Prefix_Origin, PathId uint32) {
	key := BgpPeer_UnicastIpv4Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	delete(t.UnicastIpv4Prefix, key)
}

// AppendUnicastIpv4Prefix appends the supplied BgpPeer_UnicastIpv4Prefix struct to the
// list UnicastIpv4Prefix of BgpPeer. If the key value(s) specified in
// the supplied BgpPeer_UnicastIpv4Prefix already exist in the list, an error is
// returned.
func (t *BgpPeer) AppendUnicastIpv4Prefix(v *BgpPeer_UnicastIpv4Prefix) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	if v.PrefixLength == nil {
		return fmt.Errorf("invalid nil key for PrefixLength")
	}

	if v.PathId == nil {
		return fmt.Errorf("invalid nil key for PathId")
	}

	key := BgpPeer_UnicastIpv4Prefix_Key{
		Address:      *v.Address,
		PrefixLength: *v.PrefixLength,
		Origin:       v.Origin,
		PathId:       *v.PathId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnicastIpv4Prefix == nil {
		t.UnicastIpv4Prefix = make(map[BgpPeer_UnicastIpv4Prefix_Key]*BgpPeer_UnicastIpv4Prefix)
	}

	if _, ok := t.UnicastIpv4Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list UnicastIpv4Prefix %v", key)
	}

	t.UnicastIpv4Prefix[key] = v
	return nil
}

// NewUnicastIpv6Prefix creates a new entry in the UnicastIpv6Prefix list of the
// BgpPeer struct. The keys of the list are populated from the input
// arguments.
func (t *BgpPeer) NewUnicastIpv6Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv6Prefix_Origin, PathId uint32) (*BgpPeer_UnicastIpv6Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnicastIpv6Prefix == nil {
		t.UnicastIpv6Prefix = make(map[BgpPeer_UnicastIpv6Prefix_Key]*BgpPeer_UnicastIpv6Prefix)
	}

	key := BgpPeer_UnicastIpv6Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.UnicastIpv6Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list UnicastIpv6Prefix", key)
	}

	t.UnicastIpv6Prefix[key] = &BgpPeer_UnicastIpv6Prefix{
		Address:      &Address,
		PrefixLength: &PrefixLength,
		Origin:       Origin,
		PathId:       &PathId,
	}

	return t.UnicastIpv6Prefix[key], nil
}

// GetOrCreateUnicastIpv6Prefix retrieves the value with the specified keys from
// the receiver BgpPeer. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *BgpPeer) GetOrCreateUnicastIpv6Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv6Prefix_Origin, PathId uint32) *BgpPeer_UnicastIpv6Prefix {

	key := BgpPeer_UnicastIpv6Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	if v, ok := t.UnicastIpv6Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUnicastIpv6Prefix(Address, PrefixLength, Origin, PathId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUnicastIpv6Prefix got unexpected error: %v", err))
	}
	return v
}

// GetUnicastIpv6Prefix retrieves the value with the specified key from
// the UnicastIpv6Prefix map field of BgpPeer. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *BgpPeer) GetUnicastIpv6Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv6Prefix_Origin, PathId uint32) *BgpPeer_UnicastIpv6Prefix {

	if t == nil {
		return nil
	}

	key := BgpPeer_UnicastIpv6Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	if lm, ok := t.UnicastIpv6Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeleteUnicastIpv6Prefix deletes the value with the specified keys from
// the receiver BgpPeer. If there is no such element, the function
// is a no-op.
func (t *BgpPeer) DeleteUnicastIpv6Prefix(Address string, PrefixLength uint32, Origin E_UnicastIpv6Prefix_Origin, PathId uint32) {
	key := BgpPeer_UnicastIpv6Prefix_Key{
		Address:      Address,
		PrefixLength: PrefixLength,
		Origin:       Origin,
		PathId:       PathId,
	}

	delete(t.UnicastIpv6Prefix, key)
}

// AppendUnicastIpv6Prefix appends the supplied BgpPeer_UnicastIpv6Prefix struct to the
// list UnicastIpv6Prefix of BgpPeer. If the key value(s) specified in
// the supplied BgpPeer_UnicastIpv6Prefix already exist in the list, an error is
// returned.
func (t *BgpPeer) AppendUnicastIpv6Prefix(v *BgpPeer_UnicastIpv6Prefix) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	if v.PrefixLength == nil {
		return fmt.Errorf("invalid nil key for PrefixLength")
	}

	if v.PathId == nil {
		return fmt.Errorf("invalid nil key for PathId")
	}

	key := BgpPeer_UnicastIpv6Prefix_Key{
		Address:      *v.Address,
		PrefixLength: *v.PrefixLength,
		Origin:       v.Origin,
		PathId:       *v.PathId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.UnicastIpv6Prefix == nil {
		t.UnicastIpv6Prefix = make(map[BgpPeer_UnicastIpv6Prefix_Key]*BgpPeer_UnicastIpv6Prefix)
	}

	if _, ok := t.UnicastIpv6Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list UnicastIpv6Prefix %v", key)
	}

	t.UnicastIpv6Prefix[key] = v
	return nil
}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *BgpPeer) GetOrCreateCounters() *BgpPeer_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &BgpPeer_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from BgpPeer. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *BgpPeer) GetCounters() *BgpPeer_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the BgpPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *BgpPeer) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSessionState retrieves the value of the leaf SessionState from the BgpPeer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionState is set, it can
// safely use t.GetSessionState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionState == nil' before retrieving the leaf's value.
func (t *BgpPeer) GetSessionState() E_BgpPeer_SessionState {
	if t == nil || t.SessionState == 0 {
		return 0
	}
	return t.SessionState
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	for _, e := range t.UnicastIpv4Prefix {
		e.PopulateDefaults()
	}
	for _, e := range t.UnicastIpv6Prefix {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the BgpPeer struct, which is a YANG list entry.
func (t *BgpPeer) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer.
func (*BgpPeer) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// BgpPeer_Counters represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/state/counters YANG schema element.
type BgpPeer_Counters struct {
	Flaps            *uint64 `path:"flaps" module:"open-traffic-generator-bgp"`
	InKeepalives     *uint64 `path:"in-keepalives" module:"open-traffic-generator-bgp"`
	InNotifications  *uint64 `path:"in-notifications" module:"open-traffic-generator-bgp"`
	InOpens          *uint64 `path:"in-opens" module:"open-traffic-generator-bgp"`
	InRouteWithdraw  *uint64 `path:"in-route-withdraw" module:"open-traffic-generator-bgp"`
	InRoutes         *uint64 `path:"in-routes" module:"open-traffic-generator-bgp"`
	InUpdates        *uint64 `path:"in-updates" module:"open-traffic-generator-bgp"`
	OutKeepalives    *uint64 `path:"out-keepalives" module:"open-traffic-generator-bgp"`
	OutNotifications *uint64 `path:"out-notifications" module:"open-traffic-generator-bgp"`
	OutOpens         *uint64 `path:"out-opens" module:"open-traffic-generator-bgp"`
	OutRouteWithdraw *uint64 `path:"out-route-withdraw" module:"open-traffic-generator-bgp"`
	OutRoutes        *uint64 `path:"out-routes" module:"open-traffic-generator-bgp"`
	OutUpdates       *uint64 `path:"out-updates" module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_Counters) IsYANGGoStruct() {}

// GetFlaps retrieves the value of the leaf Flaps from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flaps is set, it can
// safely use t.GetFlaps() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flaps == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetFlaps() uint64 {
	if t == nil || t.Flaps == nil {
		return 0
	}
	return *t.Flaps
}

// GetInKeepalives retrieves the value of the leaf InKeepalives from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InKeepalives is set, it can
// safely use t.GetInKeepalives() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InKeepalives == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInKeepalives() uint64 {
	if t == nil || t.InKeepalives == nil {
		return 0
	}
	return *t.InKeepalives
}

// GetInNotifications retrieves the value of the leaf InNotifications from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InNotifications is set, it can
// safely use t.GetInNotifications() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InNotifications == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInNotifications() uint64 {
	if t == nil || t.InNotifications == nil {
		return 0
	}
	return *t.InNotifications
}

// GetInOpens retrieves the value of the leaf InOpens from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOpens is set, it can
// safely use t.GetInOpens() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOpens == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInOpens() uint64 {
	if t == nil || t.InOpens == nil {
		return 0
	}
	return *t.InOpens
}

// GetInRouteWithdraw retrieves the value of the leaf InRouteWithdraw from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRouteWithdraw is set, it can
// safely use t.GetInRouteWithdraw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRouteWithdraw == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInRouteWithdraw() uint64 {
	if t == nil || t.InRouteWithdraw == nil {
		return 0
	}
	return *t.InRouteWithdraw
}

// GetInRoutes retrieves the value of the leaf InRoutes from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRoutes is set, it can
// safely use t.GetInRoutes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRoutes == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInRoutes() uint64 {
	if t == nil || t.InRoutes == nil {
		return 0
	}
	return *t.InRoutes
}

// GetInUpdates retrieves the value of the leaf InUpdates from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InUpdates is set, it can
// safely use t.GetInUpdates() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InUpdates == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetInUpdates() uint64 {
	if t == nil || t.InUpdates == nil {
		return 0
	}
	return *t.InUpdates
}

// GetOutKeepalives retrieves the value of the leaf OutKeepalives from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutKeepalives is set, it can
// safely use t.GetOutKeepalives() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutKeepalives == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutKeepalives() uint64 {
	if t == nil || t.OutKeepalives == nil {
		return 0
	}
	return *t.OutKeepalives
}

// GetOutNotifications retrieves the value of the leaf OutNotifications from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutNotifications is set, it can
// safely use t.GetOutNotifications() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutNotifications == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutNotifications() uint64 {
	if t == nil || t.OutNotifications == nil {
		return 0
	}
	return *t.OutNotifications
}

// GetOutOpens retrieves the value of the leaf OutOpens from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOpens is set, it can
// safely use t.GetOutOpens() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOpens == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutOpens() uint64 {
	if t == nil || t.OutOpens == nil {
		return 0
	}
	return *t.OutOpens
}

// GetOutRouteWithdraw retrieves the value of the leaf OutRouteWithdraw from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRouteWithdraw is set, it can
// safely use t.GetOutRouteWithdraw() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRouteWithdraw == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutRouteWithdraw() uint64 {
	if t == nil || t.OutRouteWithdraw == nil {
		return 0
	}
	return *t.OutRouteWithdraw
}

// GetOutRoutes retrieves the value of the leaf OutRoutes from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRoutes is set, it can
// safely use t.GetOutRoutes() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRoutes == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutRoutes() uint64 {
	if t == nil || t.OutRoutes == nil {
		return 0
	}
	return *t.OutRoutes
}

// GetOutUpdates retrieves the value of the leaf OutUpdates from the BgpPeer_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutUpdates is set, it can
// safely use t.GetOutUpdates() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutUpdates == nil' before retrieving the leaf's value.
func (t *BgpPeer_Counters) GetOutUpdates() uint64 {
	if t == nil || t.OutUpdates == nil {
		return 0
	}
	return *t.OutUpdates
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer_Counters.
func (*BgpPeer_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// BgpPeer_UnicastIpv4Prefix represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/unicast-ipv4-prefixes/unicast-ipv4-prefix YANG schema element.
type BgpPeer_UnicastIpv4Prefix struct {
	Address            *string                                `path:"state/address|address" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"address" shadow-module:"open-traffic-generator-bgp"`
	AsPath             []*BgpPeer_UnicastIpv4Prefix_AsPath    `path:"state/as-path" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Community          []*BgpPeer_UnicastIpv4Prefix_Community `path:"state/community" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	NextHopIpv4Address *string                                `path:"state/next-hop-ipv4-address" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	NextHopIpv6Address *string                                `path:"state/next-hop-ipv6-address" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Origin             E_UnicastIpv4Prefix_Origin             `path:"state/origin|origin" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"origin" shadow-module:"open-traffic-generator-bgp"`
	PathId             *uint32                                `path:"state/path-id|path-id" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"path-id" shadow-module:"open-traffic-generator-bgp"`
	PrefixLength       *uint32                                `path:"state/prefix-length|prefix-length" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"prefix-length" shadow-module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_UnicastIpv4Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_UnicastIpv4Prefix) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the BgpPeer_UnicastIpv4Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetNextHopIpv4Address retrieves the value of the leaf NextHopIpv4Address from the BgpPeer_UnicastIpv4Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopIpv4Address is set, it can
// safely use t.GetNextHopIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopIpv4Address == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix) GetNextHopIpv4Address() string {
	if t == nil || t.NextHopIpv4Address == nil {
		return ""
	}
	return *t.NextHopIpv4Address
}

// GetNextHopIpv6Address retrieves the value of the leaf NextHopIpv6Address from the BgpPeer_UnicastIpv4Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopIpv6Address is set, it can
// safely use t.GetNextHopIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopIpv6Address == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix) GetNextHopIpv6Address() string {
	if t == nil || t.NextHopIpv6Address == nil {
		return ""
	}
	return *t.NextHopIpv6Address
}

// GetOrigin retrieves the value of the leaf Origin from the BgpPeer_UnicastIpv4Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix) GetOrigin() E_UnicastIpv4Prefix_Origin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPathId retrieves the value of the leaf PathId from the BgpPeer_UnicastIpv4Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathId is set, it can
// safely use t.GetPathId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathId == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix) GetPathId() uint32 {
	if t == nil || t.PathId == nil {
		return 0
	}
	return *t.PathId
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the BgpPeer_UnicastIpv4Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix) GetPrefixLength() uint32 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_UnicastIpv4Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_UnicastIpv4Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PathId == nil {
		var v uint32 = 0
		t.PathId = &v
	}
	for _, e := range t.AsPath {
		e.PopulateDefaults()
	}
	for _, e := range t.Community {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the BgpPeer_UnicastIpv4Prefix struct, which is a YANG list entry.
func (t *BgpPeer_UnicastIpv4Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.PathId == nil {
		return nil, fmt.Errorf("nil value for key PathId")
	}

	if t.PrefixLength == nil {
		return nil, fmt.Errorf("nil value for key PrefixLength")
	}

	return map[string]interface{}{
		"address":       *t.Address,
		"origin":        t.Origin,
		"path-id":       *t.PathId,
		"prefix-length": *t.PrefixLength,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv4Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_UnicastIpv4Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv4Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_UnicastIpv4Prefix) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer_UnicastIpv4Prefix.
func (*BgpPeer_UnicastIpv4Prefix) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// BgpPeer_UnicastIpv4Prefix_AsPath represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/unicast-ipv4-prefixes/unicast-ipv4-prefix/state/as-path YANG schema element.
type BgpPeer_UnicastIpv4Prefix_AsPath struct {
	AsNumbers   []uint32            `path:"as_numbers" module:"open-traffic-generator-bgp"`
	SegmentType E_State_SegmentType `path:"segment-type" module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_UnicastIpv4Prefix_AsPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_UnicastIpv4Prefix_AsPath) IsYANGGoStruct() {}

// GetAsNumbers retrieves the value of the leaf AsNumbers from the BgpPeer_UnicastIpv4Prefix_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AsNumbers is set, it can
// safely use t.GetAsNumbers() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AsNumbers == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix_AsPath) GetAsNumbers() []uint32 {
	if t == nil || t.AsNumbers == nil {
		return nil
	}
	return t.AsNumbers
}

// GetSegmentType retrieves the value of the leaf SegmentType from the BgpPeer_UnicastIpv4Prefix_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SegmentType is set, it can
// safely use t.GetSegmentType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SegmentType == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix_AsPath) GetSegmentType() E_State_SegmentType {
	if t == nil || t.SegmentType == 0 {
		return 0
	}
	return t.SegmentType
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_UnicastIpv4Prefix_AsPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_UnicastIpv4Prefix_AsPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv4Prefix_AsPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_UnicastIpv4Prefix_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv4Prefix_AsPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_UnicastIpv4Prefix_AsPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer_UnicastIpv4Prefix_AsPath.
func (*BgpPeer_UnicastIpv4Prefix_AsPath) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// BgpPeer_UnicastIpv4Prefix_Community represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/unicast-ipv4-prefixes/unicast-ipv4-prefix/state/community YANG schema element.
type BgpPeer_UnicastIpv4Prefix_Community struct {
	CommunityType  E_State_CommunityType `path:"community-type" module:"open-traffic-generator-bgp"`
	CustomAsNumber *uint16               `path:"custom-as-number" module:"open-traffic-generator-bgp"`
	CustomAsValue  *uint16               `path:"custom-as-value" module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_UnicastIpv4Prefix_Community implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_UnicastIpv4Prefix_Community) IsYANGGoStruct() {}

// GetCommunityType retrieves the value of the leaf CommunityType from the BgpPeer_UnicastIpv4Prefix_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommunityType is set, it can
// safely use t.GetCommunityType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommunityType == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix_Community) GetCommunityType() E_State_CommunityType {
	if t == nil || t.CommunityType == 0 {
		return 0
	}
	return t.CommunityType
}

// GetCustomAsNumber retrieves the value of the leaf CustomAsNumber from the BgpPeer_UnicastIpv4Prefix_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CustomAsNumber is set, it can
// safely use t.GetCustomAsNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CustomAsNumber == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix_Community) GetCustomAsNumber() uint16 {
	if t == nil || t.CustomAsNumber == nil {
		return 0
	}
	return *t.CustomAsNumber
}

// GetCustomAsValue retrieves the value of the leaf CustomAsValue from the BgpPeer_UnicastIpv4Prefix_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CustomAsValue is set, it can
// safely use t.GetCustomAsValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CustomAsValue == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv4Prefix_Community) GetCustomAsValue() uint16 {
	if t == nil || t.CustomAsValue == nil {
		return 0
	}
	return *t.CustomAsValue
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_UnicastIpv4Prefix_Community
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_UnicastIpv4Prefix_Community) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv4Prefix_Community) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_UnicastIpv4Prefix_Community"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv4Prefix_Community) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_UnicastIpv4Prefix_Community) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer_UnicastIpv4Prefix_Community.
func (*BgpPeer_UnicastIpv4Prefix_Community) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// BgpPeer_UnicastIpv6Prefix represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/unicast-ipv6-prefixes/unicast-ipv6-prefix YANG schema element.
type BgpPeer_UnicastIpv6Prefix struct {
	Address            *string                                `path:"state/address|address" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"address" shadow-module:"open-traffic-generator-bgp"`
	AsPath             []*BgpPeer_UnicastIpv6Prefix_AsPath    `path:"state/as-path" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Community          []*BgpPeer_UnicastIpv6Prefix_Community `path:"state/community" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	NextHopIpv4Address *string                                `path:"state/next-hop-ipv4-address" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	NextHopIpv6Address *string                                `path:"state/next-hop-ipv6-address" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Origin             E_UnicastIpv6Prefix_Origin             `path:"state/origin|origin" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"origin" shadow-module:"open-traffic-generator-bgp"`
	PathId             *uint32                                `path:"state/path-id|path-id" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"path-id" shadow-module:"open-traffic-generator-bgp"`
	PrefixLength       *uint32                                `path:"state/prefix-length|prefix-length" module:"open-traffic-generator-bgp/open-traffic-generator-bgp|open-traffic-generator-bgp" shadow-path:"prefix-length" shadow-module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_UnicastIpv6Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_UnicastIpv6Prefix) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the BgpPeer_UnicastIpv6Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetNextHopIpv4Address retrieves the value of the leaf NextHopIpv4Address from the BgpPeer_UnicastIpv6Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopIpv4Address is set, it can
// safely use t.GetNextHopIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopIpv4Address == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix) GetNextHopIpv4Address() string {
	if t == nil || t.NextHopIpv4Address == nil {
		return ""
	}
	return *t.NextHopIpv4Address
}

// GetNextHopIpv6Address retrieves the value of the leaf NextHopIpv6Address from the BgpPeer_UnicastIpv6Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHopIpv6Address is set, it can
// safely use t.GetNextHopIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHopIpv6Address == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix) GetNextHopIpv6Address() string {
	if t == nil || t.NextHopIpv6Address == nil {
		return ""
	}
	return *t.NextHopIpv6Address
}

// GetOrigin retrieves the value of the leaf Origin from the BgpPeer_UnicastIpv6Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Origin is set, it can
// safely use t.GetOrigin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Origin == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix) GetOrigin() E_UnicastIpv6Prefix_Origin {
	if t == nil || t.Origin == 0 {
		return 0
	}
	return t.Origin
}

// GetPathId retrieves the value of the leaf PathId from the BgpPeer_UnicastIpv6Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathId is set, it can
// safely use t.GetPathId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathId == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix) GetPathId() uint32 {
	if t == nil || t.PathId == nil {
		return 0
	}
	return *t.PathId
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the BgpPeer_UnicastIpv6Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix) GetPrefixLength() uint32 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_UnicastIpv6Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_UnicastIpv6Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PathId == nil {
		var v uint32 = 0
		t.PathId = &v
	}
	for _, e := range t.AsPath {
		e.PopulateDefaults()
	}
	for _, e := range t.Community {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the BgpPeer_UnicastIpv6Prefix struct, which is a YANG list entry.
func (t *BgpPeer_UnicastIpv6Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.PathId == nil {
		return nil, fmt.Errorf("nil value for key PathId")
	}

	if t.PrefixLength == nil {
		return nil, fmt.Errorf("nil value for key PrefixLength")
	}

	return map[string]interface{}{
		"address":       *t.Address,
		"origin":        t.Origin,
		"path-id":       *t.PathId,
		"prefix-length": *t.PrefixLength,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv6Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_UnicastIpv6Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv6Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_UnicastIpv6Prefix) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer_UnicastIpv6Prefix.
func (*BgpPeer_UnicastIpv6Prefix) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// BgpPeer_UnicastIpv6Prefix_AsPath represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/unicast-ipv6-prefixes/unicast-ipv6-prefix/state/as-path YANG schema element.
type BgpPeer_UnicastIpv6Prefix_AsPath struct {
	AsNumbers   []uint32            `path:"as_numbers" module:"open-traffic-generator-bgp"`
	SegmentType E_State_SegmentType `path:"segment-type" module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_UnicastIpv6Prefix_AsPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_UnicastIpv6Prefix_AsPath) IsYANGGoStruct() {}

// GetAsNumbers retrieves the value of the leaf AsNumbers from the BgpPeer_UnicastIpv6Prefix_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AsNumbers is set, it can
// safely use t.GetAsNumbers() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AsNumbers == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix_AsPath) GetAsNumbers() []uint32 {
	if t == nil || t.AsNumbers == nil {
		return nil
	}
	return t.AsNumbers
}

// GetSegmentType retrieves the value of the leaf SegmentType from the BgpPeer_UnicastIpv6Prefix_AsPath
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SegmentType is set, it can
// safely use t.GetSegmentType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SegmentType == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix_AsPath) GetSegmentType() E_State_SegmentType {
	if t == nil || t.SegmentType == 0 {
		return 0
	}
	return t.SegmentType
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_UnicastIpv6Prefix_AsPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_UnicastIpv6Prefix_AsPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv6Prefix_AsPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_UnicastIpv6Prefix_AsPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv6Prefix_AsPath) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_UnicastIpv6Prefix_AsPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer_UnicastIpv6Prefix_AsPath.
func (*BgpPeer_UnicastIpv6Prefix_AsPath) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// BgpPeer_UnicastIpv6Prefix_Community represents the /open-traffic-generator-bgp/bgp-peers/bgp-peer/unicast-ipv6-prefixes/unicast-ipv6-prefix/state/community YANG schema element.
type BgpPeer_UnicastIpv6Prefix_Community struct {
	CommunityType  E_State_CommunityType `path:"community-type" module:"open-traffic-generator-bgp"`
	CustomAsNumber *uint16               `path:"custom-as-number" module:"open-traffic-generator-bgp"`
	CustomAsValue  *uint16               `path:"custom-as-value" module:"open-traffic-generator-bgp"`
}

// IsYANGGoStruct ensures that BgpPeer_UnicastIpv6Prefix_Community implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*BgpPeer_UnicastIpv6Prefix_Community) IsYANGGoStruct() {}

// GetCommunityType retrieves the value of the leaf CommunityType from the BgpPeer_UnicastIpv6Prefix_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CommunityType is set, it can
// safely use t.GetCommunityType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CommunityType == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix_Community) GetCommunityType() E_State_CommunityType {
	if t == nil || t.CommunityType == 0 {
		return 0
	}
	return t.CommunityType
}

// GetCustomAsNumber retrieves the value of the leaf CustomAsNumber from the BgpPeer_UnicastIpv6Prefix_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CustomAsNumber is set, it can
// safely use t.GetCustomAsNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CustomAsNumber == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix_Community) GetCustomAsNumber() uint16 {
	if t == nil || t.CustomAsNumber == nil {
		return 0
	}
	return *t.CustomAsNumber
}

// GetCustomAsValue retrieves the value of the leaf CustomAsValue from the BgpPeer_UnicastIpv6Prefix_Community
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CustomAsValue is set, it can
// safely use t.GetCustomAsValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CustomAsValue == nil' before retrieving the leaf's value.
func (t *BgpPeer_UnicastIpv6Prefix_Community) GetCustomAsValue() uint16 {
	if t == nil || t.CustomAsValue == nil {
		return 0
	}
	return *t.CustomAsValue
}

// PopulateDefaults recursively populates unset leaf fields in the BgpPeer_UnicastIpv6Prefix_Community
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *BgpPeer_UnicastIpv6Prefix_Community) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv6Prefix_Community) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["BgpPeer_UnicastIpv6Prefix_Community"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *BgpPeer_UnicastIpv6Prefix_Community) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *BgpPeer_UnicastIpv6Prefix_Community) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of BgpPeer_UnicastIpv6Prefix_Community.
func (*BgpPeer_UnicastIpv6Prefix_Community) ΛBelongingModule() string {
	return "open-traffic-generator-bgp"
}

// Flow represents the /open-traffic-generator-flow/flows/flow YANG schema element.
type Flow struct {
	Counters     *Flow_Counters `path:"state/counters" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	InFrameRate  Binary         `path:"state/in-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	InRate       Binary         `path:"state/in-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	LossPct      Binary         `path:"state/loss-pct" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	Name         *string        `path:"state/name|name" module:"open-traffic-generator-flow/open-traffic-generator-flow|open-traffic-generator-flow" shadow-path:"name" shadow-module:"open-traffic-generator-flow"`
	OutFrameRate Binary         `path:"state/out-frame-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	OutRate      Binary         `path:"state/out-rate" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	Transmit     *bool          `path:"state/transmit" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
}

// IsYANGGoStruct ensures that Flow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Flow) GetOrCreateCounters() *Flow_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Flow_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Flow. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Flow) GetCounters() *Flow_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInFrameRate retrieves the value of the leaf InFrameRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFrameRate is set, it can
// safely use t.GetInFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFrameRate == nil' before retrieving the leaf's value.
func (t *Flow) GetInFrameRate() Binary {
	if t == nil || t.InFrameRate == nil {
		return nil
	}
	return t.InFrameRate
}

// GetInRate retrieves the value of the leaf InRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRate is set, it can
// safely use t.GetInRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRate == nil' before retrieving the leaf's value.
func (t *Flow) GetInRate() Binary {
	if t == nil || t.InRate == nil {
		return nil
	}
	return t.InRate
}

// GetLossPct retrieves the value of the leaf LossPct from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LossPct is set, it can
// safely use t.GetLossPct() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LossPct == nil' before retrieving the leaf's value.
func (t *Flow) GetLossPct() Binary {
	if t == nil || t.LossPct == nil {
		return nil
	}
	return t.LossPct
}

// GetName retrieves the value of the leaf Name from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Flow) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOutFrameRate retrieves the value of the leaf OutFrameRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutFrameRate is set, it can
// safely use t.GetOutFrameRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutFrameRate == nil' before retrieving the leaf's value.
func (t *Flow) GetOutFrameRate() Binary {
	if t == nil || t.OutFrameRate == nil {
		return nil
	}
	return t.OutFrameRate
}

// GetOutRate retrieves the value of the leaf OutRate from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRate is set, it can
// safely use t.GetOutRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRate == nil' before retrieving the leaf's value.
func (t *Flow) GetOutRate() Binary {
	if t == nil || t.OutRate == nil {
		return nil
	}
	return t.OutRate
}

// GetTransmit retrieves the value of the leaf Transmit from the Flow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Transmit is set, it can
// safely use t.GetTransmit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Transmit == nil' before retrieving the leaf's value.
func (t *Flow) GetTransmit() bool {
	if t == nil || t.Transmit == nil {
		return false
	}
	return *t.Transmit
}

// PopulateDefaults recursively populates unset leaf fields in the Flow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Flow struct, which is a YANG list entry.
func (t *Flow) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow.
func (*Flow) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Flow_Counters represents the /open-traffic-generator-flow/flows/flow/state/counters YANG schema element.
type Flow_Counters struct {
	InOctets  *uint64 `path:"in-octets" module:"open-traffic-generator-flow"`
	InPkts    *uint64 `path:"in-pkts" module:"open-traffic-generator-flow"`
	OutOctets *uint64 `path:"out-octets" module:"open-traffic-generator-flow"`
	OutPkts   *uint64 `path:"out-pkts" module:"open-traffic-generator-flow"`
}

// IsYANGGoStruct ensures that Flow_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Flow_Counters) IsYANGGoStruct() {}

// GetInOctets retrieves the value of the leaf InOctets from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetInPkts retrieves the value of the leaf InPkts from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPkts is set, it can
// safely use t.GetInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPkts == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetInPkts() uint64 {
	if t == nil || t.InPkts == nil {
		return 0
	}
	return *t.InPkts
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// GetOutPkts retrieves the value of the leaf OutPkts from the Flow_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPkts is set, it can
// safely use t.GetOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPkts == nil' before retrieving the leaf's value.
func (t *Flow_Counters) GetOutPkts() uint64 {
	if t == nil || t.OutPkts == nil {
		return 0
	}
	return *t.OutPkts
}

// PopulateDefaults recursively populates unset leaf fields in the Flow_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Flow_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Flow_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Flow_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Flow_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Flow_Counters.
func (*Flow_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-flow"
}

// Interface represents the /open-traffic-generator-discovery/interfaces/interface YANG schema element.
type Interface struct {
	Ipv4Neighbor map[string]*Interface_Ipv4Neighbor `path:"ipv4-neighbors/ipv4-neighbor" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	Ipv6Neighbor map[string]*Interface_Ipv6Neighbor `path:"ipv6-neighbors/ipv6-neighbor" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	Name         *string                            `path:"state/name|name" module:"open-traffic-generator-discovery/open-traffic-generator-discovery|open-traffic-generator-discovery" shadow-path:"name" shadow-module:"open-traffic-generator-discovery"`
}

// IsYANGGoStruct ensures that Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface) IsYANGGoStruct() {}

// NewIpv4Neighbor creates a new entry in the Ipv4Neighbor list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewIpv4Neighbor(Ipv4Address string) (*Interface_Ipv4Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Neighbor == nil {
		t.Ipv4Neighbor = make(map[string]*Interface_Ipv4Neighbor)
	}

	key := Ipv4Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv4Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv4Neighbor", key)
	}

	t.Ipv4Neighbor[key] = &Interface_Ipv4Neighbor{
		Ipv4Address: &Ipv4Address,
	}

	return t.Ipv4Neighbor[key], nil
}

// GetOrCreateIpv4Neighbor retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateIpv4Neighbor(Ipv4Address string) *Interface_Ipv4Neighbor {

	key := Ipv4Address

	if v, ok := t.Ipv4Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv4Neighbor(Ipv4Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv4Neighbor got unexpected error: %v", err))
	}
	return v
}

// GetIpv4Neighbor retrieves the value with the specified key from
// the Ipv4Neighbor map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetIpv4Neighbor(Ipv4Address string) *Interface_Ipv4Neighbor {

	if t == nil {
		return nil
	}

	key := Ipv4Address

	if lm, ok := t.Ipv4Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv4Neighbor deletes the value with the specified keys from
// the receiver Interface. If there is no such element, the function
// is a no-op.
func (t *Interface) DeleteIpv4Neighbor(Ipv4Address string) {
	key := Ipv4Address

	delete(t.Ipv4Neighbor, key)
}

// AppendIpv4Neighbor appends the supplied Interface_Ipv4Neighbor struct to the
// list Ipv4Neighbor of Interface. If the key value(s) specified in
// the supplied Interface_Ipv4Neighbor already exist in the list, an error is
// returned.
func (t *Interface) AppendIpv4Neighbor(v *Interface_Ipv4Neighbor) error {
	if v.Ipv4Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv4Address")
	}

	key := *v.Ipv4Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv4Neighbor == nil {
		t.Ipv4Neighbor = make(map[string]*Interface_Ipv4Neighbor)
	}

	if _, ok := t.Ipv4Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv4Neighbor %v", key)
	}

	t.Ipv4Neighbor[key] = v
	return nil
}

// NewIpv6Neighbor creates a new entry in the Ipv6Neighbor list of the
// Interface struct. The keys of the list are populated from the input
// arguments.
func (t *Interface) NewIpv6Neighbor(Ipv6Address string) (*Interface_Ipv6Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Neighbor == nil {
		t.Ipv6Neighbor = make(map[string]*Interface_Ipv6Neighbor)
	}

	key := Ipv6Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6Neighbor", key)
	}

	t.Ipv6Neighbor[key] = &Interface_Ipv6Neighbor{
		Ipv6Address: &Ipv6Address,
	}

	return t.Ipv6Neighbor[key], nil
}

// GetOrCreateIpv6Neighbor retrieves the value with the specified keys from
// the receiver Interface. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Interface) GetOrCreateIpv6Neighbor(Ipv6Address string) *Interface_Ipv6Neighbor {

	key := Ipv6Address

	if v, ok := t.Ipv6Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6Neighbor(Ipv6Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6Neighbor got unexpected error: %v", err))
	}
	return v
}

// GetIpv6Neighbor retrieves the value with the specified key from
// the Ipv6Neighbor map field of Interface. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Interface) GetIpv6Neighbor(Ipv6Address string) *Interface_Ipv6Neighbor {

	if t == nil {
		return nil
	}

	key := Ipv6Address

	if lm, ok := t.Ipv6Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6Neighbor deletes the value with the specified keys from
// the receiver Interface. If there is no such element, the function
// is a no-op.
func (t *Interface) DeleteIpv6Neighbor(Ipv6Address string) {
	key := Ipv6Address

	delete(t.Ipv6Neighbor, key)
}

// AppendIpv6Neighbor appends the supplied Interface_Ipv6Neighbor struct to the
// list Ipv6Neighbor of Interface. If the key value(s) specified in
// the supplied Interface_Ipv6Neighbor already exist in the list, an error is
// returned.
func (t *Interface) AppendIpv6Neighbor(v *Interface_Ipv6Neighbor) error {
	if v.Ipv6Address == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Address")
	}

	key := *v.Ipv6Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6Neighbor == nil {
		t.Ipv6Neighbor = make(map[string]*Interface_Ipv6Neighbor)
	}

	if _, ok := t.Ipv6Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6Neighbor %v", key)
	}

	t.Ipv6Neighbor[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the Interface
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Interface) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the Interface
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Ipv4Neighbor {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6Neighbor {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the Interface struct, which is a YANG list entry.
func (t *Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface.
func (*Interface) ΛBelongingModule() string {
	return "open-traffic-generator-discovery"
}

// Interface_Ipv4Neighbor represents the /open-traffic-generator-discovery/interfaces/interface/ipv4-neighbors/ipv4-neighbor YANG schema element.
type Interface_Ipv4Neighbor struct {
	Ipv4Address      *string `path:"state/ipv4-address|ipv4-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery|open-traffic-generator-discovery" shadow-path:"ipv4-address" shadow-module:"open-traffic-generator-discovery"`
	LinkLayerAddress *string `path:"state/link-layer-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
}

// IsYANGGoStruct ensures that Interface_Ipv4Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ipv4Neighbor) IsYANGGoStruct() {}

// GetIpv4Address retrieves the value of the leaf Ipv4Address from the Interface_Ipv4Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Address is set, it can
// safely use t.GetIpv4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Address == nil' before retrieving the leaf's value.
func (t *Interface_Ipv4Neighbor) GetIpv4Address() string {
	if t == nil || t.Ipv4Address == nil {
		return ""
	}
	return *t.Ipv4Address
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Ipv4Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ipv4Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Ipv4Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Ipv4Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Ipv4Neighbor struct, which is a YANG list entry.
func (t *Interface_Ipv4Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv4Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv4Address")
	}

	return map[string]interface{}{
		"ipv4-address": *t.Ipv4Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv4Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ipv4Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv4Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ipv4Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ipv4Neighbor.
func (*Interface_Ipv4Neighbor) ΛBelongingModule() string {
	return "open-traffic-generator-discovery"
}

// Interface_Ipv6Neighbor represents the /open-traffic-generator-discovery/interfaces/interface/ipv6-neighbors/ipv6-neighbor YANG schema element.
type Interface_Ipv6Neighbor struct {
	Ipv6Address      *string `path:"state/ipv6-address|ipv6-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery|open-traffic-generator-discovery" shadow-path:"ipv6-address" shadow-module:"open-traffic-generator-discovery"`
	LinkLayerAddress *string `path:"state/link-layer-address" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
}

// IsYANGGoStruct ensures that Interface_Ipv6Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Interface_Ipv6Neighbor) IsYANGGoStruct() {}

// GetIpv6Address retrieves the value of the leaf Ipv6Address from the Interface_Ipv6Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Address is set, it can
// safely use t.GetIpv6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Address == nil' before retrieving the leaf's value.
func (t *Interface_Ipv6Neighbor) GetIpv6Address() string {
	if t == nil || t.Ipv6Address == nil {
		return ""
	}
	return *t.Ipv6Address
}

// GetLinkLayerAddress retrieves the value of the leaf LinkLayerAddress from the Interface_Ipv6Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkLayerAddress is set, it can
// safely use t.GetLinkLayerAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkLayerAddress == nil' before retrieving the leaf's value.
func (t *Interface_Ipv6Neighbor) GetLinkLayerAddress() string {
	if t == nil || t.LinkLayerAddress == nil {
		return ""
	}
	return *t.LinkLayerAddress
}

// PopulateDefaults recursively populates unset leaf fields in the Interface_Ipv6Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Interface_Ipv6Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the Interface_Ipv6Neighbor struct, which is a YANG list entry.
func (t *Interface_Ipv6Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Address == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Address")
	}

	return map[string]interface{}{
		"ipv6-address": *t.Ipv6Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv6Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Interface_Ipv6Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Interface_Ipv6Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Interface_Ipv6Neighbor) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Interface_Ipv6Neighbor.
func (*Interface_Ipv6Neighbor) ΛBelongingModule() string {
	return "open-traffic-generator-discovery"
}

// IsisRouter represents the /open-traffic-generator-isis/isis-routers/isis-router YANG schema element.
type IsisRouter struct {
	Counters          *IsisRouter_Counters          `path:"state/counters" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	LinkStateDatabase *IsisRouter_LinkStateDatabase `path:"state/link-state-database" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Name              *string                       `path:"state/name|name" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"name" shadow-module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *IsisRouter) GetOrCreateCounters() *IsisRouter_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &IsisRouter_Counters{}
	return t.Counters
}

// GetOrCreateLinkStateDatabase retrieves the value of the LinkStateDatabase field
// or returns the existing field if it already exists.
func (t *IsisRouter) GetOrCreateLinkStateDatabase() *IsisRouter_LinkStateDatabase {
	if t.LinkStateDatabase != nil {
		return t.LinkStateDatabase
	}
	t.LinkStateDatabase = &IsisRouter_LinkStateDatabase{}
	return t.LinkStateDatabase
}

// GetCounters returns the value of the Counters struct pointer
// from IsisRouter. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter) GetCounters() *IsisRouter_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetLinkStateDatabase returns the value of the LinkStateDatabase struct pointer
// from IsisRouter. If the receiver or the field LinkStateDatabase is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter) GetLinkStateDatabase() *IsisRouter_LinkStateDatabase {
	if t != nil && t.LinkStateDatabase != nil {
		return t.LinkStateDatabase
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the IsisRouter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *IsisRouter) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
	t.LinkStateDatabase.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the IsisRouter struct, which is a YANG list entry.
func (t *IsisRouter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter.
func (*IsisRouter) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_Counters represents the /open-traffic-generator-isis/isis-routers/isis-router/state/counters YANG schema element.
type IsisRouter_Counters struct {
	Level1 *IsisRouter_Counters_Level1 `path:"level1" module:"open-traffic-generator-isis"`
	Level2 *IsisRouter_Counters_Level2 `path:"level2" module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_Counters) IsYANGGoStruct() {}

// GetOrCreateLevel1 retrieves the value of the Level1 field
// or returns the existing field if it already exists.
func (t *IsisRouter_Counters) GetOrCreateLevel1() *IsisRouter_Counters_Level1 {
	if t.Level1 != nil {
		return t.Level1
	}
	t.Level1 = &IsisRouter_Counters_Level1{}
	return t.Level1
}

// GetOrCreateLevel2 retrieves the value of the Level2 field
// or returns the existing field if it already exists.
func (t *IsisRouter_Counters) GetOrCreateLevel2() *IsisRouter_Counters_Level2 {
	if t.Level2 != nil {
		return t.Level2
	}
	t.Level2 = &IsisRouter_Counters_Level2{}
	return t.Level2
}

// GetLevel1 returns the value of the Level1 struct pointer
// from IsisRouter_Counters. If the receiver or the field Level1 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_Counters) GetLevel1() *IsisRouter_Counters_Level1 {
	if t != nil && t.Level1 != nil {
		return t.Level1
	}
	return nil
}

// GetLevel2 returns the value of the Level2 struct pointer
// from IsisRouter_Counters. If the receiver or the field Level2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_Counters) GetLevel2() *IsisRouter_Counters_Level2 {
	if t != nil && t.Level2 != nil {
		return t.Level2
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Level1.PopulateDefaults()
	t.Level2.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_Counters.
func (*IsisRouter_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_Counters_Level1 represents the /open-traffic-generator-isis/isis-routers/isis-router/state/counters/level1 YANG schema element.
type IsisRouter_Counters_Level1 struct {
	DatabaseSize   *uint64 `path:"database-size" module:"open-traffic-generator-isis"`
	InBcastHellos  *uint64 `path:"in-bcast-hellos" module:"open-traffic-generator-isis"`
	InCsnp         *uint64 `path:"in-csnp" module:"open-traffic-generator-isis"`
	InLsp          *uint64 `path:"in-lsp" module:"open-traffic-generator-isis"`
	InP2PHellos    *uint64 `path:"in-p2p-hellos" module:"open-traffic-generator-isis"`
	InPsnp         *uint64 `path:"in-psnp" module:"open-traffic-generator-isis"`
	OutBcastHellos *uint64 `path:"out-bcast-hellos" module:"open-traffic-generator-isis"`
	OutCsnp        *uint64 `path:"out-csnp" module:"open-traffic-generator-isis"`
	OutLsp         *uint64 `path:"out-lsp" module:"open-traffic-generator-isis"`
	OutP2PHellos   *uint64 `path:"out-p2p-hellos" module:"open-traffic-generator-isis"`
	OutPsnp        *uint64 `path:"out-psnp" module:"open-traffic-generator-isis"`
	SessionsFlap   *uint64 `path:"sessions-flap" module:"open-traffic-generator-isis"`
	SessionsUp     *uint64 `path:"sessions-up" module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_Counters_Level1 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_Counters_Level1) IsYANGGoStruct() {}

// GetDatabaseSize retrieves the value of the leaf DatabaseSize from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DatabaseSize is set, it can
// safely use t.GetDatabaseSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DatabaseSize == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetDatabaseSize() uint64 {
	if t == nil || t.DatabaseSize == nil {
		return 0
	}
	return *t.DatabaseSize
}

// GetInBcastHellos retrieves the value of the leaf InBcastHellos from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBcastHellos is set, it can
// safely use t.GetInBcastHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBcastHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetInBcastHellos() uint64 {
	if t == nil || t.InBcastHellos == nil {
		return 0
	}
	return *t.InBcastHellos
}

// GetInCsnp retrieves the value of the leaf InCsnp from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCsnp is set, it can
// safely use t.GetInCsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetInCsnp() uint64 {
	if t == nil || t.InCsnp == nil {
		return 0
	}
	return *t.InCsnp
}

// GetInLsp retrieves the value of the leaf InLsp from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InLsp is set, it can
// safely use t.GetInLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InLsp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetInLsp() uint64 {
	if t == nil || t.InLsp == nil {
		return 0
	}
	return *t.InLsp
}

// GetInP2PHellos retrieves the value of the leaf InP2PHellos from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InP2PHellos is set, it can
// safely use t.GetInP2PHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InP2PHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetInP2PHellos() uint64 {
	if t == nil || t.InP2PHellos == nil {
		return 0
	}
	return *t.InP2PHellos
}

// GetInPsnp retrieves the value of the leaf InPsnp from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPsnp is set, it can
// safely use t.GetInPsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetInPsnp() uint64 {
	if t == nil || t.InPsnp == nil {
		return 0
	}
	return *t.InPsnp
}

// GetOutBcastHellos retrieves the value of the leaf OutBcastHellos from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutBcastHellos is set, it can
// safely use t.GetOutBcastHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutBcastHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetOutBcastHellos() uint64 {
	if t == nil || t.OutBcastHellos == nil {
		return 0
	}
	return *t.OutBcastHellos
}

// GetOutCsnp retrieves the value of the leaf OutCsnp from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutCsnp is set, it can
// safely use t.GetOutCsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutCsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetOutCsnp() uint64 {
	if t == nil || t.OutCsnp == nil {
		return 0
	}
	return *t.OutCsnp
}

// GetOutLsp retrieves the value of the leaf OutLsp from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutLsp is set, it can
// safely use t.GetOutLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutLsp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetOutLsp() uint64 {
	if t == nil || t.OutLsp == nil {
		return 0
	}
	return *t.OutLsp
}

// GetOutP2PHellos retrieves the value of the leaf OutP2PHellos from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutP2PHellos is set, it can
// safely use t.GetOutP2PHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutP2PHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetOutP2PHellos() uint64 {
	if t == nil || t.OutP2PHellos == nil {
		return 0
	}
	return *t.OutP2PHellos
}

// GetOutPsnp retrieves the value of the leaf OutPsnp from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPsnp is set, it can
// safely use t.GetOutPsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetOutPsnp() uint64 {
	if t == nil || t.OutPsnp == nil {
		return 0
	}
	return *t.OutPsnp
}

// GetSessionsFlap retrieves the value of the leaf SessionsFlap from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionsFlap is set, it can
// safely use t.GetSessionsFlap() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionsFlap == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetSessionsFlap() uint64 {
	if t == nil || t.SessionsFlap == nil {
		return 0
	}
	return *t.SessionsFlap
}

// GetSessionsUp retrieves the value of the leaf SessionsUp from the IsisRouter_Counters_Level1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionsUp is set, it can
// safely use t.GetSessionsUp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionsUp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level1) GetSessionsUp() uint64 {
	if t == nil || t.SessionsUp == nil {
		return 0
	}
	return *t.SessionsUp
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_Counters_Level1
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_Counters_Level1) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_Counters_Level1) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_Counters_Level1"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_Counters_Level1) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_Counters_Level1) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_Counters_Level1.
func (*IsisRouter_Counters_Level1) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_Counters_Level2 represents the /open-traffic-generator-isis/isis-routers/isis-router/state/counters/level2 YANG schema element.
type IsisRouter_Counters_Level2 struct {
	DatabaseSize   *uint64 `path:"database-size" module:"open-traffic-generator-isis"`
	InBcastHellos  *uint64 `path:"in-bcast-hellos" module:"open-traffic-generator-isis"`
	InCsnp         *uint64 `path:"in-csnp" module:"open-traffic-generator-isis"`
	InLsp          *uint64 `path:"in-lsp" module:"open-traffic-generator-isis"`
	InP2PHellos    *uint64 `path:"in-p2p-hellos" module:"open-traffic-generator-isis"`
	InPsnp         *uint64 `path:"in-psnp" module:"open-traffic-generator-isis"`
	OutBcastHellos *uint64 `path:"out-bcast-hellos" module:"open-traffic-generator-isis"`
	OutCsnp        *uint64 `path:"out-csnp" module:"open-traffic-generator-isis"`
	OutLsp         *uint64 `path:"out-lsp" module:"open-traffic-generator-isis"`
	OutP2PHellos   *uint64 `path:"out-p2p-hellos" module:"open-traffic-generator-isis"`
	OutPsnp        *uint64 `path:"out-psnp" module:"open-traffic-generator-isis"`
	SessionsFlap   *uint64 `path:"sessions-flap" module:"open-traffic-generator-isis"`
	SessionsUp     *uint64 `path:"sessions-up" module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_Counters_Level2 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_Counters_Level2) IsYANGGoStruct() {}

// GetDatabaseSize retrieves the value of the leaf DatabaseSize from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DatabaseSize is set, it can
// safely use t.GetDatabaseSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DatabaseSize == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetDatabaseSize() uint64 {
	if t == nil || t.DatabaseSize == nil {
		return 0
	}
	return *t.DatabaseSize
}

// GetInBcastHellos retrieves the value of the leaf InBcastHellos from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InBcastHellos is set, it can
// safely use t.GetInBcastHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InBcastHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetInBcastHellos() uint64 {
	if t == nil || t.InBcastHellos == nil {
		return 0
	}
	return *t.InBcastHellos
}

// GetInCsnp retrieves the value of the leaf InCsnp from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InCsnp is set, it can
// safely use t.GetInCsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InCsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetInCsnp() uint64 {
	if t == nil || t.InCsnp == nil {
		return 0
	}
	return *t.InCsnp
}

// GetInLsp retrieves the value of the leaf InLsp from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InLsp is set, it can
// safely use t.GetInLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InLsp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetInLsp() uint64 {
	if t == nil || t.InLsp == nil {
		return 0
	}
	return *t.InLsp
}

// GetInP2PHellos retrieves the value of the leaf InP2PHellos from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InP2PHellos is set, it can
// safely use t.GetInP2PHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InP2PHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetInP2PHellos() uint64 {
	if t == nil || t.InP2PHellos == nil {
		return 0
	}
	return *t.InP2PHellos
}

// GetInPsnp retrieves the value of the leaf InPsnp from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPsnp is set, it can
// safely use t.GetInPsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetInPsnp() uint64 {
	if t == nil || t.InPsnp == nil {
		return 0
	}
	return *t.InPsnp
}

// GetOutBcastHellos retrieves the value of the leaf OutBcastHellos from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutBcastHellos is set, it can
// safely use t.GetOutBcastHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutBcastHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetOutBcastHellos() uint64 {
	if t == nil || t.OutBcastHellos == nil {
		return 0
	}
	return *t.OutBcastHellos
}

// GetOutCsnp retrieves the value of the leaf OutCsnp from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutCsnp is set, it can
// safely use t.GetOutCsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutCsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetOutCsnp() uint64 {
	if t == nil || t.OutCsnp == nil {
		return 0
	}
	return *t.OutCsnp
}

// GetOutLsp retrieves the value of the leaf OutLsp from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutLsp is set, it can
// safely use t.GetOutLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutLsp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetOutLsp() uint64 {
	if t == nil || t.OutLsp == nil {
		return 0
	}
	return *t.OutLsp
}

// GetOutP2PHellos retrieves the value of the leaf OutP2PHellos from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutP2PHellos is set, it can
// safely use t.GetOutP2PHellos() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutP2PHellos == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetOutP2PHellos() uint64 {
	if t == nil || t.OutP2PHellos == nil {
		return 0
	}
	return *t.OutP2PHellos
}

// GetOutPsnp retrieves the value of the leaf OutPsnp from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutPsnp is set, it can
// safely use t.GetOutPsnp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutPsnp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetOutPsnp() uint64 {
	if t == nil || t.OutPsnp == nil {
		return 0
	}
	return *t.OutPsnp
}

// GetSessionsFlap retrieves the value of the leaf SessionsFlap from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionsFlap is set, it can
// safely use t.GetSessionsFlap() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionsFlap == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetSessionsFlap() uint64 {
	if t == nil || t.SessionsFlap == nil {
		return 0
	}
	return *t.SessionsFlap
}

// GetSessionsUp retrieves the value of the leaf SessionsUp from the IsisRouter_Counters_Level2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SessionsUp is set, it can
// safely use t.GetSessionsUp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SessionsUp == nil' before retrieving the leaf's value.
func (t *IsisRouter_Counters_Level2) GetSessionsUp() uint64 {
	if t == nil || t.SessionsUp == nil {
		return 0
	}
	return *t.SessionsUp
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_Counters_Level2
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_Counters_Level2) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_Counters_Level2) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_Counters_Level2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_Counters_Level2) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_Counters_Level2) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_Counters_Level2.
func (*IsisRouter_Counters_Level2) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database YANG schema element.
type IsisRouter_LinkStateDatabase struct {
	Lsps map[string]*IsisRouter_LinkStateDatabase_Lsps `path:"lsp-states/lsps" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase) IsYANGGoStruct() {}

// NewLsps creates a new entry in the Lsps list of the
// IsisRouter_LinkStateDatabase struct. The keys of the list are populated from the input
// arguments.
func (t *IsisRouter_LinkStateDatabase) NewLsps(LspId string) (*IsisRouter_LinkStateDatabase_Lsps, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsps == nil {
		t.Lsps = make(map[string]*IsisRouter_LinkStateDatabase_Lsps)
	}

	key := LspId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lsps[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lsps", key)
	}

	t.Lsps[key] = &IsisRouter_LinkStateDatabase_Lsps{
		LspId: &LspId,
	}

	return t.Lsps[key], nil
}

// GetOrCreateLsps retrieves the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IsisRouter_LinkStateDatabase) GetOrCreateLsps(LspId string) *IsisRouter_LinkStateDatabase_Lsps {

	key := LspId

	if v, ok := t.Lsps[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLsps(LspId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLsps got unexpected error: %v", err))
	}
	return v
}

// GetLsps retrieves the value with the specified key from
// the Lsps map field of IsisRouter_LinkStateDatabase. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IsisRouter_LinkStateDatabase) GetLsps(LspId string) *IsisRouter_LinkStateDatabase_Lsps {

	if t == nil {
		return nil
	}

	key := LspId

	if lm, ok := t.Lsps[key]; ok {
		return lm
	}
	return nil
}

// DeleteLsps deletes the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase. If there is no such element, the function
// is a no-op.
func (t *IsisRouter_LinkStateDatabase) DeleteLsps(LspId string) {
	key := LspId

	delete(t.Lsps, key)
}

// AppendLsps appends the supplied IsisRouter_LinkStateDatabase_Lsps struct to the
// list Lsps of IsisRouter_LinkStateDatabase. If the key value(s) specified in
// the supplied IsisRouter_LinkStateDatabase_Lsps already exist in the list, an error is
// returned.
func (t *IsisRouter_LinkStateDatabase) AppendLsps(v *IsisRouter_LinkStateDatabase_Lsps) error {
	if v.LspId == nil {
		return fmt.Errorf("invalid nil key received for LspId")
	}

	key := *v.LspId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lsps == nil {
		t.Lsps = make(map[string]*IsisRouter_LinkStateDatabase_Lsps)
	}

	if _, ok := t.Lsps[key]; ok {
		return fmt.Errorf("duplicate key for list Lsps %v", key)
	}

	t.Lsps[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Lsps {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase.
func (*IsisRouter_LinkStateDatabase) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps struct {
	Flags             []E_Lsps_Flags                          `path:"state/flags" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	IsType            *uint8                                  `path:"state/is-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	LspId             *string                                 `path:"state/lsp-id|lsp-id" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"lsp-id" shadow-module:"open-traffic-generator-isis"`
	PduLength         *uint16                                 `path:"state/pdu-length" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	PduType           E_Lsps_PduType                          `path:"state/pdu-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	RemainingLifetime *uint16                                 `path:"state/remaining-lifetime" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	SequenceNumber    *uint32                                 `path:"state/sequence-number" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Tlvs              *IsisRouter_LinkStateDatabase_Lsps_Tlvs `path:"tlvs" module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps) IsYANGGoStruct() {}

// GetOrCreateTlvs retrieves the value of the Tlvs field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetOrCreateTlvs() *IsisRouter_LinkStateDatabase_Lsps_Tlvs {
	if t.Tlvs != nil {
		return t.Tlvs
	}
	t.Tlvs = &IsisRouter_LinkStateDatabase_Lsps_Tlvs{}
	return t.Tlvs
}

// GetTlvs returns the value of the Tlvs struct pointer
// from IsisRouter_LinkStateDatabase_Lsps. If the receiver or the field Tlvs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetTlvs() *IsisRouter_LinkStateDatabase_Lsps_Tlvs {
	if t != nil && t.Tlvs != nil {
		return t.Tlvs
	}
	return nil
}

// GetFlags retrieves the value of the leaf Flags from the IsisRouter_LinkStateDatabase_Lsps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetFlags() []E_Lsps_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// GetIsType retrieves the value of the leaf IsType from the IsisRouter_LinkStateDatabase_Lsps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsType is set, it can
// safely use t.GetIsType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetIsType() uint8 {
	if t == nil || t.IsType == nil {
		return 0
	}
	return *t.IsType
}

// GetLspId retrieves the value of the leaf LspId from the IsisRouter_LinkStateDatabase_Lsps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LspId is set, it can
// safely use t.GetLspId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LspId == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetLspId() string {
	if t == nil || t.LspId == nil {
		return ""
	}
	return *t.LspId
}

// GetPduLength retrieves the value of the leaf PduLength from the IsisRouter_LinkStateDatabase_Lsps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PduLength is set, it can
// safely use t.GetPduLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PduLength == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetPduLength() uint16 {
	if t == nil || t.PduLength == nil {
		return 0
	}
	return *t.PduLength
}

// GetPduType retrieves the value of the leaf PduType from the IsisRouter_LinkStateDatabase_Lsps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PduType is set, it can
// safely use t.GetPduType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PduType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetPduType() E_Lsps_PduType {
	if t == nil || t.PduType == 0 {
		return 0
	}
	return t.PduType
}

// GetRemainingLifetime retrieves the value of the leaf RemainingLifetime from the IsisRouter_LinkStateDatabase_Lsps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemainingLifetime is set, it can
// safely use t.GetRemainingLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemainingLifetime == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetRemainingLifetime() uint16 {
	if t == nil || t.RemainingLifetime == nil {
		return 0
	}
	return *t.RemainingLifetime
}

// GetSequenceNumber retrieves the value of the leaf SequenceNumber from the IsisRouter_LinkStateDatabase_Lsps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SequenceNumber is set, it can
// safely use t.GetSequenceNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SequenceNumber == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps) GetSequenceNumber() uint32 {
	if t == nil || t.SequenceNumber == nil {
		return 0
	}
	return *t.SequenceNumber
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Tlvs.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the IsisRouter_LinkStateDatabase_Lsps struct, which is a YANG list entry.
func (t *IsisRouter_LinkStateDatabase_Lsps) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LspId == nil {
		return nil, fmt.Errorf("nil value for key LspId")
	}

	return map[string]interface{}{
		"lsp-id": *t.LspId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps.
func (*IsisRouter_LinkStateDatabase_Lsps) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs struct {
	ExtendedIpv4Reachability *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability `path:"extended-ipv4-reachability" module:"open-traffic-generator-isis"`
	ExtendedIsReachability   *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability   `path:"extended-is-reachability" module:"open-traffic-generator-isis"`
	Hostnames                *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames                `path:"hostnames" module:"open-traffic-generator-isis"`
	Ipv4ExternalReachability *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability `path:"ipv4-external-reachability" module:"open-traffic-generator-isis"`
	Ipv4InternalReachability *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability `path:"ipv4-internal-reachability" module:"open-traffic-generator-isis"`
	Ipv6Reachability         *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability         `path:"ipv6-reachability" module:"open-traffic-generator-isis"`
	IsReachability           *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability           `path:"is-reachability" module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs) IsYANGGoStruct() {}

// GetOrCreateExtendedIpv4Reachability retrieves the value of the ExtendedIpv4Reachability field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetOrCreateExtendedIpv4Reachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability {
	if t.ExtendedIpv4Reachability != nil {
		return t.ExtendedIpv4Reachability
	}
	t.ExtendedIpv4Reachability = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability{}
	return t.ExtendedIpv4Reachability
}

// GetOrCreateExtendedIsReachability retrieves the value of the ExtendedIsReachability field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetOrCreateExtendedIsReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability {
	if t.ExtendedIsReachability != nil {
		return t.ExtendedIsReachability
	}
	t.ExtendedIsReachability = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability{}
	return t.ExtendedIsReachability
}

// GetOrCreateHostnames retrieves the value of the Hostnames field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetOrCreateHostnames() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames {
	if t.Hostnames != nil {
		return t.Hostnames
	}
	t.Hostnames = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames{}
	return t.Hostnames
}

// GetOrCreateIpv4ExternalReachability retrieves the value of the Ipv4ExternalReachability field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetOrCreateIpv4ExternalReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability {
	if t.Ipv4ExternalReachability != nil {
		return t.Ipv4ExternalReachability
	}
	t.Ipv4ExternalReachability = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability{}
	return t.Ipv4ExternalReachability
}

// GetOrCreateIpv4InternalReachability retrieves the value of the Ipv4InternalReachability field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetOrCreateIpv4InternalReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability {
	if t.Ipv4InternalReachability != nil {
		return t.Ipv4InternalReachability
	}
	t.Ipv4InternalReachability = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability{}
	return t.Ipv4InternalReachability
}

// GetOrCreateIpv6Reachability retrieves the value of the Ipv6Reachability field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetOrCreateIpv6Reachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability {
	if t.Ipv6Reachability != nil {
		return t.Ipv6Reachability
	}
	t.Ipv6Reachability = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability{}
	return t.Ipv6Reachability
}

// GetOrCreateIsReachability retrieves the value of the IsReachability field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetOrCreateIsReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability {
	if t.IsReachability != nil {
		return t.IsReachability
	}
	t.IsReachability = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability{}
	return t.IsReachability
}

// GetExtendedIpv4Reachability returns the value of the ExtendedIpv4Reachability struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs. If the receiver or the field ExtendedIpv4Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetExtendedIpv4Reachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability {
	if t != nil && t.ExtendedIpv4Reachability != nil {
		return t.ExtendedIpv4Reachability
	}
	return nil
}

// GetExtendedIsReachability returns the value of the ExtendedIsReachability struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs. If the receiver or the field ExtendedIsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetExtendedIsReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability {
	if t != nil && t.ExtendedIsReachability != nil {
		return t.ExtendedIsReachability
	}
	return nil
}

// GetHostnames returns the value of the Hostnames struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs. If the receiver or the field Hostnames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetHostnames() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames {
	if t != nil && t.Hostnames != nil {
		return t.Hostnames
	}
	return nil
}

// GetIpv4ExternalReachability returns the value of the Ipv4ExternalReachability struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs. If the receiver or the field Ipv4ExternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetIpv4ExternalReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability {
	if t != nil && t.Ipv4ExternalReachability != nil {
		return t.Ipv4ExternalReachability
	}
	return nil
}

// GetIpv4InternalReachability returns the value of the Ipv4InternalReachability struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs. If the receiver or the field Ipv4InternalReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetIpv4InternalReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability {
	if t != nil && t.Ipv4InternalReachability != nil {
		return t.Ipv4InternalReachability
	}
	return nil
}

// GetIpv6Reachability returns the value of the Ipv6Reachability struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs. If the receiver or the field Ipv6Reachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetIpv6Reachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability {
	if t != nil && t.Ipv6Reachability != nil {
		return t.Ipv6Reachability
	}
	return nil
}

// GetIsReachability returns the value of the IsReachability struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs. If the receiver or the field IsReachability is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) GetIsReachability() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability {
	if t != nil && t.IsReachability != nil {
		return t.IsReachability
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ExtendedIpv4Reachability.PopulateDefaults()
	t.ExtendedIsReachability.PopulateDefaults()
	t.Hostnames.PopulateDefaults()
	t.Ipv4ExternalReachability.PopulateDefaults()
	t.Ipv4InternalReachability.PopulateDefaults()
	t.Ipv6Reachability.PopulateDefaults()
	t.IsReachability.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/extended-ipv4-reachability YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability struct {
	Prefix map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix `path:"prefixes/prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) NewPrefix(Prefix string) (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) GetOrCreatePrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) GetPrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability. If there is no such element, the function
// is a no-op.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix struct to the
// list Prefix of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability. If the key value(s) specified in
// the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix already exist in the list, an error is
// returned.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) AppendPrefix(v *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/extended-ipv4-reachability/prefixes/prefix YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix struct {
	Metric             *uint32                                                                                  `path:"state/metric" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Prefix             *string                                                                                  `path:"state/prefix|prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"prefix" shadow-module:"open-traffic-generator-isis"`
	PrefixAttributes   *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes `path:"state/prefix-attributes" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	PrefixLength       *uint32                                                                                  `path:"state/prefix-length" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	RedistributionType E_ExtendedIpv4Reachability_Prefix_RedistributionType                                     `path:"state/redistribution-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) IsYANGGoStruct() {}

// GetOrCreatePrefixAttributes retrieves the value of the PrefixAttributes field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) GetOrCreatePrefixAttributes() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes {
	if t.PrefixAttributes != nil {
		return t.PrefixAttributes
	}
	t.PrefixAttributes = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes{}
	return t.PrefixAttributes
}

// GetPrefixAttributes returns the value of the PrefixAttributes struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix. If the receiver or the field PrefixAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) GetPrefixAttributes() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes {
	if t != nil && t.PrefixAttributes != nil {
		return t.PrefixAttributes
	}
	return nil
}

// GetMetric retrieves the value of the leaf Metric from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) GetMetric() uint32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetPrefix retrieves the value of the leaf Prefix from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) GetPrefixLength() uint32 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetRedistributionType retrieves the value of the leaf RedistributionType from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedistributionType is set, it can
// safely use t.GetRedistributionType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedistributionType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) GetRedistributionType() E_ExtendedIpv4Reachability_Prefix_RedistributionType {
	if t == nil || t.RedistributionType == 0 {
		return 0
	}
	return t.RedistributionType
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixAttributes.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix struct, which is a YANG list entry.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/extended-ipv4-reachability/prefixes/prefix/state/prefix-attributes YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes struct {
	Flags []E_State_Flags `path:"flags" module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes) IsYANGGoStruct() {
}

// GetFlags retrieves the value of the leaf Flags from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes) GetFlags() []E_State_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIpv4Reachability_Prefix_PrefixAttributes) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/extended-is-reachability YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability struct {
	Neighbor map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor `path:"neighbors/neighbor" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability struct. The keys of the list are populated from the input
// arguments.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) NewNeighbor(SystemId string) (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) GetOrCreateNeighbor(SystemId string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) GetNeighbor(SystemId string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability. If there is no such element, the function
// is a no-op.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) DeleteNeighbor(SystemId string) {
	key := SystemId

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor struct to the
// list Neighbor of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability. If the key value(s) specified in
// the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor already exist in the list, an error is
// returned.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) AppendNeighbor(v *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) error {
	if v.SystemId == nil {
		return fmt.Errorf("invalid nil key received for SystemId")
	}

	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/extended-is-reachability/neighbors/neighbor YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor struct {
	SystemId *string `path:"state/system-id|system-id" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"system-id" shadow-module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) IsYANGGoStruct() {}

// GetSystemId retrieves the value of the leaf SystemId from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor struct, which is a YANG list entry.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_ExtendedIsReachability_Neighbor) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/hostnames YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames struct {
	Hostname []string `path:"state/hostname" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames) IsYANGGoStruct() {}

// GetHostname retrieves the value of the leaf Hostname from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Hostname is set, it can
// safely use t.GetHostname() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Hostname == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames) GetHostname() []string {
	if t == nil || t.Hostname == nil {
		return nil
	}
	return t.Hostname
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Hostnames) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/ipv4-external-reachability YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability struct {
	Prefix map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix `path:"prefixes/prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability struct. The keys of the list are populated from the input
// arguments.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) NewPrefix(Prefix string) (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) GetOrCreatePrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) GetPrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability. If there is no such element, the function
// is a no-op.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix struct to the
// list Prefix of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability. If the key value(s) specified in
// the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix already exist in the list, an error is
// returned.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) AppendPrefix(v *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/ipv4-external-reachability/prefixes/prefix YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix struct {
	DefaultMetric      *uint8                                               `path:"state/default-metric" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	OriginType         E_Ipv4ExternalReachability_Prefix_OriginType         `path:"state/origin-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Prefix             *string                                              `path:"state/prefix|prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"prefix" shadow-module:"open-traffic-generator-isis"`
	PrefixLength       *uint32                                              `path:"state/prefix-length" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	RedistributionType E_Ipv4ExternalReachability_Prefix_RedistributionType `path:"state/redistribution-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) IsYANGGoStruct() {}

// GetDefaultMetric retrieves the value of the leaf DefaultMetric from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultMetric is set, it can
// safely use t.GetDefaultMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultMetric == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) GetDefaultMetric() uint8 {
	if t == nil || t.DefaultMetric == nil {
		return 0
	}
	return *t.DefaultMetric
}

// GetOriginType retrieves the value of the leaf OriginType from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginType is set, it can
// safely use t.GetOriginType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) GetOriginType() E_Ipv4ExternalReachability_Prefix_OriginType {
	if t == nil || t.OriginType == 0 {
		return 0
	}
	return t.OriginType
}

// GetPrefix retrieves the value of the leaf Prefix from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) GetPrefixLength() uint32 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetRedistributionType retrieves the value of the leaf RedistributionType from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedistributionType is set, it can
// safely use t.GetRedistributionType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedistributionType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) GetRedistributionType() E_Ipv4ExternalReachability_Prefix_RedistributionType {
	if t == nil || t.RedistributionType == 0 {
		return 0
	}
	return t.RedistributionType
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix struct, which is a YANG list entry.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4ExternalReachability_Prefix) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/ipv4-internal-reachability YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability struct {
	Prefix map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix `path:"prefixes/prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability struct. The keys of the list are populated from the input
// arguments.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) NewPrefix(Prefix string) (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) GetOrCreatePrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) GetPrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability. If there is no such element, the function
// is a no-op.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix struct to the
// list Prefix of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability. If the key value(s) specified in
// the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix already exist in the list, an error is
// returned.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) AppendPrefix(v *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/ipv4-internal-reachability/prefixes/prefix YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix struct {
	DefaultMetric      *uint8                                               `path:"state/default-metric" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	OriginType         E_Ipv4ExternalReachability_Prefix_OriginType         `path:"state/origin-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Prefix             *string                                              `path:"state/prefix|prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"prefix" shadow-module:"open-traffic-generator-isis"`
	PrefixLength       *uint32                                              `path:"state/prefix-length" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	RedistributionType E_Ipv4ExternalReachability_Prefix_RedistributionType `path:"state/redistribution-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) IsYANGGoStruct() {}

// GetDefaultMetric retrieves the value of the leaf DefaultMetric from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultMetric is set, it can
// safely use t.GetDefaultMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultMetric == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) GetDefaultMetric() uint8 {
	if t == nil || t.DefaultMetric == nil {
		return 0
	}
	return *t.DefaultMetric
}

// GetOriginType retrieves the value of the leaf OriginType from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginType is set, it can
// safely use t.GetOriginType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) GetOriginType() E_Ipv4ExternalReachability_Prefix_OriginType {
	if t == nil || t.OriginType == 0 {
		return 0
	}
	return t.OriginType
}

// GetPrefix retrieves the value of the leaf Prefix from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) GetPrefixLength() uint32 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetRedistributionType retrieves the value of the leaf RedistributionType from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedistributionType is set, it can
// safely use t.GetRedistributionType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedistributionType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) GetRedistributionType() E_Ipv4ExternalReachability_Prefix_RedistributionType {
	if t == nil || t.RedistributionType == 0 {
		return 0
	}
	return t.RedistributionType
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix struct, which is a YANG list entry.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv4InternalReachability_Prefix) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/ipv6-reachability YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability struct {
	Prefix map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix `path:"prefixes/prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability struct. The keys of the list are populated from the input
// arguments.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) NewPrefix(Prefix string) (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix)
	}

	key := Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix{
		Prefix: &Prefix,
	}

	return t.Prefix[key], nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) GetOrCreatePrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix {

	key := Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) GetPrefix(Prefix string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix {

	if t == nil {
		return nil
	}

	key := Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability. If there is no such element, the function
// is a no-op.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) DeletePrefix(Prefix string) {
	key := Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix struct to the
// list Prefix of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability. If the key value(s) specified in
// the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix already exist in the list, an error is
// returned.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) AppendPrefix(v *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) error {
	if v.Prefix == nil {
		return fmt.Errorf("invalid nil key received for Prefix")
	}

	key := *v.Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/ipv6-reachability/prefixes/prefix YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix struct {
	Metric             *uint32                                                                          `path:"state/metric" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	OriginType         E_Ipv6Reachability_Prefix_OriginType                                             `path:"state/origin-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Prefix             *string                                                                          `path:"state/prefix|prefix" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"prefix" shadow-module:"open-traffic-generator-isis"`
	PrefixAttributes   *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes `path:"state/prefix-attributes" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	PrefixLength       *uint32                                                                          `path:"state/prefix-length" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	RedistributionType E_Ipv6Reachability_Prefix_RedistributionType                                     `path:"state/redistribution-type" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) IsYANGGoStruct() {}

// GetOrCreatePrefixAttributes retrieves the value of the PrefixAttributes field
// or returns the existing field if it already exists.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) GetOrCreatePrefixAttributes() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes {
	if t.PrefixAttributes != nil {
		return t.PrefixAttributes
	}
	t.PrefixAttributes = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes{}
	return t.PrefixAttributes
}

// GetPrefixAttributes returns the value of the PrefixAttributes struct pointer
// from IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix. If the receiver or the field PrefixAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) GetPrefixAttributes() *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes {
	if t != nil && t.PrefixAttributes != nil {
		return t.PrefixAttributes
	}
	return nil
}

// GetMetric retrieves the value of the leaf Metric from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Metric is set, it can
// safely use t.GetMetric() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Metric == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) GetMetric() uint32 {
	if t == nil || t.Metric == nil {
		return 0
	}
	return *t.Metric
}

// GetOriginType retrieves the value of the leaf OriginType from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OriginType is set, it can
// safely use t.GetOriginType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OriginType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) GetOriginType() E_Ipv6Reachability_Prefix_OriginType {
	if t == nil || t.OriginType == 0 {
		return 0
	}
	return t.OriginType
}

// GetPrefix retrieves the value of the leaf Prefix from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// GetPrefixLength retrieves the value of the leaf PrefixLength from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixLength is set, it can
// safely use t.GetPrefixLength() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixLength == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) GetPrefixLength() uint32 {
	if t == nil || t.PrefixLength == nil {
		return 0
	}
	return *t.PrefixLength
}

// GetRedistributionType retrieves the value of the leaf RedistributionType from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedistributionType is set, it can
// safely use t.GetRedistributionType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedistributionType == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) GetRedistributionType() E_Ipv6Reachability_Prefix_RedistributionType {
	if t == nil || t.RedistributionType == 0 {
		return 0
	}
	return t.RedistributionType
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PrefixAttributes.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix struct, which is a YANG list entry.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Prefix == nil {
		return nil, fmt.Errorf("nil value for key Prefix")
	}

	return map[string]interface{}{
		"prefix": *t.Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/ipv6-reachability/prefixes/prefix/state/prefix-attributes YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes struct {
	Flags []E_State_Flags `path:"flags" module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes) IsYANGGoStruct() {
}

// GetFlags retrieves the value of the leaf Flags from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Flags is set, it can
// safely use t.GetFlags() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Flags == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes) GetFlags() []E_State_Flags {
	if t == nil || t.Flags == nil {
		return nil
	}
	return t.Flags
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_Ipv6Reachability_Prefix_PrefixAttributes) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/is-reachability YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability struct {
	Neighbor map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor `path:"neighbors/neighbor" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) IsYANGGoStruct() {}

// NewNeighbor creates a new entry in the Neighbor list of the
// IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability struct. The keys of the list are populated from the input
// arguments.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) NewNeighbor(SystemId string) (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor)
	}

	key := SystemId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Neighbor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Neighbor", key)
	}

	t.Neighbor[key] = &IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor{
		SystemId: &SystemId,
	}

	return t.Neighbor[key], nil
}

// GetOrCreateNeighbor retrieves the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) GetOrCreateNeighbor(SystemId string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor {

	key := SystemId

	if v, ok := t.Neighbor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighbor(SystemId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighbor got unexpected error: %v", err))
	}
	return v
}

// GetNeighbor retrieves the value with the specified key from
// the Neighbor map field of IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) GetNeighbor(SystemId string) *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor {

	if t == nil {
		return nil
	}

	key := SystemId

	if lm, ok := t.Neighbor[key]; ok {
		return lm
	}
	return nil
}

// DeleteNeighbor deletes the value with the specified keys from
// the receiver IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability. If there is no such element, the function
// is a no-op.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) DeleteNeighbor(SystemId string) {
	key := SystemId

	delete(t.Neighbor, key)
}

// AppendNeighbor appends the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor struct to the
// list Neighbor of IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability. If the key value(s) specified in
// the supplied IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor already exist in the list, an error is
// returned.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) AppendNeighbor(v *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) error {
	if v.SystemId == nil {
		return fmt.Errorf("invalid nil key received for SystemId")
	}

	key := *v.SystemId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Neighbor == nil {
		t.Neighbor = make(map[string]*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor)
	}

	if _, ok := t.Neighbor[key]; ok {
		return fmt.Errorf("duplicate key for list Neighbor %v", key)
	}

	t.Neighbor[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Neighbor {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor represents the /open-traffic-generator-isis/isis-routers/isis-router/state/link-state-database/lsp-states/lsps/tlvs/is-reachability/neighbors/neighbor YANG schema element.
type IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor struct {
	SystemId *string `path:"state/system-id|system-id" module:"open-traffic-generator-isis/open-traffic-generator-isis|open-traffic-generator-isis" shadow-path:"system-id" shadow-module:"open-traffic-generator-isis"`
}

// IsYANGGoStruct ensures that IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) IsYANGGoStruct() {}

// GetSystemId retrieves the value of the leaf SystemId from the IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// PopulateDefaults recursively populates unset leaf fields in the IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor struct, which is a YANG list entry.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.SystemId == nil {
		return nil, fmt.Errorf("nil value for key SystemId")
	}

	return map[string]interface{}{
		"system-id": *t.SystemId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor.
func (*IsisRouter_LinkStateDatabase_Lsps_Tlvs_IsReachability_Neighbor) ΛBelongingModule() string {
	return "open-traffic-generator-isis"
}

// Lacp represents the /open-traffic-generator-lacp/lacp YANG schema element.
type Lacp struct {
	LagMember map[string]*Lacp_LagMember `path:"lag-members/lag-member" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
}

// IsYANGGoStruct ensures that Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp) IsYANGGoStruct() {}

// NewLagMember creates a new entry in the LagMember list of the
// Lacp struct. The keys of the list are populated from the input
// arguments.
func (t *Lacp) NewLagMember(Name string) (*Lacp_LagMember, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LagMember == nil {
		t.LagMember = make(map[string]*Lacp_LagMember)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LagMember[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LagMember", key)
	}

	t.LagMember[key] = &Lacp_LagMember{
		Name: &Name,
	}

	return t.LagMember[key], nil
}

// GetOrCreateLagMember retrieves the value with the specified keys from
// the receiver Lacp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Lacp) GetOrCreateLagMember(Name string) *Lacp_LagMember {

	key := Name

	if v, ok := t.LagMember[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLagMember(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLagMember got unexpected error: %v", err))
	}
	return v
}

// GetLagMember retrieves the value with the specified key from
// the LagMember map field of Lacp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Lacp) GetLagMember(Name string) *Lacp_LagMember {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.LagMember[key]; ok {
		return lm
	}
	return nil
}

// DeleteLagMember deletes the value with the specified keys from
// the receiver Lacp. If there is no such element, the function
// is a no-op.
func (t *Lacp) DeleteLagMember(Name string) {
	key := Name

	delete(t.LagMember, key)
}

// AppendLagMember appends the supplied Lacp_LagMember struct to the
// list LagMember of Lacp. If the key value(s) specified in
// the supplied Lacp_LagMember already exist in the list, an error is
// returned.
func (t *Lacp) AppendLagMember(v *Lacp_LagMember) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LagMember == nil {
		t.LagMember = make(map[string]*Lacp_LagMember)
	}

	if _, ok := t.LagMember[key]; ok {
		return fmt.Errorf("duplicate key for list LagMember %v", key)
	}

	t.LagMember[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.LagMember {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp.
func (*Lacp) ΛBelongingModule() string {
	return "open-traffic-generator-lacp"
}

// Lacp_LagMember represents the /open-traffic-generator-lacp/lacp/lag-members/lag-member YANG schema element.
type Lacp_LagMember struct {
	Activity        E_Lacp_LacpActivityType        `path:"state/activity" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	Aggregatable    *bool                          `path:"state/aggregatable" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	Collecting      *bool                          `path:"state/collecting" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	Counters        *Lacp_LagMember_Counters       `path:"state/counters" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	Distributing    *bool                          `path:"state/distributing" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	Name            *string                        `path:"state/name|name" module:"open-traffic-generator-lacp/open-traffic-generator-lacp|open-traffic-generator-lacp" shadow-path:"name" shadow-module:"open-traffic-generator-lacp"`
	OperKey         *uint16                        `path:"state/oper-key" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	PartnerId       *string                        `path:"state/partner-id" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	PartnerKey      *uint16                        `path:"state/partner-key" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	PartnerPortNum  *uint16                        `path:"state/partner-port-num" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	PortNum         *uint16                        `path:"state/port-num" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	Synchronization E_Lacp_LacpSynchronizationType `path:"state/synchronization" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	SystemId        *string                        `path:"state/system-id" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
	Timeout         E_Lacp_LacpTimeoutType         `path:"state/timeout" module:"open-traffic-generator-lacp/open-traffic-generator-lacp"`
}

// IsYANGGoStruct ensures that Lacp_LagMember implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_LagMember) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lacp_LagMember) GetOrCreateCounters() *Lacp_LagMember_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lacp_LagMember_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lacp_LagMember. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lacp_LagMember) GetCounters() *Lacp_LagMember_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetActivity retrieves the value of the leaf Activity from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Activity is set, it can
// safely use t.GetActivity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Activity == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetActivity() E_Lacp_LacpActivityType {
	if t == nil || t.Activity == 0 {
		return 0
	}
	return t.Activity
}

// GetAggregatable retrieves the value of the leaf Aggregatable from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Aggregatable is set, it can
// safely use t.GetAggregatable() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Aggregatable == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetAggregatable() bool {
	if t == nil || t.Aggregatable == nil {
		return false
	}
	return *t.Aggregatable
}

// GetCollecting retrieves the value of the leaf Collecting from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Collecting is set, it can
// safely use t.GetCollecting() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Collecting == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetCollecting() bool {
	if t == nil || t.Collecting == nil {
		return false
	}
	return *t.Collecting
}

// GetDistributing retrieves the value of the leaf Distributing from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Distributing is set, it can
// safely use t.GetDistributing() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Distributing == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetDistributing() bool {
	if t == nil || t.Distributing == nil {
		return false
	}
	return *t.Distributing
}

// GetName retrieves the value of the leaf Name from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperKey retrieves the value of the leaf OperKey from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperKey is set, it can
// safely use t.GetOperKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperKey == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetOperKey() uint16 {
	if t == nil || t.OperKey == nil {
		return 0
	}
	return *t.OperKey
}

// GetPartnerId retrieves the value of the leaf PartnerId from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerId is set, it can
// safely use t.GetPartnerId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerId == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetPartnerId() string {
	if t == nil || t.PartnerId == nil {
		return ""
	}
	return *t.PartnerId
}

// GetPartnerKey retrieves the value of the leaf PartnerKey from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerKey is set, it can
// safely use t.GetPartnerKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerKey == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetPartnerKey() uint16 {
	if t == nil || t.PartnerKey == nil {
		return 0
	}
	return *t.PartnerKey
}

// GetPartnerPortNum retrieves the value of the leaf PartnerPortNum from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PartnerPortNum is set, it can
// safely use t.GetPartnerPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PartnerPortNum == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetPartnerPortNum() uint16 {
	if t == nil || t.PartnerPortNum == nil {
		return 0
	}
	return *t.PartnerPortNum
}

// GetPortNum retrieves the value of the leaf PortNum from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortNum is set, it can
// safely use t.GetPortNum() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortNum == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetPortNum() uint16 {
	if t == nil || t.PortNum == nil {
		return 0
	}
	return *t.PortNum
}

// GetSynchronization retrieves the value of the leaf Synchronization from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Synchronization is set, it can
// safely use t.GetSynchronization() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Synchronization == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetSynchronization() E_Lacp_LacpSynchronizationType {
	if t == nil || t.Synchronization == 0 {
		return 0
	}
	return t.Synchronization
}

// GetSystemId retrieves the value of the leaf SystemId from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return ""
	}
	return *t.SystemId
}

// GetTimeout retrieves the value of the leaf Timeout from the Lacp_LagMember
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember) GetTimeout() E_Lacp_LacpTimeoutType {
	if t == nil || t.Timeout == 0 {
		return 0
	}
	return t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_LagMember
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_LagMember) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Lacp_LagMember struct, which is a YANG list entry.
func (t *Lacp_LagMember) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_LagMember) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_LagMember"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_LagMember) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_LagMember) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_LagMember.
func (*Lacp_LagMember) ΛBelongingModule() string {
	return "open-traffic-generator-lacp"
}

// Lacp_LagMember_Counters represents the /open-traffic-generator-lacp/lacp/lag-members/lag-member/state/counters YANG schema element.
type Lacp_LagMember_Counters struct {
	LacpInPkts   *uint64 `path:"lacp-in-pkts" module:"open-traffic-generator-lacp"`
	LacpOutPkts  *uint64 `path:"lacp-out-pkts" module:"open-traffic-generator-lacp"`
	LacpRxErrors *uint64 `path:"lacp-rx-errors" module:"open-traffic-generator-lacp"`
}

// IsYANGGoStruct ensures that Lacp_LagMember_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lacp_LagMember_Counters) IsYANGGoStruct() {}

// GetLacpInPkts retrieves the value of the leaf LacpInPkts from the Lacp_LagMember_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpInPkts is set, it can
// safely use t.GetLacpInPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpInPkts == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember_Counters) GetLacpInPkts() uint64 {
	if t == nil || t.LacpInPkts == nil {
		return 0
	}
	return *t.LacpInPkts
}

// GetLacpOutPkts retrieves the value of the leaf LacpOutPkts from the Lacp_LagMember_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpOutPkts is set, it can
// safely use t.GetLacpOutPkts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpOutPkts == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember_Counters) GetLacpOutPkts() uint64 {
	if t == nil || t.LacpOutPkts == nil {
		return 0
	}
	return *t.LacpOutPkts
}

// GetLacpRxErrors retrieves the value of the leaf LacpRxErrors from the Lacp_LagMember_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpRxErrors is set, it can
// safely use t.GetLacpRxErrors() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpRxErrors == nil' before retrieving the leaf's value.
func (t *Lacp_LagMember_Counters) GetLacpRxErrors() uint64 {
	if t == nil || t.LacpRxErrors == nil {
		return 0
	}
	return *t.LacpRxErrors
}

// PopulateDefaults recursively populates unset leaf fields in the Lacp_LagMember_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lacp_LagMember_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_LagMember_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lacp_LagMember_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lacp_LagMember_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lacp_LagMember_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lacp_LagMember_Counters.
func (*Lacp_LagMember_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-lacp"
}

// Lag represents the /open-traffic-generator-lag/lags/lag YANG schema element.
type Lag struct {
	Counters   *Lag_Counters    `path:"state/counters" module:"open-traffic-generator-lag/open-traffic-generator-lag"`
	InRate     Binary           `path:"state/in-rate" module:"open-traffic-generator-lag/open-traffic-generator-lag"`
	Name       *string          `path:"state/name|name" module:"open-traffic-generator-lag/open-traffic-generator-lag|open-traffic-generator-lag" shadow-path:"name" shadow-module:"open-traffic-generator-lag"`
	OperStatus E_Lag_OperStatus `path:"state/oper-status" module:"open-traffic-generator-lag/open-traffic-generator-lag"`
	OutRate    Binary           `path:"state/out-rate" module:"open-traffic-generator-lag/open-traffic-generator-lag"`
}

// IsYANGGoStruct ensures that Lag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lag) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Lag) GetOrCreateCounters() *Lag_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Lag_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Lag. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Lag) GetCounters() *Lag_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInRate retrieves the value of the leaf InRate from the Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRate is set, it can
// safely use t.GetInRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRate == nil' before retrieving the leaf's value.
func (t *Lag) GetInRate() Binary {
	if t == nil || t.InRate == nil {
		return nil
	}
	return t.InRate
}

// GetName retrieves the value of the leaf Name from the Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Lag) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOperStatus retrieves the value of the leaf OperStatus from the Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperStatus is set, it can
// safely use t.GetOperStatus() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperStatus == nil' before retrieving the leaf's value.
func (t *Lag) GetOperStatus() E_Lag_OperStatus {
	if t == nil || t.OperStatus == 0 {
		return 0
	}
	return t.OperStatus
}

// GetOutRate retrieves the value of the leaf OutRate from the Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRate is set, it can
// safely use t.GetOutRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRate == nil' before retrieving the leaf's value.
func (t *Lag) GetOutRate() Binary {
	if t == nil || t.OutRate == nil {
		return nil
	}
	return t.OutRate
}

// PopulateDefaults recursively populates unset leaf fields in the Lag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Lag struct, which is a YANG list entry.
func (t *Lag) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lag) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lag) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lag.
func (*Lag) ΛBelongingModule() string {
	return "open-traffic-generator-lag"
}

// Lag_Counters represents the /open-traffic-generator-lag/lags/lag/state/counters YANG schema element.
type Lag_Counters struct {
	InFrames      *uint64 `path:"in-frames" module:"open-traffic-generator-lag"`
	InOctets      *uint64 `path:"in-octets" module:"open-traffic-generator-lag"`
	MemberPortsUp *uint64 `path:"member-ports-up" module:"open-traffic-generator-lag"`
	OutFrames     *uint64 `path:"out-frames" module:"open-traffic-generator-lag"`
	OutOctets     *uint64 `path:"out-octets" module:"open-traffic-generator-lag"`
}

// IsYANGGoStruct ensures that Lag_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Lag_Counters) IsYANGGoStruct() {}

// GetInFrames retrieves the value of the leaf InFrames from the Lag_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFrames is set, it can
// safely use t.GetInFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFrames == nil' before retrieving the leaf's value.
func (t *Lag_Counters) GetInFrames() uint64 {
	if t == nil || t.InFrames == nil {
		return 0
	}
	return *t.InFrames
}

// GetInOctets retrieves the value of the leaf InOctets from the Lag_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Lag_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetMemberPortsUp retrieves the value of the leaf MemberPortsUp from the Lag_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MemberPortsUp is set, it can
// safely use t.GetMemberPortsUp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MemberPortsUp == nil' before retrieving the leaf's value.
func (t *Lag_Counters) GetMemberPortsUp() uint64 {
	if t == nil || t.MemberPortsUp == nil {
		return 0
	}
	return *t.MemberPortsUp
}

// GetOutFrames retrieves the value of the leaf OutFrames from the Lag_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutFrames is set, it can
// safely use t.GetOutFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutFrames == nil' before retrieving the leaf's value.
func (t *Lag_Counters) GetOutFrames() uint64 {
	if t == nil || t.OutFrames == nil {
		return 0
	}
	return *t.OutFrames
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Lag_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Lag_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// PopulateDefaults recursively populates unset leaf fields in the Lag_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Lag_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lag_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Lag_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Lag_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Lag_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Lag_Counters.
func (*Lag_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-lag"
}

// Port represents the /open-traffic-generator-port/ports/port YANG schema element.
type Port struct {
	Counters *Port_Counters `path:"state/counters" module:"open-traffic-generator-port/open-traffic-generator-port"`
	InRate   Binary         `path:"state/in-rate" module:"open-traffic-generator-port/open-traffic-generator-port"`
	Link     E_Port_Link    `path:"state/link" module:"open-traffic-generator-port/open-traffic-generator-port"`
	Name     *string        `path:"state/name|name" module:"open-traffic-generator-port/open-traffic-generator-port|open-traffic-generator-port" shadow-path:"name" shadow-module:"open-traffic-generator-port"`
	OutRate  Binary         `path:"state/out-rate" module:"open-traffic-generator-port/open-traffic-generator-port"`
}

// IsYANGGoStruct ensures that Port implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Port) IsYANGGoStruct() {}

// GetOrCreateCounters retrieves the value of the Counters field
// or returns the existing field if it already exists.
func (t *Port) GetOrCreateCounters() *Port_Counters {
	if t.Counters != nil {
		return t.Counters
	}
	t.Counters = &Port_Counters{}
	return t.Counters
}

// GetCounters returns the value of the Counters struct pointer
// from Port. If the receiver or the field Counters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Port) GetCounters() *Port_Counters {
	if t != nil && t.Counters != nil {
		return t.Counters
	}
	return nil
}

// GetInRate retrieves the value of the leaf InRate from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InRate is set, it can
// safely use t.GetInRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InRate == nil' before retrieving the leaf's value.
func (t *Port) GetInRate() Binary {
	if t == nil || t.InRate == nil {
		return nil
	}
	return t.InRate
}

// GetLink retrieves the value of the leaf Link from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Link is set, it can
// safely use t.GetLink() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Link == nil' before retrieving the leaf's value.
func (t *Port) GetLink() E_Port_Link {
	if t == nil || t.Link == 0 {
		return 0
	}
	return t.Link
}

// GetName retrieves the value of the leaf Name from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *Port) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOutRate retrieves the value of the leaf OutRate from the Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutRate is set, it can
// safely use t.GetOutRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutRate == nil' before retrieving the leaf's value.
func (t *Port) GetOutRate() Binary {
	if t == nil || t.OutRate == nil {
		return nil
	}
	return t.OutRate
}

// PopulateDefaults recursively populates unset leaf fields in the Port
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Port) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Counters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the Port struct, which is a YANG list entry.
func (t *Port) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Port) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Port.
func (*Port) ΛBelongingModule() string {
	return "open-traffic-generator-port"
}

// Port_Counters represents the /open-traffic-generator-port/ports/port/state/counters YANG schema element.
type Port_Counters struct {
	InFrames  *uint64 `path:"in-frames" module:"open-traffic-generator-port"`
	InOctets  *uint64 `path:"in-octets" module:"open-traffic-generator-port"`
	OutFrames *uint64 `path:"out-frames" module:"open-traffic-generator-port"`
	OutOctets *uint64 `path:"out-octets" module:"open-traffic-generator-port"`
}

// IsYANGGoStruct ensures that Port_Counters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Port_Counters) IsYANGGoStruct() {}

// GetInFrames retrieves the value of the leaf InFrames from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InFrames is set, it can
// safely use t.GetInFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InFrames == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetInFrames() uint64 {
	if t == nil || t.InFrames == nil {
		return 0
	}
	return *t.InFrames
}

// GetInOctets retrieves the value of the leaf InOctets from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InOctets is set, it can
// safely use t.GetInOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InOctets == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetInOctets() uint64 {
	if t == nil || t.InOctets == nil {
		return 0
	}
	return *t.InOctets
}

// GetOutFrames retrieves the value of the leaf OutFrames from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutFrames is set, it can
// safely use t.GetOutFrames() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutFrames == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetOutFrames() uint64 {
	if t == nil || t.OutFrames == nil {
		return 0
	}
	return *t.OutFrames
}

// GetOutOctets retrieves the value of the leaf OutOctets from the Port_Counters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutOctets is set, it can
// safely use t.GetOutOctets() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutOctets == nil' before retrieving the leaf's value.
func (t *Port_Counters) GetOutOctets() uint64 {
	if t == nil || t.OutOctets == nil {
		return 0
	}
	return *t.OutOctets
}

// PopulateDefaults recursively populates unset leaf fields in the Port_Counters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Port_Counters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port_Counters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Port_Counters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Port_Counters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Port_Counters) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Port_Counters.
func (*Port_Counters) ΛBelongingModule() string {
	return "open-traffic-generator-port"
}

// Root represents the /root YANG schema element.
type Root struct {
	BgpPeer    map[string]*BgpPeer    `path:"bgp-peers/bgp-peer" module:"open-traffic-generator-bgp/open-traffic-generator-bgp"`
	Flow       map[string]*Flow       `path:"flows/flow" module:"open-traffic-generator-flow/open-traffic-generator-flow"`
	Interface  map[string]*Interface  `path:"interfaces/interface" module:"open-traffic-generator-discovery/open-traffic-generator-discovery"`
	IsisRouter map[string]*IsisRouter `path:"isis-routers/isis-router" module:"open-traffic-generator-isis/open-traffic-generator-isis"`
	Lacp       *Lacp                  `path:"lacp" module:"open-traffic-generator-lacp"`
	Lag        map[string]*Lag        `path:"lags/lag" module:"open-traffic-generator-lag/open-traffic-generator-lag"`
	Port       map[string]*Port       `path:"ports/port" module:"open-traffic-generator-port/open-traffic-generator-port"`
}

// IsYANGGoStruct ensures that Root implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Root) IsYANGGoStruct() {}

// NewBgpPeer creates a new entry in the BgpPeer list of the
// Root struct. The keys of the list are populated from the input
// arguments.
func (t *Root) NewBgpPeer(Name string) (*BgpPeer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeer == nil {
		t.BgpPeer = make(map[string]*BgpPeer)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BgpPeer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BgpPeer", key)
	}

	t.BgpPeer[key] = &BgpPeer{
		Name: &Name,
	}

	return t.BgpPeer[key], nil
}

// GetOrCreateBgpPeer retrieves the value with the specified keys from
// the receiver Root. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Root) GetOrCreateBgpPeer(Name string) *BgpPeer {

	key := Name

	if v, ok := t.BgpPeer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBgpPeer(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBgpPeer got unexpected error: %v", err))
	}
	return v
}

// GetBgpPeer retrieves the value with the specified key from
// the BgpPeer map field of Root. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Root) GetBgpPeer(Name string) *BgpPeer {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.BgpPeer[key]; ok {
		return lm
	}
	return nil
}

// DeleteBgpPeer deletes the value with the specified keys from
// the receiver Root. If there is no such element, the function
// is a no-op.
func (t *Root) DeleteBgpPeer(Name string) {
	key := Name

	delete(t.BgpPeer, key)
}

// AppendBgpPeer appends the supplied BgpPeer struct to the
// list BgpPeer of Root. If the key value(s) specified in
// the supplied BgpPeer already exist in the list, an error is
// returned.
func (t *Root) AppendBgpPeer(v *BgpPeer) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeer == nil {
		t.BgpPeer = make(map[string]*BgpPeer)
	}

	if _, ok := t.BgpPeer[key]; ok {
		return fmt.Errorf("duplicate key for list BgpPeer %v", key)
	}

	t.BgpPeer[key] = v
	return nil
}

// NewFlow creates a new entry in the Flow list of the
// Root struct. The keys of the list are populated from the input
// arguments.
func (t *Root) NewFlow(Name string) (*Flow, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flow == nil {
		t.Flow = make(map[string]*Flow)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Flow[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Flow", key)
	}

	t.Flow[key] = &Flow{
		Name: &Name,
	}

	return t.Flow[key], nil
}

// GetOrCreateFlow retrieves the value with the specified keys from
// the receiver Root. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Root) GetOrCreateFlow(Name string) *Flow {

	key := Name

	if v, ok := t.Flow[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFlow(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFlow got unexpected error: %v", err))
	}
	return v
}

// GetFlow retrieves the value with the specified key from
// the Flow map field of Root. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Root) GetFlow(Name string) *Flow {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Flow[key]; ok {
		return lm
	}
	return nil
}

// DeleteFlow deletes the value with the specified keys from
// the receiver Root. If there is no such element, the function
// is a no-op.
func (t *Root) DeleteFlow(Name string) {
	key := Name

	delete(t.Flow, key)
}

// AppendFlow appends the supplied Flow struct to the
// list Flow of Root. If the key value(s) specified in
// the supplied Flow already exist in the list, an error is
// returned.
func (t *Root) AppendFlow(v *Flow) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flow == nil {
		t.Flow = make(map[string]*Flow)
	}

	if _, ok := t.Flow[key]; ok {
		return fmt.Errorf("duplicate key for list Flow %v", key)
	}

	t.Flow[key] = v
	return nil
}

// NewInterface creates a new entry in the Interface list of the
// Root struct. The keys of the list are populated from the input
// arguments.
func (t *Root) NewInterface(Name string) (*Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Root. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Root) GetOrCreateInterface(Name string) *Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Root. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Root) GetInterface(Name string) *Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver Root. If there is no such element, the function
// is a no-op.
func (t *Root) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied Interface struct to the
// list Interface of Root. If the key value(s) specified in
// the supplied Interface already exist in the list, an error is
// returned.
func (t *Root) AppendInterface(v *Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// NewIsisRouter creates a new entry in the IsisRouter list of the
// Root struct. The keys of the list are populated from the input
// arguments.
func (t *Root) NewIsisRouter(Name string) (*IsisRouter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IsisRouter == nil {
		t.IsisRouter = make(map[string]*IsisRouter)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IsisRouter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IsisRouter", key)
	}

	t.IsisRouter[key] = &IsisRouter{
		Name: &Name,
	}

	return t.IsisRouter[key], nil
}

// GetOrCreateIsisRouter retrieves the value with the specified keys from
// the receiver Root. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Root) GetOrCreateIsisRouter(Name string) *IsisRouter {

	key := Name

	if v, ok := t.IsisRouter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIsisRouter(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIsisRouter got unexpected error: %v", err))
	}
	return v
}

// GetIsisRouter retrieves the value with the specified key from
// the IsisRouter map field of Root. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Root) GetIsisRouter(Name string) *IsisRouter {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.IsisRouter[key]; ok {
		return lm
	}
	return nil
}

// DeleteIsisRouter deletes the value with the specified keys from
// the receiver Root. If there is no such element, the function
// is a no-op.
func (t *Root) DeleteIsisRouter(Name string) {
	key := Name

	delete(t.IsisRouter, key)
}

// AppendIsisRouter appends the supplied IsisRouter struct to the
// list IsisRouter of Root. If the key value(s) specified in
// the supplied IsisRouter already exist in the list, an error is
// returned.
func (t *Root) AppendIsisRouter(v *IsisRouter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IsisRouter == nil {
		t.IsisRouter = make(map[string]*IsisRouter)
	}

	if _, ok := t.IsisRouter[key]; ok {
		return fmt.Errorf("duplicate key for list IsisRouter %v", key)
	}

	t.IsisRouter[key] = v
	return nil
}

// NewLag creates a new entry in the Lag list of the
// Root struct. The keys of the list are populated from the input
// arguments.
func (t *Root) NewLag(Name string) (*Lag, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lag == nil {
		t.Lag = make(map[string]*Lag)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lag[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lag", key)
	}

	t.Lag[key] = &Lag{
		Name: &Name,
	}

	return t.Lag[key], nil
}

// GetOrCreateLag retrieves the value with the specified keys from
// the receiver Root. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Root) GetOrCreateLag(Name string) *Lag {

	key := Name

	if v, ok := t.Lag[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLag(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLag got unexpected error: %v", err))
	}
	return v
}

// GetLag retrieves the value with the specified key from
// the Lag map field of Root. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Root) GetLag(Name string) *Lag {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Lag[key]; ok {
		return lm
	}
	return nil
}

// DeleteLag deletes the value with the specified keys from
// the receiver Root. If there is no such element, the function
// is a no-op.
func (t *Root) DeleteLag(Name string) {
	key := Name

	delete(t.Lag, key)
}

// AppendLag appends the supplied Lag struct to the
// list Lag of Root. If the key value(s) specified in
// the supplied Lag already exist in the list, an error is
// returned.
func (t *Root) AppendLag(v *Lag) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lag == nil {
		t.Lag = make(map[string]*Lag)
	}

	if _, ok := t.Lag[key]; ok {
		return fmt.Errorf("duplicate key for list Lag %v", key)
	}

	t.Lag[key] = v
	return nil
}

// NewPort creates a new entry in the Port list of the
// Root struct. The keys of the list are populated from the input
// arguments.
func (t *Root) NewPort(Name string) (*Port, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*Port)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Port[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Port", key)
	}

	t.Port[key] = &Port{
		Name: &Name,
	}

	return t.Port[key], nil
}

// GetOrCreatePort retrieves the value with the specified keys from
// the receiver Root. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Root) GetOrCreatePort(Name string) *Port {

	key := Name

	if v, ok := t.Port[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPort(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePort got unexpected error: %v", err))
	}
	return v
}

// GetPort retrieves the value with the specified key from
// the Port map field of Root. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Root) GetPort(Name string) *Port {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Port[key]; ok {
		return lm
	}
	return nil
}

// DeletePort deletes the value with the specified keys from
// the receiver Root. If there is no such element, the function
// is a no-op.
func (t *Root) DeletePort(Name string) {
	key := Name

	delete(t.Port, key)
}

// AppendPort appends the supplied Port struct to the
// list Port of Root. If the key value(s) specified in
// the supplied Port already exist in the list, an error is
// returned.
func (t *Root) AppendPort(v *Port) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*Port)
	}

	if _, ok := t.Port[key]; ok {
		return fmt.Errorf("duplicate key for list Port %v", key)
	}

	t.Port[key] = v
	return nil
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *Root) GetOrCreateLacp() *Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &Lacp{}
	return t.Lacp
}

// GetLacp returns the value of the Lacp struct pointer
// from Root. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Root) GetLacp() *Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the Root
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *Root) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Lacp.PopulateDefaults()
	for _, e := range t.BgpPeer {
		e.PopulateDefaults()
	}
	for _, e := range t.Flow {
		e.PopulateDefaults()
	}
	for _, e := range t.Interface {
		e.PopulateDefaults()
	}
	for _, e := range t.IsisRouter {
		e.PopulateDefaults()
	}
	for _, e := range t.Lag {
		e.PopulateDefaults()
	}
	for _, e := range t.Port {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Root) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Root"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Root) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Root) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Root.
func (*Root) ΛBelongingModule() string {
	return ""
}
