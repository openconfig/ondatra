// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: ate.proto

package proto

import (
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"

	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BgpAsnSetMode int32

const (
	BgpAsnSetMode_ASN_SET_MODE_UNSPECIFIED          BgpAsnSetMode = 0
	BgpAsnSetMode_ASN_SET_MODE_DO_NOT_INCLUDE       BgpAsnSetMode = 1
	BgpAsnSetMode_ASN_SET_MODE_AS_SEQ               BgpAsnSetMode = 2
	BgpAsnSetMode_ASN_SET_MODE_AS_SET               BgpAsnSetMode = 3
	BgpAsnSetMode_ASN_SET_MODE_AS_SEQ_CONFEDERATION BgpAsnSetMode = 4
	BgpAsnSetMode_ASN_SET_MODE_AS_SET_CONFEDERATION BgpAsnSetMode = 5
	BgpAsnSetMode_ASN_SET_MODE_PREPEND              BgpAsnSetMode = 6
)

// Enum value maps for BgpAsnSetMode.
var (
	BgpAsnSetMode_name = map[int32]string{
		0: "ASN_SET_MODE_UNSPECIFIED",
		1: "ASN_SET_MODE_DO_NOT_INCLUDE",
		2: "ASN_SET_MODE_AS_SEQ",
		3: "ASN_SET_MODE_AS_SET",
		4: "ASN_SET_MODE_AS_SEQ_CONFEDERATION",
		5: "ASN_SET_MODE_AS_SET_CONFEDERATION",
		6: "ASN_SET_MODE_PREPEND",
	}
	BgpAsnSetMode_value = map[string]int32{
		"ASN_SET_MODE_UNSPECIFIED":          0,
		"ASN_SET_MODE_DO_NOT_INCLUDE":       1,
		"ASN_SET_MODE_AS_SEQ":               2,
		"ASN_SET_MODE_AS_SET":               3,
		"ASN_SET_MODE_AS_SEQ_CONFEDERATION": 4,
		"ASN_SET_MODE_AS_SET_CONFEDERATION": 5,
		"ASN_SET_MODE_PREPEND":              6,
	}
)

func (x BgpAsnSetMode) Enum() *BgpAsnSetMode {
	p := new(BgpAsnSetMode)
	*p = x
	return p
}

func (x BgpAsnSetMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BgpAsnSetMode) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[0].Descriptor()
}

func (BgpAsnSetMode) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[0]
}

func (x BgpAsnSetMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BgpAsnSetMode.Descriptor instead.
func (BgpAsnSetMode) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{0}
}

type MacSec_CipherSuite int32

const (
	MacSec_CIPHER_SUITE_UNSPECIFIED MacSec_CipherSuite = 0
	MacSec_AES_128                  MacSec_CipherSuite = 1
	MacSec_AES_256                  MacSec_CipherSuite = 2
	MacSec_AES_XPN_128              MacSec_CipherSuite = 3
	MacSec_AES_XPN_256              MacSec_CipherSuite = 4
)

// Enum value maps for MacSec_CipherSuite.
var (
	MacSec_CipherSuite_name = map[int32]string{
		0: "CIPHER_SUITE_UNSPECIFIED",
		1: "AES_128",
		2: "AES_256",
		3: "AES_XPN_128",
		4: "AES_XPN_256",
	}
	MacSec_CipherSuite_value = map[string]int32{
		"CIPHER_SUITE_UNSPECIFIED": 0,
		"AES_128":                  1,
		"AES_256":                  2,
		"AES_XPN_128":              3,
		"AES_XPN_256":              4,
	}
)

func (x MacSec_CipherSuite) Enum() *MacSec_CipherSuite {
	p := new(MacSec_CipherSuite)
	*p = x
	return p
}

func (x MacSec_CipherSuite) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MacSec_CipherSuite) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[1].Descriptor()
}

func (MacSec_CipherSuite) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[1]
}

func (x MacSec_CipherSuite) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MacSec_CipherSuite.Descriptor instead.
func (MacSec_CipherSuite) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{5, 0}
}

type MacSec_MKA_Capability int32

const (
	MacSec_MKA_CAPABILITY_UNSPECIFIED                   MacSec_MKA_Capability = 0
	MacSec_MKA_NOT_IMPLEMENTED                          MacSec_MKA_Capability = 1
	MacSec_MKA_INTEGRITY_WITHOUT_CONFIDENTIALITY        MacSec_MKA_Capability = 2
	MacSec_MKA_INTEGRITY_WITH_NO_CONFIDENTIALITY_OFFSET MacSec_MKA_Capability = 3
	MacSec_MKA_INTEGRITY_WITH_CONFIDENTIALITY_OFFSET    MacSec_MKA_Capability = 4
)

// Enum value maps for MacSec_MKA_Capability.
var (
	MacSec_MKA_Capability_name = map[int32]string{
		0: "CAPABILITY_UNSPECIFIED",
		1: "NOT_IMPLEMENTED",
		2: "INTEGRITY_WITHOUT_CONFIDENTIALITY",
		3: "INTEGRITY_WITH_NO_CONFIDENTIALITY_OFFSET",
		4: "INTEGRITY_WITH_CONFIDENTIALITY_OFFSET",
	}
	MacSec_MKA_Capability_value = map[string]int32{
		"CAPABILITY_UNSPECIFIED":                   0,
		"NOT_IMPLEMENTED":                          1,
		"INTEGRITY_WITHOUT_CONFIDENTIALITY":        2,
		"INTEGRITY_WITH_NO_CONFIDENTIALITY_OFFSET": 3,
		"INTEGRITY_WITH_CONFIDENTIALITY_OFFSET":    4,
	}
)

func (x MacSec_MKA_Capability) Enum() *MacSec_MKA_Capability {
	p := new(MacSec_MKA_Capability)
	*p = x
	return p
}

func (x MacSec_MKA_Capability) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MacSec_MKA_Capability) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[2].Descriptor()
}

func (MacSec_MKA_Capability) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[2]
}

func (x MacSec_MKA_Capability) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MacSec_MKA_Capability.Descriptor instead.
func (MacSec_MKA_Capability) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{5, 0, 0}
}

type MacSec_MKA_ConfidentialityOffset int32

const (
	MacSec_MKA_OFFSET_UNSPECIFIED        MacSec_MKA_ConfidentialityOffset = 0
	MacSec_MKA_OFFSET_NO_CONFIDENTIALITY MacSec_MKA_ConfidentialityOffset = 4
	MacSec_MKA_OFFSET_0                  MacSec_MKA_ConfidentialityOffset = 1
	MacSec_MKA_OFFSET_30                 MacSec_MKA_ConfidentialityOffset = 2
	MacSec_MKA_OFFSET_50                 MacSec_MKA_ConfidentialityOffset = 3
)

// Enum value maps for MacSec_MKA_ConfidentialityOffset.
var (
	MacSec_MKA_ConfidentialityOffset_name = map[int32]string{
		0: "OFFSET_UNSPECIFIED",
		4: "OFFSET_NO_CONFIDENTIALITY",
		1: "OFFSET_0",
		2: "OFFSET_30",
		3: "OFFSET_50",
	}
	MacSec_MKA_ConfidentialityOffset_value = map[string]int32{
		"OFFSET_UNSPECIFIED":        0,
		"OFFSET_NO_CONFIDENTIALITY": 4,
		"OFFSET_0":                  1,
		"OFFSET_30":                 2,
		"OFFSET_50":                 3,
	}
)

func (x MacSec_MKA_ConfidentialityOffset) Enum() *MacSec_MKA_ConfidentialityOffset {
	p := new(MacSec_MKA_ConfidentialityOffset)
	*p = x
	return p
}

func (x MacSec_MKA_ConfidentialityOffset) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MacSec_MKA_ConfidentialityOffset) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[3].Descriptor()
}

func (MacSec_MKA_ConfidentialityOffset) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[3]
}

func (x MacSec_MKA_ConfidentialityOffset) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MacSec_MKA_ConfidentialityOffset.Descriptor instead.
func (MacSec_MKA_ConfidentialityOffset) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{5, 0, 1}
}

type MacSec_MKA_KeyDerivationFunction int32

const (
	MacSec_MKA_KEY_DERIVATION_UNSPECIFIED MacSec_MKA_KeyDerivationFunction = 0
	MacSec_MKA_AES_128_CMAC               MacSec_MKA_KeyDerivationFunction = 1
	MacSec_MKA_AES_256_CMAC               MacSec_MKA_KeyDerivationFunction = 2
)

// Enum value maps for MacSec_MKA_KeyDerivationFunction.
var (
	MacSec_MKA_KeyDerivationFunction_name = map[int32]string{
		0: "KEY_DERIVATION_UNSPECIFIED",
		1: "AES_128_CMAC",
		2: "AES_256_CMAC",
	}
	MacSec_MKA_KeyDerivationFunction_value = map[string]int32{
		"KEY_DERIVATION_UNSPECIFIED": 0,
		"AES_128_CMAC":               1,
		"AES_256_CMAC":               2,
	}
)

func (x MacSec_MKA_KeyDerivationFunction) Enum() *MacSec_MKA_KeyDerivationFunction {
	p := new(MacSec_MKA_KeyDerivationFunction)
	*p = x
	return p
}

func (x MacSec_MKA_KeyDerivationFunction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MacSec_MKA_KeyDerivationFunction) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[4].Descriptor()
}

func (MacSec_MKA_KeyDerivationFunction) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[4]
}

func (x MacSec_MKA_KeyDerivationFunction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MacSec_MKA_KeyDerivationFunction.Descriptor instead.
func (MacSec_MKA_KeyDerivationFunction) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{5, 0, 2}
}

type ISISConfig_Level int32

const (
	ISISConfig_LEVEL_UNSPECIFIED ISISConfig_Level = 0
	ISISConfig_L1                ISISConfig_Level = 1
	ISISConfig_L2                ISISConfig_Level = 2
	ISISConfig_L1L2              ISISConfig_Level = 3
)

// Enum value maps for ISISConfig_Level.
var (
	ISISConfig_Level_name = map[int32]string{
		0: "LEVEL_UNSPECIFIED",
		1: "L1",
		2: "L2",
		3: "L1L2",
	}
	ISISConfig_Level_value = map[string]int32{
		"LEVEL_UNSPECIFIED": 0,
		"L1":                1,
		"L2":                2,
		"L1L2":              3,
	}
)

func (x ISISConfig_Level) Enum() *ISISConfig_Level {
	p := new(ISISConfig_Level)
	*p = x
	return p
}

func (x ISISConfig_Level) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ISISConfig_Level) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[5].Descriptor()
}

func (ISISConfig_Level) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[5]
}

func (x ISISConfig_Level) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ISISConfig_Level.Descriptor instead.
func (ISISConfig_Level) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{8, 0}
}

type ISISConfig_NetworkType int32

const (
	ISISConfig_NETWORK_TYPE_UNSPECIFIED ISISConfig_NetworkType = 0
	ISISConfig_BROADCAST                ISISConfig_NetworkType = 1
	ISISConfig_POINT_TO_POINT           ISISConfig_NetworkType = 2
)

// Enum value maps for ISISConfig_NetworkType.
var (
	ISISConfig_NetworkType_name = map[int32]string{
		0: "NETWORK_TYPE_UNSPECIFIED",
		1: "BROADCAST",
		2: "POINT_TO_POINT",
	}
	ISISConfig_NetworkType_value = map[string]int32{
		"NETWORK_TYPE_UNSPECIFIED": 0,
		"BROADCAST":                1,
		"POINT_TO_POINT":           2,
	}
)

func (x ISISConfig_NetworkType) Enum() *ISISConfig_NetworkType {
	p := new(ISISConfig_NetworkType)
	*p = x
	return p
}

func (x ISISConfig_NetworkType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ISISConfig_NetworkType) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[6].Descriptor()
}

func (ISISConfig_NetworkType) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[6]
}

func (x ISISConfig_NetworkType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ISISConfig_NetworkType.Descriptor instead.
func (ISISConfig_NetworkType) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{8, 1}
}

type ISISConfig_AuthType int32

const (
	ISISConfig_AUTH_TYPE_UNSPECIFIED ISISConfig_AuthType = 0
	ISISConfig_MD5                   ISISConfig_AuthType = 1
	ISISConfig_PASSWORD              ISISConfig_AuthType = 2
)

// Enum value maps for ISISConfig_AuthType.
var (
	ISISConfig_AuthType_name = map[int32]string{
		0: "AUTH_TYPE_UNSPECIFIED",
		1: "MD5",
		2: "PASSWORD",
	}
	ISISConfig_AuthType_value = map[string]int32{
		"AUTH_TYPE_UNSPECIFIED": 0,
		"MD5":                   1,
		"PASSWORD":              2,
	}
)

func (x ISISConfig_AuthType) Enum() *ISISConfig_AuthType {
	p := new(ISISConfig_AuthType)
	*p = x
	return p
}

func (x ISISConfig_AuthType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ISISConfig_AuthType) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[7].Descriptor()
}

func (ISISConfig_AuthType) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[7]
}

func (x ISISConfig_AuthType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ISISConfig_AuthType.Descriptor instead.
func (ISISConfig_AuthType) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{8, 2}
}

type IPReachability_RouteOrigin int32

const (
	IPReachability_ROUTE_ORIGIN_UNSPECIFIED IPReachability_RouteOrigin = 0
	IPReachability_INTERNAL                 IPReachability_RouteOrigin = 1
	IPReachability_EXTERNAL                 IPReachability_RouteOrigin = 2
)

// Enum value maps for IPReachability_RouteOrigin.
var (
	IPReachability_RouteOrigin_name = map[int32]string{
		0: "ROUTE_ORIGIN_UNSPECIFIED",
		1: "INTERNAL",
		2: "EXTERNAL",
	}
	IPReachability_RouteOrigin_value = map[string]int32{
		"ROUTE_ORIGIN_UNSPECIFIED": 0,
		"INTERNAL":                 1,
		"EXTERNAL":                 2,
	}
)

func (x IPReachability_RouteOrigin) Enum() *IPReachability_RouteOrigin {
	p := new(IPReachability_RouteOrigin)
	*p = x
	return p
}

func (x IPReachability_RouteOrigin) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IPReachability_RouteOrigin) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[8].Descriptor()
}

func (IPReachability_RouteOrigin) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[8]
}

func (x IPReachability_RouteOrigin) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IPReachability_RouteOrigin.Descriptor instead.
func (IPReachability_RouteOrigin) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{10, 0}
}

type BgpPeer_Type int32

const (
	BgpPeer_TYPE_UNSPECIFIED BgpPeer_Type = 0
	BgpPeer_TYPE_EXTERNAL    BgpPeer_Type = 1
	BgpPeer_TYPE_INTERNAL    BgpPeer_Type = 2
)

// Enum value maps for BgpPeer_Type.
var (
	BgpPeer_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "TYPE_EXTERNAL",
		2: "TYPE_INTERNAL",
	}
	BgpPeer_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED": 0,
		"TYPE_EXTERNAL":    1,
		"TYPE_INTERNAL":    2,
	}
)

func (x BgpPeer_Type) Enum() *BgpPeer_Type {
	p := new(BgpPeer_Type)
	*p = x
	return p
}

func (x BgpPeer_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BgpPeer_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[9].Descriptor()
}

func (BgpPeer_Type) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[9]
}

func (x BgpPeer_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BgpPeer_Type.Descriptor instead.
func (BgpPeer_Type) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 0}
}

type BgpAttributes_Origin int32

const (
	BgpAttributes_ORIGIN_UNSPECIFIED BgpAttributes_Origin = 0
	BgpAttributes_ORIGIN_IGP         BgpAttributes_Origin = 1
	BgpAttributes_ORIGIN_EGP         BgpAttributes_Origin = 2
	BgpAttributes_ORIGIN_INCOMPLETE  BgpAttributes_Origin = 3
)

// Enum value maps for BgpAttributes_Origin.
var (
	BgpAttributes_Origin_name = map[int32]string{
		0: "ORIGIN_UNSPECIFIED",
		1: "ORIGIN_IGP",
		2: "ORIGIN_EGP",
		3: "ORIGIN_INCOMPLETE",
	}
	BgpAttributes_Origin_value = map[string]int32{
		"ORIGIN_UNSPECIFIED": 0,
		"ORIGIN_IGP":         1,
		"ORIGIN_EGP":         2,
		"ORIGIN_INCOMPLETE":  3,
	}
)

func (x BgpAttributes_Origin) Enum() *BgpAttributes_Origin {
	p := new(BgpAttributes_Origin)
	*p = x
	return p
}

func (x BgpAttributes_Origin) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BgpAttributes_Origin) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[10].Descriptor()
}

func (BgpAttributes_Origin) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[10]
}

func (x BgpAttributes_Origin) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BgpAttributes_Origin.Descriptor instead.
func (BgpAttributes_Origin) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15, 0}
}

type BgpAttributes_AdvertisementProtocol int32

const (
	BgpAttributes_ADVERTISEMENT_PROTOCOL_UNSPECIFIED   BgpAttributes_AdvertisementProtocol = 0
	BgpAttributes_ADVERTISEMENT_PROTOCOL_V4            BgpAttributes_AdvertisementProtocol = 1
	BgpAttributes_ADVERTISEMENT_PROTOCOL_V6            BgpAttributes_AdvertisementProtocol = 2
	BgpAttributes_ADVERTISEMENT_PROTOCOL_V4_AND_V6     BgpAttributes_AdvertisementProtocol = 3
	BgpAttributes_ADVERTISEMENT_PROTOCOL_SAME_AS_ROUTE BgpAttributes_AdvertisementProtocol = 4
)

// Enum value maps for BgpAttributes_AdvertisementProtocol.
var (
	BgpAttributes_AdvertisementProtocol_name = map[int32]string{
		0: "ADVERTISEMENT_PROTOCOL_UNSPECIFIED",
		1: "ADVERTISEMENT_PROTOCOL_V4",
		2: "ADVERTISEMENT_PROTOCOL_V6",
		3: "ADVERTISEMENT_PROTOCOL_V4_AND_V6",
		4: "ADVERTISEMENT_PROTOCOL_SAME_AS_ROUTE",
	}
	BgpAttributes_AdvertisementProtocol_value = map[string]int32{
		"ADVERTISEMENT_PROTOCOL_UNSPECIFIED":   0,
		"ADVERTISEMENT_PROTOCOL_V4":            1,
		"ADVERTISEMENT_PROTOCOL_V6":            2,
		"ADVERTISEMENT_PROTOCOL_V4_AND_V6":     3,
		"ADVERTISEMENT_PROTOCOL_SAME_AS_ROUTE": 4,
	}
)

func (x BgpAttributes_AdvertisementProtocol) Enum() *BgpAttributes_AdvertisementProtocol {
	p := new(BgpAttributes_AdvertisementProtocol)
	*p = x
	return p
}

func (x BgpAttributes_AdvertisementProtocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BgpAttributes_AdvertisementProtocol) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[11].Descriptor()
}

func (BgpAttributes_AdvertisementProtocol) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[11]
}

func (x BgpAttributes_AdvertisementProtocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BgpAttributes_AdvertisementProtocol.Descriptor instead.
func (BgpAttributes_AdvertisementProtocol) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15, 1}
}

type BgpAttributes_ExtendedCommunity_Color_CoBits int32

const (
	BgpAttributes_ExtendedCommunity_Color_CO_BITS_UNSPECIFIED BgpAttributes_ExtendedCommunity_Color_CoBits = 0
	BgpAttributes_ExtendedCommunity_Color_CO_BITS_00          BgpAttributes_ExtendedCommunity_Color_CoBits = 1
	BgpAttributes_ExtendedCommunity_Color_CO_BITS_01          BgpAttributes_ExtendedCommunity_Color_CoBits = 2
	BgpAttributes_ExtendedCommunity_Color_CO_BITS_10          BgpAttributes_ExtendedCommunity_Color_CoBits = 3
	BgpAttributes_ExtendedCommunity_Color_CO_BITS_11          BgpAttributes_ExtendedCommunity_Color_CoBits = 4
)

// Enum value maps for BgpAttributes_ExtendedCommunity_Color_CoBits.
var (
	BgpAttributes_ExtendedCommunity_Color_CoBits_name = map[int32]string{
		0: "CO_BITS_UNSPECIFIED",
		1: "CO_BITS_00",
		2: "CO_BITS_01",
		3: "CO_BITS_10",
		4: "CO_BITS_11",
	}
	BgpAttributes_ExtendedCommunity_Color_CoBits_value = map[string]int32{
		"CO_BITS_UNSPECIFIED": 0,
		"CO_BITS_00":          1,
		"CO_BITS_01":          2,
		"CO_BITS_10":          3,
		"CO_BITS_11":          4,
	}
)

func (x BgpAttributes_ExtendedCommunity_Color_CoBits) Enum() *BgpAttributes_ExtendedCommunity_Color_CoBits {
	p := new(BgpAttributes_ExtendedCommunity_Color_CoBits)
	*p = x
	return p
}

func (x BgpAttributes_ExtendedCommunity_Color_CoBits) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BgpAttributes_ExtendedCommunity_Color_CoBits) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[12].Descriptor()
}

func (BgpAttributes_ExtendedCommunity_Color_CoBits) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[12]
}

func (x BgpAttributes_ExtendedCommunity_Color_CoBits) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BgpAttributes_ExtendedCommunity_Color_CoBits.Descriptor instead.
func (BgpAttributes_ExtendedCommunity_Color_CoBits) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15, 0, 0, 0}
}

type BgpAttributes_AsPathSegment_Type int32

const (
	BgpAttributes_AsPathSegment_TYPE_UNSPECIFIED          BgpAttributes_AsPathSegment_Type = 0
	BgpAttributes_AsPathSegment_TYPE_AS_SEQ               BgpAttributes_AsPathSegment_Type = 1
	BgpAttributes_AsPathSegment_TYPE_AS_SET               BgpAttributes_AsPathSegment_Type = 2
	BgpAttributes_AsPathSegment_TYPE_AS_SEQ_CONFEDERATION BgpAttributes_AsPathSegment_Type = 3
	BgpAttributes_AsPathSegment_TYPE_AS_SET_CONFEDERATION BgpAttributes_AsPathSegment_Type = 4
)

// Enum value maps for BgpAttributes_AsPathSegment_Type.
var (
	BgpAttributes_AsPathSegment_Type_name = map[int32]string{
		0: "TYPE_UNSPECIFIED",
		1: "TYPE_AS_SEQ",
		2: "TYPE_AS_SET",
		3: "TYPE_AS_SEQ_CONFEDERATION",
		4: "TYPE_AS_SET_CONFEDERATION",
	}
	BgpAttributes_AsPathSegment_Type_value = map[string]int32{
		"TYPE_UNSPECIFIED":          0,
		"TYPE_AS_SEQ":               1,
		"TYPE_AS_SET":               2,
		"TYPE_AS_SEQ_CONFEDERATION": 3,
		"TYPE_AS_SET_CONFEDERATION": 4,
	}
)

func (x BgpAttributes_AsPathSegment_Type) Enum() *BgpAttributes_AsPathSegment_Type {
	p := new(BgpAttributes_AsPathSegment_Type)
	*p = x
	return p
}

func (x BgpAttributes_AsPathSegment_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BgpAttributes_AsPathSegment_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[13].Descriptor()
}

func (BgpAttributes_AsPathSegment_Type) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[13]
}

func (x BgpAttributes_AsPathSegment_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BgpAttributes_AsPathSegment_Type.Descriptor instead.
func (BgpAttributes_AsPathSegment_Type) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15, 1, 0}
}

type Network_ImportedBgpRoutes_RouteTableFormat int32

const (
	Network_ImportedBgpRoutes_ROUTE_TABLE_FORMAT_UNSPECIFIED Network_ImportedBgpRoutes_RouteTableFormat = 0
	Network_ImportedBgpRoutes_ROUTE_TABLE_FORMAT_CISCO       Network_ImportedBgpRoutes_RouteTableFormat = 1
	Network_ImportedBgpRoutes_ROUTE_TABLE_FORMAT_JUNIPER     Network_ImportedBgpRoutes_RouteTableFormat = 2
	Network_ImportedBgpRoutes_ROUTE_TABLE_FORMAT_CSV         Network_ImportedBgpRoutes_RouteTableFormat = 3
)

// Enum value maps for Network_ImportedBgpRoutes_RouteTableFormat.
var (
	Network_ImportedBgpRoutes_RouteTableFormat_name = map[int32]string{
		0: "ROUTE_TABLE_FORMAT_UNSPECIFIED",
		1: "ROUTE_TABLE_FORMAT_CISCO",
		2: "ROUTE_TABLE_FORMAT_JUNIPER",
		3: "ROUTE_TABLE_FORMAT_CSV",
	}
	Network_ImportedBgpRoutes_RouteTableFormat_value = map[string]int32{
		"ROUTE_TABLE_FORMAT_UNSPECIFIED": 0,
		"ROUTE_TABLE_FORMAT_CISCO":       1,
		"ROUTE_TABLE_FORMAT_JUNIPER":     2,
		"ROUTE_TABLE_FORMAT_CSV":         3,
	}
)

func (x Network_ImportedBgpRoutes_RouteTableFormat) Enum() *Network_ImportedBgpRoutes_RouteTableFormat {
	p := new(Network_ImportedBgpRoutes_RouteTableFormat)
	*p = x
	return p
}

func (x Network_ImportedBgpRoutes_RouteTableFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Network_ImportedBgpRoutes_RouteTableFormat) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[14].Descriptor()
}

func (Network_ImportedBgpRoutes_RouteTableFormat) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[14]
}

func (x Network_ImportedBgpRoutes_RouteTableFormat) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Network_ImportedBgpRoutes_RouteTableFormat.Descriptor instead.
func (Network_ImportedBgpRoutes_RouteTableFormat) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{19, 0, 0}
}

type FrameSize_ImixPreset int32

const (
	FrameSize_IMIX_UNKNOWN       FrameSize_ImixPreset = 0
	FrameSize_IMIX_CISCO         FrameSize_ImixPreset = 1
	FrameSize_IMIX_DEFAULT       FrameSize_ImixPreset = 2
	FrameSize_IMIX_IPSEC         FrameSize_ImixPreset = 3
	FrameSize_IMIX_IPV6          FrameSize_ImixPreset = 4
	FrameSize_IMIX_RPR_QUADMODAL FrameSize_ImixPreset = 5
	FrameSize_IMIX_RPR_TRIMODAL  FrameSize_ImixPreset = 6
	FrameSize_IMIX_STANDARD      FrameSize_ImixPreset = 7
	FrameSize_IMIX_TCP           FrameSize_ImixPreset = 8
	FrameSize_IMIX_TOLLY         FrameSize_ImixPreset = 9
)

// Enum value maps for FrameSize_ImixPreset.
var (
	FrameSize_ImixPreset_name = map[int32]string{
		0: "IMIX_UNKNOWN",
		1: "IMIX_CISCO",
		2: "IMIX_DEFAULT",
		3: "IMIX_IPSEC",
		4: "IMIX_IPV6",
		5: "IMIX_RPR_QUADMODAL",
		6: "IMIX_RPR_TRIMODAL",
		7: "IMIX_STANDARD",
		8: "IMIX_TCP",
		9: "IMIX_TOLLY",
	}
	FrameSize_ImixPreset_value = map[string]int32{
		"IMIX_UNKNOWN":       0,
		"IMIX_CISCO":         1,
		"IMIX_DEFAULT":       2,
		"IMIX_IPSEC":         3,
		"IMIX_IPV6":          4,
		"IMIX_RPR_QUADMODAL": 5,
		"IMIX_RPR_TRIMODAL":  6,
		"IMIX_STANDARD":      7,
		"IMIX_TCP":           8,
		"IMIX_TOLLY":         9,
	}
)

func (x FrameSize_ImixPreset) Enum() *FrameSize_ImixPreset {
	p := new(FrameSize_ImixPreset)
	*p = x
	return p
}

func (x FrameSize_ImixPreset) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FrameSize_ImixPreset) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[15].Descriptor()
}

func (FrameSize_ImixPreset) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[15]
}

func (x FrameSize_ImixPreset) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FrameSize_ImixPreset.Descriptor instead.
func (FrameSize_ImixPreset) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{24, 0}
}

type Transmission_Pattern int32

const (
	Transmission_PATTERN_UNSPECIFIED Transmission_Pattern = 0
	Transmission_CONTINUOUS          Transmission_Pattern = 1
	Transmission_BURST               Transmission_Pattern = 2
	Transmission_FIXED_FRAME_COUNT   Transmission_Pattern = 3
	Transmission_FIXED_DURATION      Transmission_Pattern = 4
)

// Enum value maps for Transmission_Pattern.
var (
	Transmission_Pattern_name = map[int32]string{
		0: "PATTERN_UNSPECIFIED",
		1: "CONTINUOUS",
		2: "BURST",
		3: "FIXED_FRAME_COUNT",
		4: "FIXED_DURATION",
	}
	Transmission_Pattern_value = map[string]int32{
		"PATTERN_UNSPECIFIED": 0,
		"CONTINUOUS":          1,
		"BURST":               2,
		"FIXED_FRAME_COUNT":   3,
		"FIXED_DURATION":      4,
	}
)

func (x Transmission_Pattern) Enum() *Transmission_Pattern {
	p := new(Transmission_Pattern)
	*p = x
	return p
}

func (x Transmission_Pattern) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Transmission_Pattern) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[16].Descriptor()
}

func (Transmission_Pattern) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[16]
}

func (x Transmission_Pattern) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Transmission_Pattern.Descriptor instead.
func (Transmission_Pattern) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{25, 0}
}

type IcmpHeader_DestinationUnreachable_Code int32

const (
	IcmpHeader_DestinationUnreachable_CODE_UNSPECIFIED       IcmpHeader_DestinationUnreachable_Code = 0
	IcmpHeader_DestinationUnreachable_NETWORK_UNREACHABLE    IcmpHeader_DestinationUnreachable_Code = 1
	IcmpHeader_DestinationUnreachable_HOST_UNREACHABLE       IcmpHeader_DestinationUnreachable_Code = 2
	IcmpHeader_DestinationUnreachable_PROTOCOL_UNREACHABLE   IcmpHeader_DestinationUnreachable_Code = 3
	IcmpHeader_DestinationUnreachable_PORT_UNREACHABLE       IcmpHeader_DestinationUnreachable_Code = 4
	IcmpHeader_DestinationUnreachable_FRAGMENTATION_REQUIRED IcmpHeader_DestinationUnreachable_Code = 5
	IcmpHeader_DestinationUnreachable_SOURCE_ROUTE_FAILED    IcmpHeader_DestinationUnreachable_Code = 6
)

// Enum value maps for IcmpHeader_DestinationUnreachable_Code.
var (
	IcmpHeader_DestinationUnreachable_Code_name = map[int32]string{
		0: "CODE_UNSPECIFIED",
		1: "NETWORK_UNREACHABLE",
		2: "HOST_UNREACHABLE",
		3: "PROTOCOL_UNREACHABLE",
		4: "PORT_UNREACHABLE",
		5: "FRAGMENTATION_REQUIRED",
		6: "SOURCE_ROUTE_FAILED",
	}
	IcmpHeader_DestinationUnreachable_Code_value = map[string]int32{
		"CODE_UNSPECIFIED":       0,
		"NETWORK_UNREACHABLE":    1,
		"HOST_UNREACHABLE":       2,
		"PROTOCOL_UNREACHABLE":   3,
		"PORT_UNREACHABLE":       4,
		"FRAGMENTATION_REQUIRED": 5,
		"SOURCE_ROUTE_FAILED":    6,
	}
)

func (x IcmpHeader_DestinationUnreachable_Code) Enum() *IcmpHeader_DestinationUnreachable_Code {
	p := new(IcmpHeader_DestinationUnreachable_Code)
	*p = x
	return p
}

func (x IcmpHeader_DestinationUnreachable_Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IcmpHeader_DestinationUnreachable_Code) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[17].Descriptor()
}

func (IcmpHeader_DestinationUnreachable_Code) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[17]
}

func (x IcmpHeader_DestinationUnreachable_Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IcmpHeader_DestinationUnreachable_Code.Descriptor instead.
func (IcmpHeader_DestinationUnreachable_Code) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 1, 0}
}

type IcmpHeader_RedirectMessage_Code int32

const (
	IcmpHeader_RedirectMessage_CODE_UNSPECIFIED IcmpHeader_RedirectMessage_Code = 0
	IcmpHeader_RedirectMessage_NETWORK          IcmpHeader_RedirectMessage_Code = 1
	IcmpHeader_RedirectMessage_HOST             IcmpHeader_RedirectMessage_Code = 2
	IcmpHeader_RedirectMessage_TOS_AND_NETWORK  IcmpHeader_RedirectMessage_Code = 3
	IcmpHeader_RedirectMessage_TOS_AND_HOST     IcmpHeader_RedirectMessage_Code = 4
)

// Enum value maps for IcmpHeader_RedirectMessage_Code.
var (
	IcmpHeader_RedirectMessage_Code_name = map[int32]string{
		0: "CODE_UNSPECIFIED",
		1: "NETWORK",
		2: "HOST",
		3: "TOS_AND_NETWORK",
		4: "TOS_AND_HOST",
	}
	IcmpHeader_RedirectMessage_Code_value = map[string]int32{
		"CODE_UNSPECIFIED": 0,
		"NETWORK":          1,
		"HOST":             2,
		"TOS_AND_NETWORK":  3,
		"TOS_AND_HOST":     4,
	}
)

func (x IcmpHeader_RedirectMessage_Code) Enum() *IcmpHeader_RedirectMessage_Code {
	p := new(IcmpHeader_RedirectMessage_Code)
	*p = x
	return p
}

func (x IcmpHeader_RedirectMessage_Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IcmpHeader_RedirectMessage_Code) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[18].Descriptor()
}

func (IcmpHeader_RedirectMessage_Code) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[18]
}

func (x IcmpHeader_RedirectMessage_Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IcmpHeader_RedirectMessage_Code.Descriptor instead.
func (IcmpHeader_RedirectMessage_Code) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 2, 0}
}

type IcmpHeader_TimeExceeded_Code int32

const (
	IcmpHeader_TimeExceeded_CODE_UNSPECIFIED    IcmpHeader_TimeExceeded_Code = 0
	IcmpHeader_TimeExceeded_TRANSIT             IcmpHeader_TimeExceeded_Code = 1
	IcmpHeader_TimeExceeded_FRAGMENT_REASSEMBLY IcmpHeader_TimeExceeded_Code = 2
)

// Enum value maps for IcmpHeader_TimeExceeded_Code.
var (
	IcmpHeader_TimeExceeded_Code_name = map[int32]string{
		0: "CODE_UNSPECIFIED",
		1: "TRANSIT",
		2: "FRAGMENT_REASSEMBLY",
	}
	IcmpHeader_TimeExceeded_Code_value = map[string]int32{
		"CODE_UNSPECIFIED":    0,
		"TRANSIT":             1,
		"FRAGMENT_REASSEMBLY": 2,
	}
)

func (x IcmpHeader_TimeExceeded_Code) Enum() *IcmpHeader_TimeExceeded_Code {
	p := new(IcmpHeader_TimeExceeded_Code)
	*p = x
	return p
}

func (x IcmpHeader_TimeExceeded_Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IcmpHeader_TimeExceeded_Code) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[19].Descriptor()
}

func (IcmpHeader_TimeExceeded_Code) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[19]
}

func (x IcmpHeader_TimeExceeded_Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IcmpHeader_TimeExceeded_Code.Descriptor instead.
func (IcmpHeader_TimeExceeded_Code) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 4, 0}
}

type OspfHeader_LinkStateType int32

const (
	OspfHeader_LINK_STATE_TYPE_UNSPECIFIED     OspfHeader_LinkStateType = 0
	OspfHeader_LINK_STATE_TYPE_ROUTER          OspfHeader_LinkStateType = 1
	OspfHeader_LINK_STATE_TYPE_NETWORK         OspfHeader_LinkStateType = 2
	OspfHeader_LINK_STATE_TYPE_SUMMARY_NETWORK OspfHeader_LinkStateType = 3
	OspfHeader_LINK_STATE_TYPE_SUMMARY_ASBR    OspfHeader_LinkStateType = 4
	OspfHeader_LINK_STATE_TYPE_AS_EXTERNAL     OspfHeader_LinkStateType = 5
)

// Enum value maps for OspfHeader_LinkStateType.
var (
	OspfHeader_LinkStateType_name = map[int32]string{
		0: "LINK_STATE_TYPE_UNSPECIFIED",
		1: "LINK_STATE_TYPE_ROUTER",
		2: "LINK_STATE_TYPE_NETWORK",
		3: "LINK_STATE_TYPE_SUMMARY_NETWORK",
		4: "LINK_STATE_TYPE_SUMMARY_ASBR",
		5: "LINK_STATE_TYPE_AS_EXTERNAL",
	}
	OspfHeader_LinkStateType_value = map[string]int32{
		"LINK_STATE_TYPE_UNSPECIFIED":     0,
		"LINK_STATE_TYPE_ROUTER":          1,
		"LINK_STATE_TYPE_NETWORK":         2,
		"LINK_STATE_TYPE_SUMMARY_NETWORK": 3,
		"LINK_STATE_TYPE_SUMMARY_ASBR":    4,
		"LINK_STATE_TYPE_AS_EXTERNAL":     5,
	}
)

func (x OspfHeader_LinkStateType) Enum() *OspfHeader_LinkStateType {
	p := new(OspfHeader_LinkStateType)
	*p = x
	return p
}

func (x OspfHeader_LinkStateType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OspfHeader_LinkStateType) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[20].Descriptor()
}

func (OspfHeader_LinkStateType) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[20]
}

func (x OspfHeader_LinkStateType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OspfHeader_LinkStateType.Descriptor instead.
func (OspfHeader_LinkStateType) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 0}
}

type RsvpHeader_MessageType int32

const (
	RsvpHeader_MESSAGE_TYPE_UNSPECIFIED RsvpHeader_MessageType = 0
	RsvpHeader_PATH                     RsvpHeader_MessageType = 1
	RsvpHeader_RESV                     RsvpHeader_MessageType = 2
)

// Enum value maps for RsvpHeader_MessageType.
var (
	RsvpHeader_MessageType_name = map[int32]string{
		0: "MESSAGE_TYPE_UNSPECIFIED",
		1: "PATH",
		2: "RESV",
	}
	RsvpHeader_MessageType_value = map[string]int32{
		"MESSAGE_TYPE_UNSPECIFIED": 0,
		"PATH":                     1,
		"RESV":                     2,
	}
)

func (x RsvpHeader_MessageType) Enum() *RsvpHeader_MessageType {
	p := new(RsvpHeader_MessageType)
	*p = x
	return p
}

func (x RsvpHeader_MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RsvpHeader_MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_ate_proto_enumTypes[21].Descriptor()
}

func (RsvpHeader_MessageType) Type() protoreflect.EnumType {
	return &file_ate_proto_enumTypes[21]
}

func (x RsvpHeader_MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RsvpHeader_MessageType.Descriptor instead.
func (RsvpHeader_MessageType) EnumDescriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{39, 0}
}

type Traffic struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Flows         []*Flow                `protobuf:"bytes,2,rep,name=flows,proto3" json:"flows,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Traffic) Reset() {
	*x = Traffic{}
	mi := &file_ate_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Traffic) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Traffic) ProtoMessage() {}

func (x *Traffic) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Traffic.ProtoReflect.Descriptor instead.
func (*Traffic) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{0}
}

func (x *Traffic) GetFlows() []*Flow {
	if x != nil {
		return x.Flows
	}
	return nil
}

type Lag struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Ports         []string               `protobuf:"bytes,2,rep,name=ports,proto3" json:"ports,omitempty"`
	Lacp          *Lag_Lacp              `protobuf:"bytes,3,opt,name=lacp,proto3" json:"lacp,omitempty"`
	Macsec        *MacSec                `protobuf:"bytes,4,opt,name=macsec,proto3" json:"macsec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Lag) Reset() {
	*x = Lag{}
	mi := &file_ate_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Lag) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Lag) ProtoMessage() {}

func (x *Lag) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Lag.ProtoReflect.Descriptor instead.
func (*Lag) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{1}
}

func (x *Lag) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Lag) GetPorts() []string {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *Lag) GetLacp() *Lag_Lacp {
	if x != nil {
		return x.Lacp
	}
	return nil
}

func (x *Lag) GetMacsec() *MacSec {
	if x != nil {
		return x.Macsec
	}
	return nil
}

type InterfaceConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Name  string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Types that are valid to be assigned to Link:
	//
	//	*InterfaceConfig_Port
	//	*InterfaceConfig_Lag
	Link             isInterfaceConfig_Link `protobuf_oneof:"link"`
	Ethernet         *EthernetConfig        `protobuf:"bytes,4,opt,name=ethernet,proto3" json:"ethernet,omitempty"`
	Ipv4             *IpConfig              `protobuf:"bytes,5,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Ipv6             *IpConfig              `protobuf:"bytes,6,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
	Ipv4LoopbackCidr string                 `protobuf:"bytes,11,opt,name=ipv4_loopback_cidr,json=ipv4LoopbackCidr,proto3" json:"ipv4_loopback_cidr,omitempty"`
	Ipv6LoopbackCidr string                 `protobuf:"bytes,13,opt,name=ipv6_loopback_cidr,json=ipv6LoopbackCidr,proto3" json:"ipv6_loopback_cidr,omitempty"`
	Isis             *ISISConfig            `protobuf:"bytes,7,opt,name=isis,proto3" json:"isis,omitempty"`
	Bgp              *BgpConfig             `protobuf:"bytes,8,opt,name=bgp,proto3" json:"bgp,omitempty"`
	Rsvps            []*RsvpConfig          `protobuf:"bytes,12,rep,name=rsvps,proto3" json:"rsvps,omitempty"`
	Dhcpv6Client     *DhcpV6Client          `protobuf:"bytes,15,opt,name=dhcpv6_client,json=dhcpv6Client,proto3" json:"dhcpv6_client,omitempty"`
	Dhcpv6Server     *DhcpV6Server          `protobuf:"bytes,16,opt,name=dhcpv6_server,json=dhcpv6Server,proto3" json:"dhcpv6_server,omitempty"`
	Networks         []*Network             `protobuf:"bytes,9,rep,name=networks,proto3" json:"networks,omitempty"`
	EnableLacp       bool                   `protobuf:"varint,10,opt,name=enable_lacp,json=enableLacp,proto3" json:"enable_lacp,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *InterfaceConfig) Reset() {
	*x = InterfaceConfig{}
	mi := &file_ate_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InterfaceConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InterfaceConfig) ProtoMessage() {}

func (x *InterfaceConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InterfaceConfig.ProtoReflect.Descriptor instead.
func (*InterfaceConfig) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{2}
}

func (x *InterfaceConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InterfaceConfig) GetLink() isInterfaceConfig_Link {
	if x != nil {
		return x.Link
	}
	return nil
}

func (x *InterfaceConfig) GetPort() string {
	if x != nil {
		if x, ok := x.Link.(*InterfaceConfig_Port); ok {
			return x.Port
		}
	}
	return ""
}

func (x *InterfaceConfig) GetLag() string {
	if x != nil {
		if x, ok := x.Link.(*InterfaceConfig_Lag); ok {
			return x.Lag
		}
	}
	return ""
}

func (x *InterfaceConfig) GetEthernet() *EthernetConfig {
	if x != nil {
		return x.Ethernet
	}
	return nil
}

func (x *InterfaceConfig) GetIpv4() *IpConfig {
	if x != nil {
		return x.Ipv4
	}
	return nil
}

func (x *InterfaceConfig) GetIpv6() *IpConfig {
	if x != nil {
		return x.Ipv6
	}
	return nil
}

func (x *InterfaceConfig) GetIpv4LoopbackCidr() string {
	if x != nil {
		return x.Ipv4LoopbackCidr
	}
	return ""
}

func (x *InterfaceConfig) GetIpv6LoopbackCidr() string {
	if x != nil {
		return x.Ipv6LoopbackCidr
	}
	return ""
}

func (x *InterfaceConfig) GetIsis() *ISISConfig {
	if x != nil {
		return x.Isis
	}
	return nil
}

func (x *InterfaceConfig) GetBgp() *BgpConfig {
	if x != nil {
		return x.Bgp
	}
	return nil
}

func (x *InterfaceConfig) GetRsvps() []*RsvpConfig {
	if x != nil {
		return x.Rsvps
	}
	return nil
}

func (x *InterfaceConfig) GetDhcpv6Client() *DhcpV6Client {
	if x != nil {
		return x.Dhcpv6Client
	}
	return nil
}

func (x *InterfaceConfig) GetDhcpv6Server() *DhcpV6Server {
	if x != nil {
		return x.Dhcpv6Server
	}
	return nil
}

func (x *InterfaceConfig) GetNetworks() []*Network {
	if x != nil {
		return x.Networks
	}
	return nil
}

func (x *InterfaceConfig) GetEnableLacp() bool {
	if x != nil {
		return x.EnableLacp
	}
	return false
}

type isInterfaceConfig_Link interface {
	isInterfaceConfig_Link()
}

type InterfaceConfig_Port struct {
	Port string `protobuf:"bytes,2,opt,name=port,proto3,oneof"`
}

type InterfaceConfig_Lag struct {
	Lag string `protobuf:"bytes,3,opt,name=lag,proto3,oneof"`
}

func (*InterfaceConfig_Port) isInterfaceConfig_Link() {}

func (*InterfaceConfig_Lag) isInterfaceConfig_Link() {}

type EthernetConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Mtu   uint32                 `protobuf:"varint,1,opt,name=mtu,proto3" json:"mtu,omitempty"`
	// Note that this is only a 12-bit value in the protocol.
	VlanId        uint32  `protobuf:"varint,2,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	Macsec        *MacSec `protobuf:"bytes,3,opt,name=macsec,proto3" json:"macsec,omitempty"`
	Fec           *Fec    `protobuf:"bytes,4,opt,name=fec,proto3" json:"fec,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EthernetConfig) Reset() {
	*x = EthernetConfig{}
	mi := &file_ate_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EthernetConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EthernetConfig) ProtoMessage() {}

func (x *EthernetConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EthernetConfig.ProtoReflect.Descriptor instead.
func (*EthernetConfig) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{3}
}

func (x *EthernetConfig) GetMtu() uint32 {
	if x != nil {
		return x.Mtu
	}
	return 0
}

func (x *EthernetConfig) GetVlanId() uint32 {
	if x != nil {
		return x.VlanId
	}
	return 0
}

func (x *EthernetConfig) GetMacsec() *MacSec {
	if x != nil {
		return x.Macsec
	}
	return nil
}

func (x *EthernetConfig) GetFec() *Fec {
	if x != nil {
		return x.Fec
	}
	return nil
}

type Fec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Fec) Reset() {
	*x = Fec{}
	mi := &file_ate_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Fec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Fec) ProtoMessage() {}

func (x *Fec) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Fec.ProtoReflect.Descriptor instead.
func (*Fec) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{4}
}

func (x *Fec) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

type MacSec struct {
	state                 protoimpl.MessageState `protogen:"open.v1"`
	CipherSuite           MacSec_CipherSuite     `protobuf:"varint,1,opt,name=cipher_suite,json=cipherSuite,proto3,enum=ondatra.MacSec_CipherSuite" json:"cipher_suite,omitempty"`
	EncryptedVlansEnabled bool                   `protobuf:"varint,2,opt,name=encrypted_vlans_enabled,json=encryptedVlansEnabled,proto3" json:"encrypted_vlans_enabled,omitempty"`
	CleartextEthernetVlan bool                   `protobuf:"varint,5,opt,name=cleartext_ethernet_vlan,json=cleartextEthernetVlan,proto3" json:"cleartext_ethernet_vlan,omitempty"`
	RxSecTagOffset        uint32                 `protobuf:"varint,6,opt,name=rx_sec_tag_offset,json=rxSecTagOffset,proto3" json:"rx_sec_tag_offset,omitempty"`
	RxSakPool             *RxSakPool             `protobuf:"bytes,3,opt,name=rx_sak_pool,json=rxSakPool,proto3" json:"rx_sak_pool,omitempty"`
	Mka                   *MacSec_MKA            `protobuf:"bytes,4,opt,name=mka,proto3" json:"mka,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *MacSec) Reset() {
	*x = MacSec{}
	mi := &file_ate_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacSec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacSec) ProtoMessage() {}

func (x *MacSec) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacSec.ProtoReflect.Descriptor instead.
func (*MacSec) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{5}
}

func (x *MacSec) GetCipherSuite() MacSec_CipherSuite {
	if x != nil {
		return x.CipherSuite
	}
	return MacSec_CIPHER_SUITE_UNSPECIFIED
}

func (x *MacSec) GetEncryptedVlansEnabled() bool {
	if x != nil {
		return x.EncryptedVlansEnabled
	}
	return false
}

func (x *MacSec) GetCleartextEthernetVlan() bool {
	if x != nil {
		return x.CleartextEthernetVlan
	}
	return false
}

func (x *MacSec) GetRxSecTagOffset() uint32 {
	if x != nil {
		return x.RxSecTagOffset
	}
	return 0
}

func (x *MacSec) GetRxSakPool() *RxSakPool {
	if x != nil {
		return x.RxSakPool
	}
	return nil
}

func (x *MacSec) GetMka() *MacSec_MKA {
	if x != nil {
		return x.Mka
	}
	return nil
}

type RxSakPool struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Sak128        string                 `protobuf:"bytes,10,opt,name=sak128,proto3" json:"sak128,omitempty"`
	Sak256        string                 `protobuf:"bytes,11,opt,name=sak256,proto3" json:"sak256,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RxSakPool) Reset() {
	*x = RxSakPool{}
	mi := &file_ate_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RxSakPool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RxSakPool) ProtoMessage() {}

func (x *RxSakPool) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RxSakPool.ProtoReflect.Descriptor instead.
func (*RxSakPool) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{6}
}

func (x *RxSakPool) GetSak128() string {
	if x != nil {
		return x.Sak128
	}
	return ""
}

func (x *RxSakPool) GetSak256() string {
	if x != nil {
		return x.Sak256
	}
	return ""
}

type IpConfig struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	AddressCidr    string                 `protobuf:"bytes,1,opt,name=address_cidr,json=addressCidr,proto3" json:"address_cidr,omitempty"`
	DefaultGateway string                 `protobuf:"bytes,2,opt,name=default_gateway,json=defaultGateway,proto3" json:"default_gateway,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *IpConfig) Reset() {
	*x = IpConfig{}
	mi := &file_ate_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IpConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpConfig) ProtoMessage() {}

func (x *IpConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpConfig.ProtoReflect.Descriptor instead.
func (*IpConfig) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{7}
}

func (x *IpConfig) GetAddressCidr() string {
	if x != nil {
		return x.AddressCidr
	}
	return ""
}

func (x *IpConfig) GetDefaultGateway() string {
	if x != nil {
		return x.DefaultGateway
	}
	return ""
}

// IS-IS configuration for the ATE.
type ISISConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The IS-IS level which the ate behaves as.
	Level ISISConfig_Level `protobuf:"varint,1,opt,name=level,proto3,enum=ondatra.ISISConfig_Level" json:"level,omitempty"`
	// The routing metric used for IS-IS link-state calculation.
	Metric uint32 `protobuf:"varint,2,opt,name=metric,proto3" json:"metric,omitempty"`
	// Area id this ate belongs to.
	AreaId string `protobuf:"bytes,3,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`
	// Use a wider range of allowed metric number up to up to 16,777,215,
	// otherwise the metrics can have values up to 63.
	EnableWideMetric bool `protobuf:"varint,4,opt,name=enable_wide_metric,json=enableWideMetric,proto3" json:"enable_wide_metric,omitempty"`
	// The network type of the IS-IS interface.
	NetworkType ISISConfig_NetworkType `protobuf:"varint,5,opt,name=network_type,json=networkType,proto3,enum=ondatra.ISISConfig_NetworkType" json:"network_type,omitempty"`
	// The type of authentication.
	AuthType ISISConfig_AuthType `protobuf:"varint,6,opt,name=auth_type,json=authType,proto3,enum=ondatra.ISISConfig_AuthType" json:"auth_type,omitempty"`
	// The auth key to be used for authentication.
	AuthKey string `protobuf:"bytes,7,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	// The type of area authentication.
	AreaAuthType ISISConfig_AuthType `protobuf:"varint,19,opt,name=area_auth_type,json=areaAuthType,proto3,enum=ondatra.ISISConfig_AuthType" json:"area_auth_type,omitempty"`
	// The auth key to be used for area authentication.
	AreaAuthKey string `protobuf:"bytes,20,opt,name=area_auth_key,json=areaAuthKey,proto3" json:"area_auth_key,omitempty"`
	// The type of domain authentication.
	DomainAuthType ISISConfig_AuthType `protobuf:"varint,21,opt,name=domain_auth_type,json=domainAuthType,proto3,enum=ondatra.ISISConfig_AuthType" json:"domain_auth_type,omitempty"`
	// The auth key to be used for domain authentication.
	DomainAuthKey string `protobuf:"bytes,22,opt,name=domain_auth_key,json=domainAuthKey,proto3" json:"domain_auth_key,omitempty"`
	// enables hello padding.
	EnableHelloPadding bool `protobuf:"varint,8,opt,name=enable_hello_padding,json=enableHelloPadding,proto3" json:"enable_hello_padding,omitempty"`
	// enables traffic engineering.
	EnableTe bool `protobuf:"varint,9,opt,name=enable_te,json=enableTe,proto3" json:"enable_te,omitempty"`
	// discard learned lsp info.
	DiscardLsps bool `protobuf:"varint,10,opt,name=discard_lsps,json=discardLsps,proto3" json:"discard_lsps,omitempty"`
	// the router id.
	TeRouterId string `protobuf:"bytes,11,opt,name=te_router_id,json=teRouterId,proto3" json:"te_router_id,omitempty"`
	// config to simulate pool of reachable ips.
	IpReachability *IPReachability `protobuf:"bytes,12,opt,name=ip_reachability,json=ipReachability,proto3" json:"ip_reachability,omitempty"`
	// config to simulate topology of IS-IS routers.
	IsReachabilities []*ISReachability `protobuf:"bytes,13,rep,name=is_reachabilities,json=isReachabilities,proto3" json:"is_reachabilities,omitempty"`
	// pripority of the interface
	InterfacePriority uint32 `protobuf:"varint,14,opt,name=interface_priority,json=interfacePriority,proto3" json:"interface_priority,omitempty"`
	// interval between sending hello packets.
	HelloIntervalSec uint32 `protobuf:"varint,15,opt,name=hello_interval_sec,json=helloIntervalSec,proto3" json:"hello_interval_sec,omitempty"`
	// interval before considering adjacency is down.
	DeadIntervalSec uint32 `protobuf:"varint,16,opt,name=dead_interval_sec,json=deadIntervalSec,proto3" json:"dead_interval_sec,omitempty"`
	// IS-IS segment routing configuration.
	SegmentRouting *ISISSegmentRouting `protobuf:"bytes,17,opt,name=segment_routing,json=segmentRouting,proto3" json:"segment_routing,omitempty"`
	// the capability router id.
	CapabilityRouterId string `protobuf:"bytes,18,opt,name=capability_router_id,json=capabilityRouterId,proto3" json:"capability_router_id,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ISISConfig) Reset() {
	*x = ISISConfig{}
	mi := &file_ate_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISISConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISISConfig) ProtoMessage() {}

func (x *ISISConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISISConfig.ProtoReflect.Descriptor instead.
func (*ISISConfig) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{8}
}

func (x *ISISConfig) GetLevel() ISISConfig_Level {
	if x != nil {
		return x.Level
	}
	return ISISConfig_LEVEL_UNSPECIFIED
}

func (x *ISISConfig) GetMetric() uint32 {
	if x != nil {
		return x.Metric
	}
	return 0
}

func (x *ISISConfig) GetAreaId() string {
	if x != nil {
		return x.AreaId
	}
	return ""
}

func (x *ISISConfig) GetEnableWideMetric() bool {
	if x != nil {
		return x.EnableWideMetric
	}
	return false
}

func (x *ISISConfig) GetNetworkType() ISISConfig_NetworkType {
	if x != nil {
		return x.NetworkType
	}
	return ISISConfig_NETWORK_TYPE_UNSPECIFIED
}

func (x *ISISConfig) GetAuthType() ISISConfig_AuthType {
	if x != nil {
		return x.AuthType
	}
	return ISISConfig_AUTH_TYPE_UNSPECIFIED
}

func (x *ISISConfig) GetAuthKey() string {
	if x != nil {
		return x.AuthKey
	}
	return ""
}

func (x *ISISConfig) GetAreaAuthType() ISISConfig_AuthType {
	if x != nil {
		return x.AreaAuthType
	}
	return ISISConfig_AUTH_TYPE_UNSPECIFIED
}

func (x *ISISConfig) GetAreaAuthKey() string {
	if x != nil {
		return x.AreaAuthKey
	}
	return ""
}

func (x *ISISConfig) GetDomainAuthType() ISISConfig_AuthType {
	if x != nil {
		return x.DomainAuthType
	}
	return ISISConfig_AUTH_TYPE_UNSPECIFIED
}

func (x *ISISConfig) GetDomainAuthKey() string {
	if x != nil {
		return x.DomainAuthKey
	}
	return ""
}

func (x *ISISConfig) GetEnableHelloPadding() bool {
	if x != nil {
		return x.EnableHelloPadding
	}
	return false
}

func (x *ISISConfig) GetEnableTe() bool {
	if x != nil {
		return x.EnableTe
	}
	return false
}

func (x *ISISConfig) GetDiscardLsps() bool {
	if x != nil {
		return x.DiscardLsps
	}
	return false
}

func (x *ISISConfig) GetTeRouterId() string {
	if x != nil {
		return x.TeRouterId
	}
	return ""
}

func (x *ISISConfig) GetIpReachability() *IPReachability {
	if x != nil {
		return x.IpReachability
	}
	return nil
}

func (x *ISISConfig) GetIsReachabilities() []*ISReachability {
	if x != nil {
		return x.IsReachabilities
	}
	return nil
}

func (x *ISISConfig) GetInterfacePriority() uint32 {
	if x != nil {
		return x.InterfacePriority
	}
	return 0
}

func (x *ISISConfig) GetHelloIntervalSec() uint32 {
	if x != nil {
		return x.HelloIntervalSec
	}
	return 0
}

func (x *ISISConfig) GetDeadIntervalSec() uint32 {
	if x != nil {
		return x.DeadIntervalSec
	}
	return 0
}

func (x *ISISConfig) GetSegmentRouting() *ISISSegmentRouting {
	if x != nil {
		return x.SegmentRouting
	}
	return nil
}

func (x *ISISConfig) GetCapabilityRouterId() string {
	if x != nil {
		return x.CapabilityRouterId
	}
	return ""
}

type ISISSegmentRouting struct {
	state            protoimpl.MessageState           `protogen:"open.v1"`
	Enable           bool                             `protobuf:"varint,1,opt,name=enable,proto3" json:"enable,omitempty"`
	AdjacencySid     *ISISSegmentRouting_AdjacencySID `protobuf:"bytes,2,opt,name=adjacency_sid,json=adjacencySid,proto3" json:"adjacency_sid,omitempty"`
	SidIndexLabel    uint32                           `protobuf:"varint,3,opt,name=sid_index_label,json=sidIndexLabel,proto3" json:"sid_index_label,omitempty"`
	SrgbRanges       []*ISISSegmentRouting_SIDRange   `protobuf:"bytes,4,rep,name=srgb_ranges,json=srgbRanges,proto3" json:"srgb_ranges,omitempty"`
	SrlbRanges       []*ISISSegmentRouting_SIDRange   `protobuf:"bytes,5,rep,name=srlb_ranges,json=srlbRanges,proto3" json:"srlb_ranges,omitempty"`
	FlagReadvertise  bool                             `protobuf:"varint,6,opt,name=flag_readvertise,json=flagReadvertise,proto3" json:"flag_readvertise,omitempty"`
	FlagNodeSid      bool                             `protobuf:"varint,7,opt,name=flag_node_sid,json=flagNodeSid,proto3" json:"flag_node_sid,omitempty"`
	FlagNoPhp        bool                             `protobuf:"varint,8,opt,name=flag_no_php,json=flagNoPhp,proto3" json:"flag_no_php,omitempty"`
	FlagExplicitNull bool                             `protobuf:"varint,9,opt,name=flag_explicit_null,json=flagExplicitNull,proto3" json:"flag_explicit_null,omitempty"`
	FlagValue        bool                             `protobuf:"varint,10,opt,name=flag_value,json=flagValue,proto3" json:"flag_value,omitempty"`
	FlagLocal        bool                             `protobuf:"varint,11,opt,name=flag_local,json=flagLocal,proto3" json:"flag_local,omitempty"`
	Algorithms       []uint32                         `protobuf:"varint,12,rep,packed,name=algorithms,proto3" json:"algorithms,omitempty"`
	PrefixSid        string                           `protobuf:"bytes,13,opt,name=prefix_sid,json=prefixSid,proto3" json:"prefix_sid,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ISISSegmentRouting) Reset() {
	*x = ISISSegmentRouting{}
	mi := &file_ate_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISISSegmentRouting) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISISSegmentRouting) ProtoMessage() {}

func (x *ISISSegmentRouting) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISISSegmentRouting.ProtoReflect.Descriptor instead.
func (*ISISSegmentRouting) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{9}
}

func (x *ISISSegmentRouting) GetEnable() bool {
	if x != nil {
		return x.Enable
	}
	return false
}

func (x *ISISSegmentRouting) GetAdjacencySid() *ISISSegmentRouting_AdjacencySID {
	if x != nil {
		return x.AdjacencySid
	}
	return nil
}

func (x *ISISSegmentRouting) GetSidIndexLabel() uint32 {
	if x != nil {
		return x.SidIndexLabel
	}
	return 0
}

func (x *ISISSegmentRouting) GetSrgbRanges() []*ISISSegmentRouting_SIDRange {
	if x != nil {
		return x.SrgbRanges
	}
	return nil
}

func (x *ISISSegmentRouting) GetSrlbRanges() []*ISISSegmentRouting_SIDRange {
	if x != nil {
		return x.SrlbRanges
	}
	return nil
}

func (x *ISISSegmentRouting) GetFlagReadvertise() bool {
	if x != nil {
		return x.FlagReadvertise
	}
	return false
}

func (x *ISISSegmentRouting) GetFlagNodeSid() bool {
	if x != nil {
		return x.FlagNodeSid
	}
	return false
}

func (x *ISISSegmentRouting) GetFlagNoPhp() bool {
	if x != nil {
		return x.FlagNoPhp
	}
	return false
}

func (x *ISISSegmentRouting) GetFlagExplicitNull() bool {
	if x != nil {
		return x.FlagExplicitNull
	}
	return false
}

func (x *ISISSegmentRouting) GetFlagValue() bool {
	if x != nil {
		return x.FlagValue
	}
	return false
}

func (x *ISISSegmentRouting) GetFlagLocal() bool {
	if x != nil {
		return x.FlagLocal
	}
	return false
}

func (x *ISISSegmentRouting) GetAlgorithms() []uint32 {
	if x != nil {
		return x.Algorithms
	}
	return nil
}

func (x *ISISSegmentRouting) GetPrefixSid() string {
	if x != nil {
		return x.PrefixSid
	}
	return ""
}

type IPReachability struct {
	state               protoimpl.MessageState     `protogen:"open.v1"`
	Metric              uint32                     `protobuf:"varint,1,opt,name=metric,proto3" json:"metric,omitempty"`
	RouteOrigin         IPReachability_RouteOrigin `protobuf:"varint,2,opt,name=route_origin,json=routeOrigin,proto3,enum=ondatra.IPReachability_RouteOrigin" json:"route_origin,omitempty"`
	Algorithm           uint32                     `protobuf:"varint,3,opt,name=algorithm,proto3" json:"algorithm,omitempty"`
	SidIndexLabel       uint32                     `protobuf:"varint,4,opt,name=sid_index_label,json=sidIndexLabel,proto3" json:"sid_index_label,omitempty"`
	FlagReadvertise     bool                       `protobuf:"varint,5,opt,name=flag_readvertise,json=flagReadvertise,proto3" json:"flag_readvertise,omitempty"`
	FlagNodeSid         bool                       `protobuf:"varint,6,opt,name=flag_node_sid,json=flagNodeSid,proto3" json:"flag_node_sid,omitempty"`
	FlagNoPhp           bool                       `protobuf:"varint,7,opt,name=flag_no_php,json=flagNoPhp,proto3" json:"flag_no_php,omitempty"`
	FlagExplicitNull    bool                       `protobuf:"varint,8,opt,name=flag_explicit_null,json=flagExplicitNull,proto3" json:"flag_explicit_null,omitempty"`
	FlagValue           bool                       `protobuf:"varint,9,opt,name=flag_value,json=flagValue,proto3" json:"flag_value,omitempty"`
	FlagLocal           bool                       `protobuf:"varint,10,opt,name=flag_local,json=flagLocal,proto3" json:"flag_local,omitempty"`
	EnableSidIndexLabel bool                       `protobuf:"varint,11,opt,name=enable_sid_index_label,json=enableSidIndexLabel,proto3" json:"enable_sid_index_label,omitempty"`
	Active              bool                       `protobuf:"varint,12,opt,name=active,proto3" json:"active,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *IPReachability) Reset() {
	*x = IPReachability{}
	mi := &file_ate_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPReachability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPReachability) ProtoMessage() {}

func (x *IPReachability) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPReachability.ProtoReflect.Descriptor instead.
func (*IPReachability) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{10}
}

func (x *IPReachability) GetMetric() uint32 {
	if x != nil {
		return x.Metric
	}
	return 0
}

func (x *IPReachability) GetRouteOrigin() IPReachability_RouteOrigin {
	if x != nil {
		return x.RouteOrigin
	}
	return IPReachability_ROUTE_ORIGIN_UNSPECIFIED
}

func (x *IPReachability) GetAlgorithm() uint32 {
	if x != nil {
		return x.Algorithm
	}
	return 0
}

func (x *IPReachability) GetSidIndexLabel() uint32 {
	if x != nil {
		return x.SidIndexLabel
	}
	return 0
}

func (x *IPReachability) GetFlagReadvertise() bool {
	if x != nil {
		return x.FlagReadvertise
	}
	return false
}

func (x *IPReachability) GetFlagNodeSid() bool {
	if x != nil {
		return x.FlagNodeSid
	}
	return false
}

func (x *IPReachability) GetFlagNoPhp() bool {
	if x != nil {
		return x.FlagNoPhp
	}
	return false
}

func (x *IPReachability) GetFlagExplicitNull() bool {
	if x != nil {
		return x.FlagExplicitNull
	}
	return false
}

func (x *IPReachability) GetFlagValue() bool {
	if x != nil {
		return x.FlagValue
	}
	return false
}

func (x *IPReachability) GetFlagLocal() bool {
	if x != nil {
		return x.FlagLocal
	}
	return false
}

func (x *IPReachability) GetEnableSidIndexLabel() bool {
	if x != nil {
		return x.EnableSidIndexLabel
	}
	return false
}

func (x *IPReachability) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

type ISReachability struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         []*ISReachability_Node `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Name          string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ISReachability) Reset() {
	*x = ISReachability{}
	mi := &file_ate_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISReachability) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISReachability) ProtoMessage() {}

func (x *ISReachability) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISReachability.ProtoReflect.Descriptor instead.
func (*ISReachability) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{11}
}

func (x *ISReachability) GetNodes() []*ISReachability_Node {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *ISReachability) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type BgpCommunities struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	NoExport           bool                   `protobuf:"varint,1,opt,name=no_export,json=noExport,proto3" json:"no_export,omitempty"`
	NoAdvertise        bool                   `protobuf:"varint,2,opt,name=no_advertise,json=noAdvertise,proto3" json:"no_advertise,omitempty"`
	NoExportSubconfed  bool                   `protobuf:"varint,3,opt,name=no_export_subconfed,json=noExportSubconfed,proto3" json:"no_export_subconfed,omitempty"`
	LlgrStale          bool                   `protobuf:"varint,4,opt,name=llgr_stale,json=llgrStale,proto3" json:"llgr_stale,omitempty"`
	NoLlgr             bool                   `protobuf:"varint,5,opt,name=no_llgr,json=noLlgr,proto3" json:"no_llgr,omitempty"`
	PrivateCommunities []string               `protobuf:"bytes,6,rep,name=private_communities,json=privateCommunities,proto3" json:"private_communities,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *BgpCommunities) Reset() {
	*x = BgpCommunities{}
	mi := &file_ate_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpCommunities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpCommunities) ProtoMessage() {}

func (x *BgpCommunities) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpCommunities.ProtoReflect.Descriptor instead.
func (*BgpCommunities) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{12}
}

func (x *BgpCommunities) GetNoExport() bool {
	if x != nil {
		return x.NoExport
	}
	return false
}

func (x *BgpCommunities) GetNoAdvertise() bool {
	if x != nil {
		return x.NoAdvertise
	}
	return false
}

func (x *BgpCommunities) GetNoExportSubconfed() bool {
	if x != nil {
		return x.NoExportSubconfed
	}
	return false
}

func (x *BgpCommunities) GetLlgrStale() bool {
	if x != nil {
		return x.LlgrStale
	}
	return false
}

func (x *BgpCommunities) GetNoLlgr() bool {
	if x != nil {
		return x.NoLlgr
	}
	return false
}

func (x *BgpCommunities) GetPrivateCommunities() []string {
	if x != nil {
		return x.PrivateCommunities
	}
	return nil
}

// BGP config for the ATE.
type BgpConfig struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BgpPeers      []*BgpPeer             `protobuf:"bytes,1,rep,name=bgp_peers,json=bgpPeers,proto3" json:"bgp_peers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpConfig) Reset() {
	*x = BgpConfig{}
	mi := &file_ate_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpConfig) ProtoMessage() {}

func (x *BgpConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpConfig.ProtoReflect.Descriptor instead.
func (*BgpConfig) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{13}
}

func (x *BgpConfig) GetBgpPeers() []*BgpPeer {
	if x != nil {
		return x.BgpPeers
	}
	return nil
}

// BGP peer for the ATE.
type BgpPeer struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Id          uint32                 `protobuf:"varint,11,opt,name=id,proto3" json:"id,omitempty"`
	Active      bool                   `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	OnLoopback  bool                   `protobuf:"varint,10,opt,name=on_loopback,json=onLoopback,proto3" json:"on_loopback,omitempty"`
	Type        BgpPeer_Type           `protobuf:"varint,2,opt,name=type,proto3,enum=ondatra.BgpPeer_Type" json:"type,omitempty"`
	PeerAddress string                 `protobuf:"bytes,3,opt,name=peer_address,json=peerAddress,proto3" json:"peer_address,omitempty"`
	LocalAsn    uint32                 `protobuf:"varint,4,opt,name=local_asn,json=localAsn,proto3" json:"local_asn,omitempty"`
	// Note that this is only a 16-bit value in the protocol.
	HoldTimeSec       uint32                     `protobuf:"varint,5,opt,name=hold_time_sec,json=holdTimeSec,proto3" json:"hold_time_sec,omitempty"`
	KeepaliveTimeSec  uint32                     `protobuf:"varint,6,opt,name=keepalive_time_sec,json=keepaliveTimeSec,proto3" json:"keepalive_time_sec,omitempty"`
	Md5Key            string                     `protobuf:"bytes,7,opt,name=md5_key,json=md5Key,proto3" json:"md5_key,omitempty"`
	Capabilities      *BgpPeer_Capabilities      `protobuf:"bytes,8,opt,name=capabilities,proto3" json:"capabilities,omitempty"`
	SrtePolicyGroups  []*BgpPeer_SrtePolicyGroup `protobuf:"bytes,9,rep,name=srte_policy_groups,json=srtePolicyGroups,proto3" json:"srte_policy_groups,omitempty"`
	RestartTime       *durationpb.Duration       `protobuf:"bytes,12,opt,name=restart_time,json=restartTime,proto3" json:"restart_time,omitempty"`
	StaleTime         *durationpb.Duration       `protobuf:"bytes,13,opt,name=stale_time,json=staleTime,proto3" json:"stale_time,omitempty"`
	AdvertiseEndOfRib bool                       `protobuf:"varint,14,opt,name=advertise_end_of_rib,json=advertiseEndOfRib,proto3" json:"advertise_end_of_rib,omitempty"`
	ActAsRestarted    bool                       `protobuf:"varint,15,opt,name=act_as_restarted,json=actAsRestarted,proto3" json:"act_as_restarted,omitempty"` // NEXT ID: 16
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *BgpPeer) Reset() {
	*x = BgpPeer{}
	mi := &file_ate_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer) ProtoMessage() {}

func (x *BgpPeer) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer.ProtoReflect.Descriptor instead.
func (*BgpPeer) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14}
}

func (x *BgpPeer) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *BgpPeer) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *BgpPeer) GetOnLoopback() bool {
	if x != nil {
		return x.OnLoopback
	}
	return false
}

func (x *BgpPeer) GetType() BgpPeer_Type {
	if x != nil {
		return x.Type
	}
	return BgpPeer_TYPE_UNSPECIFIED
}

func (x *BgpPeer) GetPeerAddress() string {
	if x != nil {
		return x.PeerAddress
	}
	return ""
}

func (x *BgpPeer) GetLocalAsn() uint32 {
	if x != nil {
		return x.LocalAsn
	}
	return 0
}

func (x *BgpPeer) GetHoldTimeSec() uint32 {
	if x != nil {
		return x.HoldTimeSec
	}
	return 0
}

func (x *BgpPeer) GetKeepaliveTimeSec() uint32 {
	if x != nil {
		return x.KeepaliveTimeSec
	}
	return 0
}

func (x *BgpPeer) GetMd5Key() string {
	if x != nil {
		return x.Md5Key
	}
	return ""
}

func (x *BgpPeer) GetCapabilities() *BgpPeer_Capabilities {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *BgpPeer) GetSrtePolicyGroups() []*BgpPeer_SrtePolicyGroup {
	if x != nil {
		return x.SrtePolicyGroups
	}
	return nil
}

func (x *BgpPeer) GetRestartTime() *durationpb.Duration {
	if x != nil {
		return x.RestartTime
	}
	return nil
}

func (x *BgpPeer) GetStaleTime() *durationpb.Duration {
	if x != nil {
		return x.StaleTime
	}
	return nil
}

func (x *BgpPeer) GetAdvertiseEndOfRib() bool {
	if x != nil {
		return x.AdvertiseEndOfRib
	}
	return false
}

func (x *BgpPeer) GetActAsRestarted() bool {
	if x != nil {
		return x.ActAsRestarted
	}
	return false
}

// BGP attributes for advertised prefixes.
type BgpAttributes struct {
	state                 protoimpl.MessageState              `protogen:"open.v1"`
	Active                bool                                `protobuf:"varint,8,opt,name=active,proto3" json:"active,omitempty"`
	NextHopAddress        string                              `protobuf:"bytes,1,opt,name=next_hop_address,json=nextHopAddress,proto3" json:"next_hop_address,omitempty"`
	Origin                BgpAttributes_Origin                `protobuf:"varint,2,opt,name=origin,proto3,enum=ondatra.BgpAttributes_Origin" json:"origin,omitempty"`
	LocalPreference       uint32                              `protobuf:"varint,3,opt,name=local_preference,json=localPreference,proto3" json:"local_preference,omitempty"`
	Communities           *BgpCommunities                     `protobuf:"bytes,4,opt,name=communities,proto3" json:"communities,omitempty"`
	ExtendedCommunities   []*BgpAttributes_ExtendedCommunity  `protobuf:"bytes,5,rep,name=extended_communities,json=extendedCommunities,proto3" json:"extended_communities,omitempty"`
	AsnSetMode            BgpAsnSetMode                       `protobuf:"varint,6,opt,name=asn_set_mode,json=asnSetMode,proto3,enum=ondatra.BgpAsnSetMode" json:"asn_set_mode,omitempty"`
	AsPathSegments        []*BgpAttributes_AsPathSegment      `protobuf:"bytes,7,rep,name=as_path_segments,json=asPathSegments,proto3" json:"as_path_segments,omitempty"`
	OriginatorId          *StringIncRange                     `protobuf:"bytes,9,opt,name=originator_id,json=originatorId,proto3" json:"originator_id,omitempty"`
	ClusterIds            []string                            `protobuf:"bytes,10,rep,name=cluster_ids,json=clusterIds,proto3" json:"cluster_ids,omitempty"`
	AdvertisementProtocol BgpAttributes_AdvertisementProtocol `protobuf:"varint,11,opt,name=advertisement_protocol,json=advertisementProtocol,proto3,enum=ondatra.BgpAttributes_AdvertisementProtocol" json:"advertisement_protocol,omitempty"` // NEXT ID: 12
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *BgpAttributes) Reset() {
	*x = BgpAttributes{}
	mi := &file_ate_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpAttributes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpAttributes) ProtoMessage() {}

func (x *BgpAttributes) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpAttributes.ProtoReflect.Descriptor instead.
func (*BgpAttributes) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15}
}

func (x *BgpAttributes) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *BgpAttributes) GetNextHopAddress() string {
	if x != nil {
		return x.NextHopAddress
	}
	return ""
}

func (x *BgpAttributes) GetOrigin() BgpAttributes_Origin {
	if x != nil {
		return x.Origin
	}
	return BgpAttributes_ORIGIN_UNSPECIFIED
}

func (x *BgpAttributes) GetLocalPreference() uint32 {
	if x != nil {
		return x.LocalPreference
	}
	return 0
}

func (x *BgpAttributes) GetCommunities() *BgpCommunities {
	if x != nil {
		return x.Communities
	}
	return nil
}

func (x *BgpAttributes) GetExtendedCommunities() []*BgpAttributes_ExtendedCommunity {
	if x != nil {
		return x.ExtendedCommunities
	}
	return nil
}

func (x *BgpAttributes) GetAsnSetMode() BgpAsnSetMode {
	if x != nil {
		return x.AsnSetMode
	}
	return BgpAsnSetMode_ASN_SET_MODE_UNSPECIFIED
}

func (x *BgpAttributes) GetAsPathSegments() []*BgpAttributes_AsPathSegment {
	if x != nil {
		return x.AsPathSegments
	}
	return nil
}

func (x *BgpAttributes) GetOriginatorId() *StringIncRange {
	if x != nil {
		return x.OriginatorId
	}
	return nil
}

func (x *BgpAttributes) GetClusterIds() []string {
	if x != nil {
		return x.ClusterIds
	}
	return nil
}

func (x *BgpAttributes) GetAdvertisementProtocol() BgpAttributes_AdvertisementProtocol {
	if x != nil {
		return x.AdvertisementProtocol
	}
	return BgpAttributes_ADVERTISEMENT_PROTOCOL_UNSPECIFIED
}

type RsvpConfig struct {
	state                protoimpl.MessageState `protogen:"open.v1"`
	Name                 string                 `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	InterfaceName        string                 `protobuf:"bytes,7,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	IsReachabilityName   string                 `protobuf:"bytes,2,opt,name=is_reachability_name,json=isReachabilityName,proto3" json:"is_reachability_name,omitempty"`
	Loopbacks            []*RsvpConfig_Loopback `protobuf:"bytes,3,rep,name=loopbacks,proto3" json:"loopbacks,omitempty"`
	BundleMessageSending bool                   `protobuf:"varint,4,opt,name=bundle_message_sending,json=bundleMessageSending,proto3" json:"bundle_message_sending,omitempty"`
	RefreshReduction     bool                   `protobuf:"varint,5,opt,name=refresh_reduction,json=refreshReduction,proto3" json:"refresh_reduction,omitempty"` // NEXT ID: 8
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *RsvpConfig) Reset() {
	*x = RsvpConfig{}
	mi := &file_ate_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RsvpConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RsvpConfig) ProtoMessage() {}

func (x *RsvpConfig) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RsvpConfig.ProtoReflect.Descriptor instead.
func (*RsvpConfig) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{16}
}

func (x *RsvpConfig) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RsvpConfig) GetInterfaceName() string {
	if x != nil {
		return x.InterfaceName
	}
	return ""
}

func (x *RsvpConfig) GetIsReachabilityName() string {
	if x != nil {
		return x.IsReachabilityName
	}
	return ""
}

func (x *RsvpConfig) GetLoopbacks() []*RsvpConfig_Loopback {
	if x != nil {
		return x.Loopbacks
	}
	return nil
}

func (x *RsvpConfig) GetBundleMessageSending() bool {
	if x != nil {
		return x.BundleMessageSending
	}
	return false
}

func (x *RsvpConfig) GetRefreshReduction() bool {
	if x != nil {
		return x.RefreshReduction
	}
	return false
}

type DhcpV6Client struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DhcpV6Client) Reset() {
	*x = DhcpV6Client{}
	mi := &file_ate_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DhcpV6Client) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DhcpV6Client) ProtoMessage() {}

func (x *DhcpV6Client) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DhcpV6Client.ProtoReflect.Descriptor instead.
func (*DhcpV6Client) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{17}
}

type DhcpV6Server struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LeaseAddrs    *AddressRange          `protobuf:"bytes,1,opt,name=lease_addrs,json=leaseAddrs,proto3" json:"lease_addrs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DhcpV6Server) Reset() {
	*x = DhcpV6Server{}
	mi := &file_ate_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DhcpV6Server) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DhcpV6Server) ProtoMessage() {}

func (x *DhcpV6Server) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DhcpV6Server.ProtoReflect.Descriptor instead.
func (*DhcpV6Server) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{18}
}

func (x *DhcpV6Server) GetLeaseAddrs() *AddressRange {
	if x != nil {
		return x.LeaseAddrs
	}
	return nil
}

type Network struct {
	state             protoimpl.MessageState     `protogen:"open.v1"`
	Name              string                     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	InterfaceName     string                     `protobuf:"bytes,2,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	Eth               *NetworkEth                `protobuf:"bytes,3,opt,name=eth,proto3" json:"eth,omitempty"`
	Ipv4              *NetworkIp                 `protobuf:"bytes,4,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Ipv6              *NetworkIp                 `protobuf:"bytes,5,opt,name=ipv6,proto3" json:"ipv6,omitempty"`
	BgpAttributes     *BgpAttributes             `protobuf:"bytes,6,opt,name=bgp_attributes,json=bgpAttributes,proto3" json:"bgp_attributes,omitempty"`
	Isis              *IPReachability            `protobuf:"bytes,7,opt,name=isis,proto3" json:"isis,omitempty"`
	ImportedBgpRoutes *Network_ImportedBgpRoutes `protobuf:"bytes,8,opt,name=imported_bgp_routes,json=importedBgpRoutes,proto3" json:"imported_bgp_routes,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *Network) Reset() {
	*x = Network{}
	mi := &file_ate_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Network) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Network) ProtoMessage() {}

func (x *Network) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Network.ProtoReflect.Descriptor instead.
func (*Network) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{19}
}

func (x *Network) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Network) GetInterfaceName() string {
	if x != nil {
		return x.InterfaceName
	}
	return ""
}

func (x *Network) GetEth() *NetworkEth {
	if x != nil {
		return x.Eth
	}
	return nil
}

func (x *Network) GetIpv4() *NetworkIp {
	if x != nil {
		return x.Ipv4
	}
	return nil
}

func (x *Network) GetIpv6() *NetworkIp {
	if x != nil {
		return x.Ipv6
	}
	return nil
}

func (x *Network) GetBgpAttributes() *BgpAttributes {
	if x != nil {
		return x.BgpAttributes
	}
	return nil
}

func (x *Network) GetIsis() *IPReachability {
	if x != nil {
		return x.Isis
	}
	return nil
}

func (x *Network) GetImportedBgpRoutes() *Network_ImportedBgpRoutes {
	if x != nil {
		return x.ImportedBgpRoutes
	}
	return nil
}

type NetworkEth struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	MacAddress string                 `protobuf:"bytes,1,opt,name=mac_address,json=macAddress,proto3" json:"mac_address,omitempty"`
	Count      uint32                 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	// Note that this is only a 12-bit value in the protocol.
	VlanId        uint32 `protobuf:"varint,3,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkEth) Reset() {
	*x = NetworkEth{}
	mi := &file_ate_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkEth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkEth) ProtoMessage() {}

func (x *NetworkEth) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkEth.ProtoReflect.Descriptor instead.
func (*NetworkEth) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{20}
}

func (x *NetworkEth) GetMacAddress() string {
	if x != nil {
		return x.MacAddress
	}
	return ""
}

func (x *NetworkEth) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *NetworkEth) GetVlanId() uint32 {
	if x != nil {
		return x.VlanId
	}
	return 0
}

type NetworkIp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AddressCidr   string                 `protobuf:"bytes,1,opt,name=address_cidr,json=addressCidr,proto3" json:"address_cidr,omitempty"`
	Count         uint32                 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkIp) Reset() {
	*x = NetworkIp{}
	mi := &file_ate_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkIp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkIp) ProtoMessage() {}

func (x *NetworkIp) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkIp.ProtoReflect.Descriptor instead.
func (*NetworkIp) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{21}
}

func (x *NetworkIp) GetAddressCidr() string {
	if x != nil {
		return x.AddressCidr
	}
	return ""
}

func (x *NetworkIp) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// A traffic flow.
type Flow struct {
	state                  protoimpl.MessageState       `protogen:"open.v1"`
	Name                   string                       `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	SrcEndpoints           []*Flow_Endpoint             `protobuf:"bytes,10,rep,name=src_endpoints,json=srcEndpoints,proto3" json:"src_endpoints,omitempty"`
	DstEndpoints           []*Flow_Endpoint             `protobuf:"bytes,11,rep,name=dst_endpoints,json=dstEndpoints,proto3" json:"dst_endpoints,omitempty"`
	Headers                []*Header                    `protobuf:"bytes,20,rep,name=headers,proto3" json:"headers,omitempty"`
	FrameRate              *FrameRate                   `protobuf:"bytes,30,opt,name=frame_rate,json=frameRate,proto3" json:"frame_rate,omitempty"`
	EgressTracking         *EgressTracking              `protobuf:"bytes,40,opt,name=egress_tracking,json=egressTracking,proto3" json:"egress_tracking,omitempty"`
	IngressTrackingFilters *Flow_IngressTrackingFilters `protobuf:"bytes,50,opt,name=ingress_tracking_filters,json=ingressTrackingFilters,proto3" json:"ingress_tracking_filters,omitempty"`
	FrameSize              *FrameSize                   `protobuf:"bytes,51,opt,name=frame_size,json=frameSize,proto3" json:"frame_size,omitempty"`
	// If transmission is not set, it's assumed to be a Continuous transmission.
	Transmission        *Transmission `protobuf:"bytes,52,opt,name=transmission,proto3" json:"transmission,omitempty"`
	ConvergenceTracking bool          `protobuf:"varint,53,opt,name=convergence_tracking,json=convergenceTracking,proto3" json:"convergence_tracking,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *Flow) Reset() {
	*x = Flow{}
	mi := &file_ate_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Flow) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Flow) ProtoMessage() {}

func (x *Flow) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Flow.ProtoReflect.Descriptor instead.
func (*Flow) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{22}
}

func (x *Flow) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Flow) GetSrcEndpoints() []*Flow_Endpoint {
	if x != nil {
		return x.SrcEndpoints
	}
	return nil
}

func (x *Flow) GetDstEndpoints() []*Flow_Endpoint {
	if x != nil {
		return x.DstEndpoints
	}
	return nil
}

func (x *Flow) GetHeaders() []*Header {
	if x != nil {
		return x.Headers
	}
	return nil
}

func (x *Flow) GetFrameRate() *FrameRate {
	if x != nil {
		return x.FrameRate
	}
	return nil
}

func (x *Flow) GetEgressTracking() *EgressTracking {
	if x != nil {
		return x.EgressTracking
	}
	return nil
}

func (x *Flow) GetIngressTrackingFilters() *Flow_IngressTrackingFilters {
	if x != nil {
		return x.IngressTrackingFilters
	}
	return nil
}

func (x *Flow) GetFrameSize() *FrameSize {
	if x != nil {
		return x.FrameSize
	}
	return nil
}

func (x *Flow) GetTransmission() *Transmission {
	if x != nil {
		return x.Transmission
	}
	return nil
}

func (x *Flow) GetConvergenceTracking() bool {
	if x != nil {
		return x.ConvergenceTracking
	}
	return false
}

type FrameRate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*FrameRate_Percent
	//	*FrameRate_Bps
	//	*FrameRate_Fps
	Type          isFrameRate_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FrameRate) Reset() {
	*x = FrameRate{}
	mi := &file_ate_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FrameRate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FrameRate) ProtoMessage() {}

func (x *FrameRate) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FrameRate.ProtoReflect.Descriptor instead.
func (*FrameRate) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{23}
}

func (x *FrameRate) GetType() isFrameRate_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *FrameRate) GetPercent() float64 {
	if x != nil {
		if x, ok := x.Type.(*FrameRate_Percent); ok {
			return x.Percent
		}
	}
	return 0
}

func (x *FrameRate) GetBps() uint64 {
	if x != nil {
		if x, ok := x.Type.(*FrameRate_Bps); ok {
			return x.Bps
		}
	}
	return 0
}

func (x *FrameRate) GetFps() uint64 {
	if x != nil {
		if x, ok := x.Type.(*FrameRate_Fps); ok {
			return x.Fps
		}
	}
	return 0
}

type isFrameRate_Type interface {
	isFrameRate_Type()
}

type FrameRate_Percent struct {
	Percent float64 `protobuf:"fixed64,1,opt,name=percent,proto3,oneof"` // percent will be truncated to 4 decimals.
}

type FrameRate_Bps struct {
	Bps uint64 `protobuf:"varint,2,opt,name=bps,proto3,oneof"`
}

type FrameRate_Fps struct {
	Fps uint64 `protobuf:"varint,3,opt,name=fps,proto3,oneof"`
}

func (*FrameRate_Percent) isFrameRate_Type() {}

func (*FrameRate_Bps) isFrameRate_Type() {}

func (*FrameRate_Fps) isFrameRate_Type() {}

type FrameSize struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*FrameSize_Fixed
	//	*FrameSize_Random_
	//	*FrameSize_ImixPreset_
	//	*FrameSize_ImixCustom_
	Type          isFrameSize_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FrameSize) Reset() {
	*x = FrameSize{}
	mi := &file_ate_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FrameSize) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FrameSize) ProtoMessage() {}

func (x *FrameSize) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FrameSize.ProtoReflect.Descriptor instead.
func (*FrameSize) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{24}
}

func (x *FrameSize) GetType() isFrameSize_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *FrameSize) GetFixed() uint32 {
	if x != nil {
		if x, ok := x.Type.(*FrameSize_Fixed); ok {
			return x.Fixed
		}
	}
	return 0
}

func (x *FrameSize) GetRandom() *FrameSize_Random {
	if x != nil {
		if x, ok := x.Type.(*FrameSize_Random_); ok {
			return x.Random
		}
	}
	return nil
}

func (x *FrameSize) GetImixPreset() FrameSize_ImixPreset {
	if x != nil {
		if x, ok := x.Type.(*FrameSize_ImixPreset_); ok {
			return x.ImixPreset
		}
	}
	return FrameSize_IMIX_UNKNOWN
}

func (x *FrameSize) GetImixCustom() *FrameSize_ImixCustom {
	if x != nil {
		if x, ok := x.Type.(*FrameSize_ImixCustom_); ok {
			return x.ImixCustom
		}
	}
	return nil
}

type isFrameSize_Type interface {
	isFrameSize_Type()
}

type FrameSize_Fixed struct {
	Fixed uint32 `protobuf:"varint,1,opt,name=fixed,proto3,oneof"`
}

type FrameSize_Random_ struct {
	Random *FrameSize_Random `protobuf:"bytes,2,opt,name=random,proto3,oneof"`
}

type FrameSize_ImixPreset_ struct {
	ImixPreset FrameSize_ImixPreset `protobuf:"varint,3,opt,name=imix_preset,json=imixPreset,proto3,enum=ondatra.FrameSize_ImixPreset,oneof"`
}

type FrameSize_ImixCustom_ struct {
	ImixCustom *FrameSize_ImixCustom `protobuf:"bytes,4,opt,name=imix_custom,json=imixCustom,proto3,oneof"`
}

func (*FrameSize_Fixed) isFrameSize_Type() {}

func (*FrameSize_Random_) isFrameSize_Type() {}

func (*FrameSize_ImixPreset_) isFrameSize_Type() {}

func (*FrameSize_ImixCustom_) isFrameSize_Type() {}

type Transmission struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Pattern         Transmission_Pattern   `protobuf:"varint,1,opt,name=pattern,proto3,enum=ondatra.Transmission_Pattern" json:"pattern,omitempty"`
	MinGapBytes     uint32                 `protobuf:"varint,2,opt,name=min_gap_bytes,json=minGapBytes,proto3" json:"min_gap_bytes,omitempty"`
	PacketsPerBurst uint32                 `protobuf:"varint,3,opt,name=packets_per_burst,json=packetsPerBurst,proto3" json:"packets_per_burst,omitempty"`
	// Types that are valid to be assigned to InterburstGap:
	//
	//	*Transmission_Nanoseconds
	//	*Transmission_Bytes
	InterburstGap isTransmission_InterburstGap `protobuf_oneof:"interburst_gap"`
	FrameCount    uint32                       `protobuf:"varint,6,opt,name=frame_count,json=frameCount,proto3" json:"frame_count,omitempty"`
	DurationSecs  uint32                       `protobuf:"varint,7,opt,name=duration_secs,json=durationSecs,proto3" json:"duration_secs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Transmission) Reset() {
	*x = Transmission{}
	mi := &file_ate_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Transmission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Transmission) ProtoMessage() {}

func (x *Transmission) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Transmission.ProtoReflect.Descriptor instead.
func (*Transmission) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{25}
}

func (x *Transmission) GetPattern() Transmission_Pattern {
	if x != nil {
		return x.Pattern
	}
	return Transmission_PATTERN_UNSPECIFIED
}

func (x *Transmission) GetMinGapBytes() uint32 {
	if x != nil {
		return x.MinGapBytes
	}
	return 0
}

func (x *Transmission) GetPacketsPerBurst() uint32 {
	if x != nil {
		return x.PacketsPerBurst
	}
	return 0
}

func (x *Transmission) GetInterburstGap() isTransmission_InterburstGap {
	if x != nil {
		return x.InterburstGap
	}
	return nil
}

func (x *Transmission) GetNanoseconds() uint32 {
	if x != nil {
		if x, ok := x.InterburstGap.(*Transmission_Nanoseconds); ok {
			return x.Nanoseconds
		}
	}
	return 0
}

func (x *Transmission) GetBytes() uint32 {
	if x != nil {
		if x, ok := x.InterburstGap.(*Transmission_Bytes); ok {
			return x.Bytes
		}
	}
	return 0
}

func (x *Transmission) GetFrameCount() uint32 {
	if x != nil {
		return x.FrameCount
	}
	return 0
}

func (x *Transmission) GetDurationSecs() uint32 {
	if x != nil {
		return x.DurationSecs
	}
	return 0
}

type isTransmission_InterburstGap interface {
	isTransmission_InterburstGap()
}

type Transmission_Nanoseconds struct {
	Nanoseconds uint32 `protobuf:"varint,4,opt,name=nanoseconds,proto3,oneof"`
}

type Transmission_Bytes struct {
	Bytes uint32 `protobuf:"varint,5,opt,name=bytes,proto3,oneof"`
}

func (*Transmission_Nanoseconds) isTransmission_InterburstGap() {}

func (*Transmission_Bytes) isTransmission_InterburstGap() {}

type EgressTracking struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	Offset        uint32                 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	Width         uint32                 `protobuf:"varint,3,opt,name=width,proto3" json:"width,omitempty"`
	Count         uint32                 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EgressTracking) Reset() {
	*x = EgressTracking{}
	mi := &file_ate_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EgressTracking) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EgressTracking) ProtoMessage() {}

func (x *EgressTracking) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EgressTracking.ProtoReflect.Descriptor instead.
func (*EgressTracking) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{26}
}

func (x *EgressTracking) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

func (x *EgressTracking) GetOffset() uint32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *EgressTracking) GetWidth() uint32 {
	if x != nil {
		return x.Width
	}
	return 0
}

func (x *EgressTracking) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

// A packet header.
type Header struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*Header_Eth
	//	*Header_Gre
	//	*Header_Ipv4
	//	*Header_Ipv6
	//	*Header_Mpls
	//	*Header_Tcp
	//	*Header_Udp
	//	*Header_Http
	//	*Header_Icmp
	//	*Header_Ospf
	//	*Header_Rsvp
	//	*Header_Pim
	//	*Header_Ldp
	//	*Header_Macsec
	//	*Header_Esp
	//	*Header_EspOverMacsec
	//	*Header_PwMplsControlWord
	Type          isHeader_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Header) Reset() {
	*x = Header{}
	mi := &file_ate_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Header) ProtoMessage() {}

func (x *Header) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Header.ProtoReflect.Descriptor instead.
func (*Header) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{27}
}

func (x *Header) GetType() isHeader_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *Header) GetEth() *EthernetHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Eth); ok {
			return x.Eth
		}
	}
	return nil
}

func (x *Header) GetGre() *GreHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Gre); ok {
			return x.Gre
		}
	}
	return nil
}

func (x *Header) GetIpv4() *Ipv4Header {
	if x != nil {
		if x, ok := x.Type.(*Header_Ipv4); ok {
			return x.Ipv4
		}
	}
	return nil
}

func (x *Header) GetIpv6() *Ipv6Header {
	if x != nil {
		if x, ok := x.Type.(*Header_Ipv6); ok {
			return x.Ipv6
		}
	}
	return nil
}

func (x *Header) GetMpls() *MplsHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Mpls); ok {
			return x.Mpls
		}
	}
	return nil
}

func (x *Header) GetTcp() *TcpHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Tcp); ok {
			return x.Tcp
		}
	}
	return nil
}

func (x *Header) GetUdp() *UdpHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Udp); ok {
			return x.Udp
		}
	}
	return nil
}

func (x *Header) GetHttp() *HttpHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Http); ok {
			return x.Http
		}
	}
	return nil
}

func (x *Header) GetIcmp() *IcmpHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Icmp); ok {
			return x.Icmp
		}
	}
	return nil
}

func (x *Header) GetOspf() *OspfHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Ospf); ok {
			return x.Ospf
		}
	}
	return nil
}

func (x *Header) GetRsvp() *RsvpHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Rsvp); ok {
			return x.Rsvp
		}
	}
	return nil
}

func (x *Header) GetPim() *PimHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Pim); ok {
			return x.Pim
		}
	}
	return nil
}

func (x *Header) GetLdp() *LdpHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Ldp); ok {
			return x.Ldp
		}
	}
	return nil
}

func (x *Header) GetMacsec() *MacsecHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Macsec); ok {
			return x.Macsec
		}
	}
	return nil
}

func (x *Header) GetEsp() *EspHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_Esp); ok {
			return x.Esp
		}
	}
	return nil
}

func (x *Header) GetEspOverMacsec() *EspOverMacSecHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_EspOverMacsec); ok {
			return x.EspOverMacsec
		}
	}
	return nil
}

func (x *Header) GetPwMplsControlWord() *PwMplsControlWordHeader {
	if x != nil {
		if x, ok := x.Type.(*Header_PwMplsControlWord); ok {
			return x.PwMplsControlWord
		}
	}
	return nil
}

type isHeader_Type interface {
	isHeader_Type()
}

type Header_Eth struct {
	Eth *EthernetHeader `protobuf:"bytes,1,opt,name=eth,proto3,oneof"`
}

type Header_Gre struct {
	Gre *GreHeader `protobuf:"bytes,2,opt,name=gre,proto3,oneof"`
}

type Header_Ipv4 struct {
	Ipv4 *Ipv4Header `protobuf:"bytes,3,opt,name=ipv4,proto3,oneof"`
}

type Header_Ipv6 struct {
	Ipv6 *Ipv6Header `protobuf:"bytes,4,opt,name=ipv6,proto3,oneof"`
}

type Header_Mpls struct {
	Mpls *MplsHeader `protobuf:"bytes,5,opt,name=mpls,proto3,oneof"`
}

type Header_Tcp struct {
	Tcp *TcpHeader `protobuf:"bytes,6,opt,name=tcp,proto3,oneof"`
}

type Header_Udp struct {
	Udp *UdpHeader `protobuf:"bytes,7,opt,name=udp,proto3,oneof"`
}

type Header_Http struct {
	Http *HttpHeader `protobuf:"bytes,8,opt,name=http,proto3,oneof"`
}

type Header_Icmp struct {
	Icmp *IcmpHeader `protobuf:"bytes,9,opt,name=icmp,proto3,oneof"`
}

type Header_Ospf struct {
	Ospf *OspfHeader `protobuf:"bytes,10,opt,name=ospf,proto3,oneof"`
}

type Header_Rsvp struct {
	Rsvp *RsvpHeader `protobuf:"bytes,11,opt,name=rsvp,proto3,oneof"`
}

type Header_Pim struct {
	Pim *PimHeader `protobuf:"bytes,12,opt,name=pim,proto3,oneof"`
}

type Header_Ldp struct {
	Ldp *LdpHeader `protobuf:"bytes,13,opt,name=ldp,proto3,oneof"`
}

type Header_Macsec struct {
	Macsec *MacsecHeader `protobuf:"bytes,14,opt,name=macsec,proto3,oneof"`
}

type Header_Esp struct {
	Esp *EspHeader `protobuf:"bytes,15,opt,name=esp,proto3,oneof"`
}

type Header_EspOverMacsec struct {
	EspOverMacsec *EspOverMacSecHeader `protobuf:"bytes,16,opt,name=esp_over_macsec,json=espOverMacsec,proto3,oneof"`
}

type Header_PwMplsControlWord struct {
	PwMplsControlWord *PwMplsControlWordHeader `protobuf:"bytes,17,opt,name=pw_mpls_control_word,json=pwMplsControlWord,proto3,oneof"`
}

func (*Header_Eth) isHeader_Type() {}

func (*Header_Gre) isHeader_Type() {}

func (*Header_Ipv4) isHeader_Type() {}

func (*Header_Ipv6) isHeader_Type() {}

func (*Header_Mpls) isHeader_Type() {}

func (*Header_Tcp) isHeader_Type() {}

func (*Header_Udp) isHeader_Type() {}

func (*Header_Http) isHeader_Type() {}

func (*Header_Icmp) isHeader_Type() {}

func (*Header_Ospf) isHeader_Type() {}

func (*Header_Rsvp) isHeader_Type() {}

func (*Header_Pim) isHeader_Type() {}

func (*Header_Ldp) isHeader_Type() {}

func (*Header_Macsec) isHeader_Type() {}

func (*Header_Esp) isHeader_Type() {}

func (*Header_EspOverMacsec) isHeader_Type() {}

func (*Header_PwMplsControlWord) isHeader_Type() {}

type EthernetHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SrcAddr       *AddressRange          `protobuf:"bytes,1,opt,name=src_addr,json=srcAddr,proto3" json:"src_addr,omitempty"`
	DstAddr       *AddressRange          `protobuf:"bytes,2,opt,name=dst_addr,json=dstAddr,proto3" json:"dst_addr,omitempty"`
	VlanId        uint32                 `protobuf:"varint,3,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	BadCrc        bool                   `protobuf:"varint,4,opt,name=bad_crc,json=badCrc,proto3" json:"bad_crc,omitempty"`
	EtherType     uint32                 `protobuf:"varint,5,opt,name=ether_type,json=etherType,proto3" json:"ether_type,omitempty"`
	ProtocolId    uint32                 `protobuf:"varint,6,opt,name=protocol_id,json=protocolId,proto3" json:"protocol_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EthernetHeader) Reset() {
	*x = EthernetHeader{}
	mi := &file_ate_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EthernetHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EthernetHeader) ProtoMessage() {}

func (x *EthernetHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EthernetHeader.ProtoReflect.Descriptor instead.
func (*EthernetHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{28}
}

func (x *EthernetHeader) GetSrcAddr() *AddressRange {
	if x != nil {
		return x.SrcAddr
	}
	return nil
}

func (x *EthernetHeader) GetDstAddr() *AddressRange {
	if x != nil {
		return x.DstAddr
	}
	return nil
}

func (x *EthernetHeader) GetVlanId() uint32 {
	if x != nil {
		return x.VlanId
	}
	return 0
}

func (x *EthernetHeader) GetBadCrc() bool {
	if x != nil {
		return x.BadCrc
	}
	return false
}

func (x *EthernetHeader) GetEtherType() uint32 {
	if x != nil {
		return x.EtherType
	}
	return 0
}

func (x *EthernetHeader) GetProtocolId() uint32 {
	if x != nil {
		return x.ProtocolId
	}
	return 0
}

type GreHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           uint32                 `protobuf:"varint,1,opt,name=key,proto3" json:"key,omitempty"`
	Seq           uint32                 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GreHeader) Reset() {
	*x = GreHeader{}
	mi := &file_ate_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GreHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GreHeader) ProtoMessage() {}

func (x *GreHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GreHeader.ProtoReflect.Descriptor instead.
func (*GreHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{29}
}

func (x *GreHeader) GetKey() uint32 {
	if x != nil {
		return x.Key
	}
	return 0
}

func (x *GreHeader) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

type Ipv4Header struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Dscp           uint32                 `protobuf:"varint,1,opt,name=dscp,proto3" json:"dscp,omitempty"`
	Ecn            uint32                 `protobuf:"varint,2,opt,name=ecn,proto3" json:"ecn,omitempty"`
	Identification uint32                 `protobuf:"varint,3,opt,name=identification,proto3" json:"identification,omitempty"`
	DontFragment   bool                   `protobuf:"varint,4,opt,name=dont_fragment,json=dontFragment,proto3" json:"dont_fragment,omitempty"`
	MoreFragments  bool                   `protobuf:"varint,5,opt,name=more_fragments,json=moreFragments,proto3" json:"more_fragments,omitempty"`
	FragmentOffset uint32                 `protobuf:"varint,6,opt,name=fragment_offset,json=fragmentOffset,proto3" json:"fragment_offset,omitempty"`
	Ttl            *uint32                `protobuf:"varint,7,opt,name=ttl,proto3,oneof" json:"ttl,omitempty"`
	Protocol       *uint32                `protobuf:"varint,8,opt,name=protocol,proto3,oneof" json:"protocol,omitempty"`
	Checksum       uint32                 `protobuf:"varint,9,opt,name=checksum,proto3" json:"checksum,omitempty"`
	SrcAddr        *AddressRange          `protobuf:"bytes,10,opt,name=src_addr,json=srcAddr,proto3" json:"src_addr,omitempty"`
	DstAddr        *AddressRange          `protobuf:"bytes,11,opt,name=dst_addr,json=dstAddr,proto3" json:"dst_addr,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *Ipv4Header) Reset() {
	*x = Ipv4Header{}
	mi := &file_ate_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ipv4Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ipv4Header) ProtoMessage() {}

func (x *Ipv4Header) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ipv4Header.ProtoReflect.Descriptor instead.
func (*Ipv4Header) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{30}
}

func (x *Ipv4Header) GetDscp() uint32 {
	if x != nil {
		return x.Dscp
	}
	return 0
}

func (x *Ipv4Header) GetEcn() uint32 {
	if x != nil {
		return x.Ecn
	}
	return 0
}

func (x *Ipv4Header) GetIdentification() uint32 {
	if x != nil {
		return x.Identification
	}
	return 0
}

func (x *Ipv4Header) GetDontFragment() bool {
	if x != nil {
		return x.DontFragment
	}
	return false
}

func (x *Ipv4Header) GetMoreFragments() bool {
	if x != nil {
		return x.MoreFragments
	}
	return false
}

func (x *Ipv4Header) GetFragmentOffset() uint32 {
	if x != nil {
		return x.FragmentOffset
	}
	return 0
}

func (x *Ipv4Header) GetTtl() uint32 {
	if x != nil && x.Ttl != nil {
		return *x.Ttl
	}
	return 0
}

func (x *Ipv4Header) GetProtocol() uint32 {
	if x != nil && x.Protocol != nil {
		return *x.Protocol
	}
	return 0
}

func (x *Ipv4Header) GetChecksum() uint32 {
	if x != nil {
		return x.Checksum
	}
	return 0
}

func (x *Ipv4Header) GetSrcAddr() *AddressRange {
	if x != nil {
		return x.SrcAddr
	}
	return nil
}

func (x *Ipv4Header) GetDstAddr() *AddressRange {
	if x != nil {
		return x.DstAddr
	}
	return nil
}

type Ipv6Header struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SrcAddr       *AddressRange          `protobuf:"bytes,1,opt,name=src_addr,json=srcAddr,proto3" json:"src_addr,omitempty"`
	DstAddr       *AddressRange          `protobuf:"bytes,2,opt,name=dst_addr,json=dstAddr,proto3" json:"dst_addr,omitempty"`
	HopLimit      *uint32                `protobuf:"varint,3,opt,name=hop_limit,json=hopLimit,proto3,oneof" json:"hop_limit,omitempty"`
	FlowLabel     *UIntRange             `protobuf:"bytes,4,opt,name=flow_label,json=flowLabel,proto3" json:"flow_label,omitempty"`
	Dscp          uint32                 `protobuf:"varint,5,opt,name=dscp,proto3" json:"dscp,omitempty"`
	Ecn           uint32                 `protobuf:"varint,6,opt,name=ecn,proto3" json:"ecn,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ipv6Header) Reset() {
	*x = Ipv6Header{}
	mi := &file_ate_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ipv6Header) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ipv6Header) ProtoMessage() {}

func (x *Ipv6Header) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ipv6Header.ProtoReflect.Descriptor instead.
func (*Ipv6Header) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{31}
}

func (x *Ipv6Header) GetSrcAddr() *AddressRange {
	if x != nil {
		return x.SrcAddr
	}
	return nil
}

func (x *Ipv6Header) GetDstAddr() *AddressRange {
	if x != nil {
		return x.DstAddr
	}
	return nil
}

func (x *Ipv6Header) GetHopLimit() uint32 {
	if x != nil && x.HopLimit != nil {
		return *x.HopLimit
	}
	return 0
}

func (x *Ipv6Header) GetFlowLabel() *UIntRange {
	if x != nil {
		return x.FlowLabel
	}
	return nil
}

func (x *Ipv6Header) GetDscp() uint32 {
	if x != nil {
		return x.Dscp
	}
	return 0
}

func (x *Ipv6Header) GetEcn() uint32 {
	if x != nil {
		return x.Ecn
	}
	return 0
}

type MplsHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Label         *UIntRange             `protobuf:"bytes,1,opt,name=label,proto3" json:"label,omitempty"`
	Exp           uint32                 `protobuf:"varint,2,opt,name=exp,proto3" json:"exp,omitempty"`
	Ttl           uint32                 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MplsHeader) Reset() {
	*x = MplsHeader{}
	mi := &file_ate_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MplsHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MplsHeader) ProtoMessage() {}

func (x *MplsHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MplsHeader.ProtoReflect.Descriptor instead.
func (*MplsHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{32}
}

func (x *MplsHeader) GetLabel() *UIntRange {
	if x != nil {
		return x.Label
	}
	return nil
}

func (x *MplsHeader) GetExp() uint32 {
	if x != nil {
		return x.Exp
	}
	return 0
}

func (x *MplsHeader) GetTtl() uint32 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

type PwMplsControlWordHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CwRsvd        uint32                 `protobuf:"varint,1,opt,name=cw_rsvd,json=cwRsvd,proto3" json:"cw_rsvd,omitempty"`
	CwFlags       uint32                 `protobuf:"varint,2,opt,name=cw_flags,json=cwFlags,proto3" json:"cw_flags,omitempty"`
	CwFrg         uint32                 `protobuf:"varint,3,opt,name=cw_frg,json=cwFrg,proto3" json:"cw_frg,omitempty"`
	CwSeq         uint32                 `protobuf:"varint,4,opt,name=cw_seq,json=cwSeq,proto3" json:"cw_seq,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PwMplsControlWordHeader) Reset() {
	*x = PwMplsControlWordHeader{}
	mi := &file_ate_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PwMplsControlWordHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PwMplsControlWordHeader) ProtoMessage() {}

func (x *PwMplsControlWordHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PwMplsControlWordHeader.ProtoReflect.Descriptor instead.
func (*PwMplsControlWordHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{33}
}

func (x *PwMplsControlWordHeader) GetCwRsvd() uint32 {
	if x != nil {
		return x.CwRsvd
	}
	return 0
}

func (x *PwMplsControlWordHeader) GetCwFlags() uint32 {
	if x != nil {
		return x.CwFlags
	}
	return 0
}

func (x *PwMplsControlWordHeader) GetCwFrg() uint32 {
	if x != nil {
		return x.CwFrg
	}
	return 0
}

func (x *PwMplsControlWordHeader) GetCwSeq() uint32 {
	if x != nil {
		return x.CwSeq
	}
	return 0
}

type TcpHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SrcPort       *UIntRange             `protobuf:"bytes,1,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstPort       *UIntRange             `protobuf:"bytes,2,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	Seq           uint32                 `protobuf:"varint,3,opt,name=seq,proto3" json:"seq,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TcpHeader) Reset() {
	*x = TcpHeader{}
	mi := &file_ate_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TcpHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TcpHeader) ProtoMessage() {}

func (x *TcpHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TcpHeader.ProtoReflect.Descriptor instead.
func (*TcpHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{34}
}

func (x *TcpHeader) GetSrcPort() *UIntRange {
	if x != nil {
		return x.SrcPort
	}
	return nil
}

func (x *TcpHeader) GetDstPort() *UIntRange {
	if x != nil {
		return x.DstPort
	}
	return nil
}

func (x *TcpHeader) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

type UdpHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SrcPort       *UIntRange             `protobuf:"bytes,1,opt,name=src_port,json=srcPort,proto3" json:"src_port,omitempty"`
	DstPort       *UIntRange             `protobuf:"bytes,2,opt,name=dst_port,json=dstPort,proto3" json:"dst_port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UdpHeader) Reset() {
	*x = UdpHeader{}
	mi := &file_ate_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UdpHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UdpHeader) ProtoMessage() {}

func (x *UdpHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UdpHeader.ProtoReflect.Descriptor instead.
func (*UdpHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{35}
}

func (x *UdpHeader) GetSrcPort() *UIntRange {
	if x != nil {
		return x.SrcPort
	}
	return nil
}

func (x *UdpHeader) GetDstPort() *UIntRange {
	if x != nil {
		return x.DstPort
	}
	return nil
}

type HttpHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HttpHeader) Reset() {
	*x = HttpHeader{}
	mi := &file_ate_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HttpHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HttpHeader) ProtoMessage() {}

func (x *HttpHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HttpHeader.ProtoReflect.Descriptor instead.
func (*HttpHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{36}
}

type IcmpHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*IcmpHeader_EchoReply_
	//	*IcmpHeader_DestinationUnreachable_
	//	*IcmpHeader_RedirectMessage_
	//	*IcmpHeader_EchoRequest_
	//	*IcmpHeader_TimeExceeded_
	//	*IcmpHeader_ParameterProblem_
	//	*IcmpHeader_Timestamp_
	//	*IcmpHeader_TimestampReply_
	Type          isIcmpHeader_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader) Reset() {
	*x = IcmpHeader{}
	mi := &file_ate_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader) ProtoMessage() {}

func (x *IcmpHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader.ProtoReflect.Descriptor instead.
func (*IcmpHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37}
}

func (x *IcmpHeader) GetType() isIcmpHeader_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *IcmpHeader) GetEchoReply() *IcmpHeader_EchoReply {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_EchoReply_); ok {
			return x.EchoReply
		}
	}
	return nil
}

func (x *IcmpHeader) GetDestinationUnreachable() *IcmpHeader_DestinationUnreachable {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_DestinationUnreachable_); ok {
			return x.DestinationUnreachable
		}
	}
	return nil
}

func (x *IcmpHeader) GetRedirectMessage() *IcmpHeader_RedirectMessage {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_RedirectMessage_); ok {
			return x.RedirectMessage
		}
	}
	return nil
}

func (x *IcmpHeader) GetEchoRequest() *IcmpHeader_EchoRequest {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_EchoRequest_); ok {
			return x.EchoRequest
		}
	}
	return nil
}

func (x *IcmpHeader) GetTimeExceeded() *IcmpHeader_TimeExceeded {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_TimeExceeded_); ok {
			return x.TimeExceeded
		}
	}
	return nil
}

func (x *IcmpHeader) GetParameterProblem() *IcmpHeader_ParameterProblem {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_ParameterProblem_); ok {
			return x.ParameterProblem
		}
	}
	return nil
}

func (x *IcmpHeader) GetTimestamp() *IcmpHeader_Timestamp {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_Timestamp_); ok {
			return x.Timestamp
		}
	}
	return nil
}

func (x *IcmpHeader) GetTimestampReply() *IcmpHeader_TimestampReply {
	if x != nil {
		if x, ok := x.Type.(*IcmpHeader_TimestampReply_); ok {
			return x.TimestampReply
		}
	}
	return nil
}

type isIcmpHeader_Type interface {
	isIcmpHeader_Type()
}

type IcmpHeader_EchoReply_ struct {
	EchoReply *IcmpHeader_EchoReply `protobuf:"bytes,1,opt,name=echo_reply,json=echoReply,proto3,oneof"`
}

type IcmpHeader_DestinationUnreachable_ struct {
	DestinationUnreachable *IcmpHeader_DestinationUnreachable `protobuf:"bytes,2,opt,name=destination_unreachable,json=destinationUnreachable,proto3,oneof"`
}

type IcmpHeader_RedirectMessage_ struct {
	RedirectMessage *IcmpHeader_RedirectMessage `protobuf:"bytes,3,opt,name=redirect_message,json=redirectMessage,proto3,oneof"`
}

type IcmpHeader_EchoRequest_ struct {
	EchoRequest *IcmpHeader_EchoRequest `protobuf:"bytes,4,opt,name=echo_request,json=echoRequest,proto3,oneof"`
}

type IcmpHeader_TimeExceeded_ struct {
	TimeExceeded *IcmpHeader_TimeExceeded `protobuf:"bytes,5,opt,name=time_exceeded,json=timeExceeded,proto3,oneof"`
}

type IcmpHeader_ParameterProblem_ struct {
	ParameterProblem *IcmpHeader_ParameterProblem `protobuf:"bytes,6,opt,name=parameter_problem,json=parameterProblem,proto3,oneof"`
}

type IcmpHeader_Timestamp_ struct {
	Timestamp *IcmpHeader_Timestamp `protobuf:"bytes,7,opt,name=timestamp,proto3,oneof"`
}

type IcmpHeader_TimestampReply_ struct {
	TimestampReply *IcmpHeader_TimestampReply `protobuf:"bytes,8,opt,name=timestamp_reply,json=timestampReply,proto3,oneof"`
}

func (*IcmpHeader_EchoReply_) isIcmpHeader_Type() {}

func (*IcmpHeader_DestinationUnreachable_) isIcmpHeader_Type() {}

func (*IcmpHeader_RedirectMessage_) isIcmpHeader_Type() {}

func (*IcmpHeader_EchoRequest_) isIcmpHeader_Type() {}

func (*IcmpHeader_TimeExceeded_) isIcmpHeader_Type() {}

func (*IcmpHeader_ParameterProblem_) isIcmpHeader_Type() {}

func (*IcmpHeader_Timestamp_) isIcmpHeader_Type() {}

func (*IcmpHeader_TimestampReply_) isIcmpHeader_Type() {}

type OspfHeader struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	RouterId string                 `protobuf:"bytes,1,opt,name=router_id,json=routerId,proto3" json:"router_id,omitempty"`
	AreaId   string                 `protobuf:"bytes,2,opt,name=area_id,json=areaId,proto3" json:"area_id,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*OspfHeader_Hello_
	//	*OspfHeader_Dbd
	//	*OspfHeader_Lsr
	//	*OspfHeader_Lsu
	//	*OspfHeader_Lsa
	Type          isOspfHeader_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OspfHeader) Reset() {
	*x = OspfHeader{}
	mi := &file_ate_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader) ProtoMessage() {}

func (x *OspfHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader.ProtoReflect.Descriptor instead.
func (*OspfHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38}
}

func (x *OspfHeader) GetRouterId() string {
	if x != nil {
		return x.RouterId
	}
	return ""
}

func (x *OspfHeader) GetAreaId() string {
	if x != nil {
		return x.AreaId
	}
	return ""
}

func (x *OspfHeader) GetType() isOspfHeader_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *OspfHeader) GetHello() *OspfHeader_Hello {
	if x != nil {
		if x, ok := x.Type.(*OspfHeader_Hello_); ok {
			return x.Hello
		}
	}
	return nil
}

func (x *OspfHeader) GetDbd() *OspfHeader_DatabaseDescription {
	if x != nil {
		if x, ok := x.Type.(*OspfHeader_Dbd); ok {
			return x.Dbd
		}
	}
	return nil
}

func (x *OspfHeader) GetLsr() *OspfHeader_LinkStateRequest {
	if x != nil {
		if x, ok := x.Type.(*OspfHeader_Lsr); ok {
			return x.Lsr
		}
	}
	return nil
}

func (x *OspfHeader) GetLsu() *OspfHeader_LinkStateUpdate {
	if x != nil {
		if x, ok := x.Type.(*OspfHeader_Lsu); ok {
			return x.Lsu
		}
	}
	return nil
}

func (x *OspfHeader) GetLsa() *OspfHeader_LinkStateAck {
	if x != nil {
		if x, ok := x.Type.(*OspfHeader_Lsa); ok {
			return x.Lsa
		}
	}
	return nil
}

type isOspfHeader_Type interface {
	isOspfHeader_Type()
}

type OspfHeader_Hello_ struct {
	Hello *OspfHeader_Hello `protobuf:"bytes,3,opt,name=hello,proto3,oneof"`
}

type OspfHeader_Dbd struct {
	Dbd *OspfHeader_DatabaseDescription `protobuf:"bytes,4,opt,name=dbd,proto3,oneof"`
}

type OspfHeader_Lsr struct {
	Lsr *OspfHeader_LinkStateRequest `protobuf:"bytes,5,opt,name=lsr,proto3,oneof"`
}

type OspfHeader_Lsu struct {
	Lsu *OspfHeader_LinkStateUpdate `protobuf:"bytes,6,opt,name=lsu,proto3,oneof"`
}

type OspfHeader_Lsa struct {
	Lsa *OspfHeader_LinkStateAck `protobuf:"bytes,7,opt,name=lsa,proto3,oneof"`
}

func (*OspfHeader_Hello_) isOspfHeader_Type() {}

func (*OspfHeader_Dbd) isOspfHeader_Type() {}

func (*OspfHeader_Lsr) isOspfHeader_Type() {}

func (*OspfHeader_Lsu) isOspfHeader_Type() {}

func (*OspfHeader_Lsa) isOspfHeader_Type() {}

type RsvpHeader struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	Version                 uint32                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	RefreshReductionCapable bool                   `protobuf:"varint,2,opt,name=refresh_reduction_capable,json=refreshReductionCapable,proto3" json:"refresh_reduction_capable,omitempty"`
	MessageType             RsvpHeader_MessageType `protobuf:"varint,3,opt,name=message_type,json=messageType,proto3,enum=ondatra.RsvpHeader_MessageType" json:"message_type,omitempty"`
	Ttl                     uint32                 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *RsvpHeader) Reset() {
	*x = RsvpHeader{}
	mi := &file_ate_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RsvpHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RsvpHeader) ProtoMessage() {}

func (x *RsvpHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RsvpHeader.ProtoReflect.Descriptor instead.
func (*RsvpHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{39}
}

func (x *RsvpHeader) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *RsvpHeader) GetRefreshReductionCapable() bool {
	if x != nil {
		return x.RefreshReductionCapable
	}
	return false
}

func (x *RsvpHeader) GetMessageType() RsvpHeader_MessageType {
	if x != nil {
		return x.MessageType
	}
	return RsvpHeader_MESSAGE_TYPE_UNSPECIFIED
}

func (x *RsvpHeader) GetTtl() uint32 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

type PimHeader struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*PimHeader_Hello_
	Type          isPimHeader_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PimHeader) Reset() {
	*x = PimHeader{}
	mi := &file_ate_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PimHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PimHeader) ProtoMessage() {}

func (x *PimHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PimHeader.ProtoReflect.Descriptor instead.
func (*PimHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{40}
}

func (x *PimHeader) GetType() isPimHeader_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *PimHeader) GetHello() *PimHeader_Hello {
	if x != nil {
		if x, ok := x.Type.(*PimHeader_Hello_); ok {
			return x.Hello
		}
	}
	return nil
}

type isPimHeader_Type interface {
	isPimHeader_Type()
}

type PimHeader_Hello_ struct {
	Hello *PimHeader_Hello `protobuf:"bytes,1,opt,name=hello,proto3,oneof"`
}

func (*PimHeader_Hello_) isPimHeader_Type() {}

type LdpHeader struct {
	state      protoimpl.MessageState `protogen:"open.v1"`
	LsrId      string                 `protobuf:"bytes,1,opt,name=lsr_id,json=lsrId,proto3" json:"lsr_id,omitempty"`
	LabelSpace uint32                 `protobuf:"varint,2,opt,name=label_space,json=labelSpace,proto3" json:"label_space,omitempty"`
	MessageId  uint32                 `protobuf:"varint,3,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*LdpHeader_Hello_
	Type          isLdpHeader_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LdpHeader) Reset() {
	*x = LdpHeader{}
	mi := &file_ate_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LdpHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LdpHeader) ProtoMessage() {}

func (x *LdpHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LdpHeader.ProtoReflect.Descriptor instead.
func (*LdpHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{41}
}

func (x *LdpHeader) GetLsrId() string {
	if x != nil {
		return x.LsrId
	}
	return ""
}

func (x *LdpHeader) GetLabelSpace() uint32 {
	if x != nil {
		return x.LabelSpace
	}
	return 0
}

func (x *LdpHeader) GetMessageId() uint32 {
	if x != nil {
		return x.MessageId
	}
	return 0
}

func (x *LdpHeader) GetType() isLdpHeader_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *LdpHeader) GetHello() *LdpHeader_Hello {
	if x != nil {
		if x, ok := x.Type.(*LdpHeader_Hello_); ok {
			return x.Hello
		}
	}
	return nil
}

type isLdpHeader_Type interface {
	isLdpHeader_Type()
}

type LdpHeader_Hello_ struct {
	Hello *LdpHeader_Hello `protobuf:"bytes,4,opt,name=hello,proto3,oneof"`
}

func (*LdpHeader_Hello_) isLdpHeader_Type() {}

type EspHeader struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	SecurityParametersIndex uint32                 `protobuf:"varint,1,opt,name=security_parameters_index,json=securityParametersIndex,proto3" json:"security_parameters_index,omitempty"`
	SequenceNumber          *UIntRange             `protobuf:"bytes,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *EspHeader) Reset() {
	*x = EspHeader{}
	mi := &file_ate_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EspHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EspHeader) ProtoMessage() {}

func (x *EspHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EspHeader.ProtoReflect.Descriptor instead.
func (*EspHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{42}
}

func (x *EspHeader) GetSecurityParametersIndex() uint32 {
	if x != nil {
		return x.SecurityParametersIndex
	}
	return 0
}

func (x *EspHeader) GetSequenceNumber() *UIntRange {
	if x != nil {
		return x.SequenceNumber
	}
	return nil
}

type EspOverMacSecHeader struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	SecurityParametersIndex uint32                 `protobuf:"varint,1,opt,name=security_parameters_index,json=securityParametersIndex,proto3" json:"security_parameters_index,omitempty"`
	SequenceNumber          *UIntRange             `protobuf:"bytes,2,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *EspOverMacSecHeader) Reset() {
	*x = EspOverMacSecHeader{}
	mi := &file_ate_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EspOverMacSecHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EspOverMacSecHeader) ProtoMessage() {}

func (x *EspOverMacSecHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EspOverMacSecHeader.ProtoReflect.Descriptor instead.
func (*EspOverMacSecHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{43}
}

func (x *EspOverMacSecHeader) GetSecurityParametersIndex() uint32 {
	if x != nil {
		return x.SecurityParametersIndex
	}
	return 0
}

func (x *EspOverMacSecHeader) GetSequenceNumber() *UIntRange {
	if x != nil {
		return x.SequenceNumber
	}
	return nil
}

type MacsecHeader struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	VlanId        uint32                 `protobuf:"varint,1,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MacsecHeader) Reset() {
	*x = MacsecHeader{}
	mi := &file_ate_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacsecHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacsecHeader) ProtoMessage() {}

func (x *MacsecHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacsecHeader.ProtoReflect.Descriptor instead.
func (*MacsecHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{44}
}

func (x *MacsecHeader) GetVlanId() uint32 {
	if x != nil {
		return x.VlanId
	}
	return 0
}

type IpAddressGenerator struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*IpAddressGenerator_List
	//	*IpAddressGenerator_Random
	Type          isIpAddressGenerator_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IpAddressGenerator) Reset() {
	*x = IpAddressGenerator{}
	mi := &file_ate_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IpAddressGenerator) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpAddressGenerator) ProtoMessage() {}

func (x *IpAddressGenerator) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpAddressGenerator.ProtoReflect.Descriptor instead.
func (*IpAddressGenerator) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{45}
}

func (x *IpAddressGenerator) GetType() isIpAddressGenerator_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *IpAddressGenerator) GetList() *IpAddressList {
	if x != nil {
		if x, ok := x.Type.(*IpAddressGenerator_List); ok {
			return x.List
		}
	}
	return nil
}

func (x *IpAddressGenerator) GetRandom() *IpAddressRandom {
	if x != nil {
		if x, ok := x.Type.(*IpAddressGenerator_Random); ok {
			return x.Random
		}
	}
	return nil
}

type isIpAddressGenerator_Type interface {
	isIpAddressGenerator_Type()
}

type IpAddressGenerator_List struct {
	List *IpAddressList `protobuf:"bytes,1,opt,name=list,proto3,oneof"`
}

type IpAddressGenerator_Random struct {
	Random *IpAddressRandom `protobuf:"bytes,2,opt,name=random,proto3,oneof"`
}

func (*IpAddressGenerator_List) isIpAddressGenerator_Type() {}

func (*IpAddressGenerator_Random) isIpAddressGenerator_Type() {}

type IpAddressList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Addrs         []string               `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IpAddressList) Reset() {
	*x = IpAddressList{}
	mi := &file_ate_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IpAddressList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpAddressList) ProtoMessage() {}

func (x *IpAddressList) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpAddressList.ProtoReflect.Descriptor instead.
func (*IpAddressList) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{46}
}

func (x *IpAddressList) GetAddrs() []string {
	if x != nil {
		return x.Addrs
	}
	return nil
}

type IpAddressRandom struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Prefix        string                 `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Count         uint32                 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IpAddressRandom) Reset() {
	*x = IpAddressRandom{}
	mi := &file_ate_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IpAddressRandom) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IpAddressRandom) ProtoMessage() {}

func (x *IpAddressRandom) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IpAddressRandom.ProtoReflect.Descriptor instead.
func (*IpAddressRandom) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{47}
}

func (x *IpAddressRandom) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *IpAddressRandom) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

type UIntRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Min           uint32                 `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	Max           uint32                 `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	Step          uint32                 `protobuf:"varint,3,opt,name=step,proto3" json:"step,omitempty"`
	Count         uint32                 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Random        bool                   `protobuf:"varint,5,opt,name=random,proto3" json:"random,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UIntRange) Reset() {
	*x = UIntRange{}
	mi := &file_ate_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UIntRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UIntRange) ProtoMessage() {}

func (x *UIntRange) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UIntRange.ProtoReflect.Descriptor instead.
func (*UIntRange) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{48}
}

func (x *UIntRange) GetMin() uint32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *UIntRange) GetMax() uint32 {
	if x != nil {
		return x.Max
	}
	return 0
}

func (x *UIntRange) GetStep() uint32 {
	if x != nil {
		return x.Step
	}
	return 0
}

func (x *UIntRange) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *UIntRange) GetRandom() bool {
	if x != nil {
		return x.Random
	}
	return false
}

type AddressRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Min           string                 `protobuf:"bytes,1,opt,name=min,proto3" json:"min,omitempty"`
	Max           string                 `protobuf:"bytes,2,opt,name=max,proto3" json:"max,omitempty"`
	Step          string                 `protobuf:"bytes,3,opt,name=step,proto3" json:"step,omitempty"`
	Count         uint32                 `protobuf:"varint,4,opt,name=count,proto3" json:"count,omitempty"`
	Random        bool                   `protobuf:"varint,5,opt,name=random,proto3" json:"random,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddressRange) Reset() {
	*x = AddressRange{}
	mi := &file_ate_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddressRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddressRange) ProtoMessage() {}

func (x *AddressRange) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddressRange.ProtoReflect.Descriptor instead.
func (*AddressRange) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{49}
}

func (x *AddressRange) GetMin() string {
	if x != nil {
		return x.Min
	}
	return ""
}

func (x *AddressRange) GetMax() string {
	if x != nil {
		return x.Max
	}
	return ""
}

func (x *AddressRange) GetStep() string {
	if x != nil {
		return x.Step
	}
	return ""
}

func (x *AddressRange) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *AddressRange) GetRandom() bool {
	if x != nil {
		return x.Random
	}
	return false
}

type StringIncRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         string                 `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	Step          string                 `protobuf:"bytes,2,opt,name=step,proto3" json:"step,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StringIncRange) Reset() {
	*x = StringIncRange{}
	mi := &file_ate_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StringIncRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringIncRange) ProtoMessage() {}

func (x *StringIncRange) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringIncRange.ProtoReflect.Descriptor instead.
func (*StringIncRange) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{50}
}

func (x *StringIncRange) GetStart() string {
	if x != nil {
		return x.Start
	}
	return ""
}

func (x *StringIncRange) GetStep() string {
	if x != nil {
		return x.Step
	}
	return ""
}

type UInt32IncRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Start         uint32                 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	Step          uint32                 `protobuf:"varint,2,opt,name=step,proto3" json:"step,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UInt32IncRange) Reset() {
	*x = UInt32IncRange{}
	mi := &file_ate_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UInt32IncRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UInt32IncRange) ProtoMessage() {}

func (x *UInt32IncRange) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UInt32IncRange.ProtoReflect.Descriptor instead.
func (*UInt32IncRange) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{51}
}

func (x *UInt32IncRange) GetStart() uint32 {
	if x != nil {
		return x.Start
	}
	return 0
}

func (x *UInt32IncRange) GetStep() uint32 {
	if x != nil {
		return x.Step
	}
	return 0
}

type Lag_Lacp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enabled       bool                   `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Lag_Lacp) Reset() {
	*x = Lag_Lacp{}
	mi := &file_ate_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Lag_Lacp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Lag_Lacp) ProtoMessage() {}

func (x *Lag_Lacp) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Lag_Lacp.ProtoReflect.Descriptor instead.
func (*Lag_Lacp) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{1, 0}
}

func (x *Lag_Lacp) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

type MacSec_MKA struct {
	state                   protoimpl.MessageState              `protogen:"open.v1"`
	Version                 uint32                              `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	Capability              MacSec_MKA_Capability               `protobuf:"varint,2,opt,name=capability,proto3,enum=ondatra.MacSec_MKA_Capability" json:"capability,omitempty"`
	ConfidentialityOffset   MacSec_MKA_ConfidentialityOffset    `protobuf:"varint,3,opt,name=confidentiality_offset,json=confidentialityOffset,proto3,enum=ondatra.MacSec_MKA_ConfidentialityOffset" json:"confidentiality_offset,omitempty"`
	CipherSuite             MacSec_CipherSuite                  `protobuf:"varint,4,opt,name=cipher_suite,json=cipherSuite,proto3,enum=ondatra.MacSec_CipherSuite" json:"cipher_suite,omitempty"`
	KeyDerivationFunction   MacSec_MKA_KeyDerivationFunction    `protobuf:"varint,6,opt,name=key_derivation_function,json=keyDerivationFunction,proto3,enum=ondatra.MacSec_MKA_KeyDerivationFunction" json:"key_derivation_function,omitempty"`
	ConnectivityAssociation *MacSec_MKA_ConnectivityAssociation `protobuf:"bytes,5,opt,name=connectivity_association,json=connectivityAssociation,proto3" json:"connectivity_association,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *MacSec_MKA) Reset() {
	*x = MacSec_MKA{}
	mi := &file_ate_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacSec_MKA) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacSec_MKA) ProtoMessage() {}

func (x *MacSec_MKA) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacSec_MKA.ProtoReflect.Descriptor instead.
func (*MacSec_MKA) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{5, 0}
}

func (x *MacSec_MKA) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *MacSec_MKA) GetCapability() MacSec_MKA_Capability {
	if x != nil {
		return x.Capability
	}
	return MacSec_MKA_CAPABILITY_UNSPECIFIED
}

func (x *MacSec_MKA) GetConfidentialityOffset() MacSec_MKA_ConfidentialityOffset {
	if x != nil {
		return x.ConfidentialityOffset
	}
	return MacSec_MKA_OFFSET_UNSPECIFIED
}

func (x *MacSec_MKA) GetCipherSuite() MacSec_CipherSuite {
	if x != nil {
		return x.CipherSuite
	}
	return MacSec_CIPHER_SUITE_UNSPECIFIED
}

func (x *MacSec_MKA) GetKeyDerivationFunction() MacSec_MKA_KeyDerivationFunction {
	if x != nil {
		return x.KeyDerivationFunction
	}
	return MacSec_MKA_KEY_DERIVATION_UNSPECIFIED
}

func (x *MacSec_MKA) GetConnectivityAssociation() *MacSec_MKA_ConnectivityAssociation {
	if x != nil {
		return x.ConnectivityAssociation
	}
	return nil
}

type MacSec_MKA_ConnectivityAssociation struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ckn           string                 `protobuf:"bytes,1,opt,name=ckn,proto3" json:"ckn,omitempty"`
	Cak           string                 `protobuf:"bytes,2,opt,name=cak,proto3" json:"cak,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MacSec_MKA_ConnectivityAssociation) Reset() {
	*x = MacSec_MKA_ConnectivityAssociation{}
	mi := &file_ate_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MacSec_MKA_ConnectivityAssociation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MacSec_MKA_ConnectivityAssociation) ProtoMessage() {}

func (x *MacSec_MKA_ConnectivityAssociation) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MacSec_MKA_ConnectivityAssociation.ProtoReflect.Descriptor instead.
func (*MacSec_MKA_ConnectivityAssociation) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{5, 0, 0}
}

func (x *MacSec_MKA_ConnectivityAssociation) GetCkn() string {
	if x != nil {
		return x.Ckn
	}
	return ""
}

func (x *MacSec_MKA_ConnectivityAssociation) GetCak() string {
	if x != nil {
		return x.Cak
	}
	return ""
}

type ISISSegmentRouting_AdjacencySID struct {
	state                     protoimpl.MessageState `protogen:"open.v1"`
	Sid                       string                 `protobuf:"bytes,1,opt,name=sid,proto3" json:"sid,omitempty"`
	OverrideFlagAddressFamily bool                   `protobuf:"varint,2,opt,name=override_flag_address_family,json=overrideFlagAddressFamily,proto3" json:"override_flag_address_family,omitempty"`
	FlagAddressFamily         bool                   `protobuf:"varint,3,opt,name=flag_address_family,json=flagAddressFamily,proto3" json:"flag_address_family,omitempty"`
	FlagBackup                bool                   `protobuf:"varint,4,opt,name=flag_backup,json=flagBackup,proto3" json:"flag_backup,omitempty"`
	FlagValue                 bool                   `protobuf:"varint,5,opt,name=flag_value,json=flagValue,proto3" json:"flag_value,omitempty"`
	FlagLocal                 bool                   `protobuf:"varint,6,opt,name=flag_local,json=flagLocal,proto3" json:"flag_local,omitempty"`
	FlagSet                   bool                   `protobuf:"varint,7,opt,name=flag_set,json=flagSet,proto3" json:"flag_set,omitempty"`
	FlagPersistent            bool                   `protobuf:"varint,8,opt,name=flag_persistent,json=flagPersistent,proto3" json:"flag_persistent,omitempty"`
	unknownFields             protoimpl.UnknownFields
	sizeCache                 protoimpl.SizeCache
}

func (x *ISISSegmentRouting_AdjacencySID) Reset() {
	*x = ISISSegmentRouting_AdjacencySID{}
	mi := &file_ate_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISISSegmentRouting_AdjacencySID) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISISSegmentRouting_AdjacencySID) ProtoMessage() {}

func (x *ISISSegmentRouting_AdjacencySID) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISISSegmentRouting_AdjacencySID.ProtoReflect.Descriptor instead.
func (*ISISSegmentRouting_AdjacencySID) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{9, 0}
}

func (x *ISISSegmentRouting_AdjacencySID) GetSid() string {
	if x != nil {
		return x.Sid
	}
	return ""
}

func (x *ISISSegmentRouting_AdjacencySID) GetOverrideFlagAddressFamily() bool {
	if x != nil {
		return x.OverrideFlagAddressFamily
	}
	return false
}

func (x *ISISSegmentRouting_AdjacencySID) GetFlagAddressFamily() bool {
	if x != nil {
		return x.FlagAddressFamily
	}
	return false
}

func (x *ISISSegmentRouting_AdjacencySID) GetFlagBackup() bool {
	if x != nil {
		return x.FlagBackup
	}
	return false
}

func (x *ISISSegmentRouting_AdjacencySID) GetFlagValue() bool {
	if x != nil {
		return x.FlagValue
	}
	return false
}

func (x *ISISSegmentRouting_AdjacencySID) GetFlagLocal() bool {
	if x != nil {
		return x.FlagLocal
	}
	return false
}

func (x *ISISSegmentRouting_AdjacencySID) GetFlagSet() bool {
	if x != nil {
		return x.FlagSet
	}
	return false
}

func (x *ISISSegmentRouting_AdjacencySID) GetFlagPersistent() bool {
	if x != nil {
		return x.FlagPersistent
	}
	return false
}

type ISISSegmentRouting_SIDRange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	SidStartLabel uint32                 `protobuf:"varint,1,opt,name=sid_start_label,json=sidStartLabel,proto3" json:"sid_start_label,omitempty"`
	SidCount      uint32                 `protobuf:"varint,2,opt,name=sid_count,json=sidCount,proto3" json:"sid_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ISISSegmentRouting_SIDRange) Reset() {
	*x = ISISSegmentRouting_SIDRange{}
	mi := &file_ate_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISISSegmentRouting_SIDRange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISISSegmentRouting_SIDRange) ProtoMessage() {}

func (x *ISISSegmentRouting_SIDRange) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISISSegmentRouting_SIDRange.ProtoReflect.Descriptor instead.
func (*ISISSegmentRouting_SIDRange) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{9, 1}
}

func (x *ISISSegmentRouting_SIDRange) GetSidStartLabel() uint32 {
	if x != nil {
		return x.SidStartLabel
	}
	return 0
}

func (x *ISISSegmentRouting_SIDRange) GetSidCount() uint32 {
	if x != nil {
		return x.SidCount
	}
	return 0
}

type ISReachability_Node struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IngressMetric uint32                 `protobuf:"varint,1,opt,name=ingress_metric,json=ingressMetric,proto3" json:"ingress_metric,omitempty"`
	EgressMetric  uint32                 `protobuf:"varint,2,opt,name=egress_metric,json=egressMetric,proto3" json:"egress_metric,omitempty"`
	// The system ID should be specified using hex characters (possibly
	// grouped by colons or periods.)
	SystemId           string                      `protobuf:"bytes,3,opt,name=system_id,json=systemId,proto3" json:"system_id,omitempty"`
	Links              []*ISReachability_Node_Link `protobuf:"bytes,4,rep,name=links,proto3" json:"links,omitempty"`
	EnableTe           bool                        `protobuf:"varint,6,opt,name=enable_te,json=enableTe,proto3" json:"enable_te,omitempty"`
	EnableWideMetric   bool                        `protobuf:"varint,7,opt,name=enable_wide_metric,json=enableWideMetric,proto3" json:"enable_wide_metric,omitempty"`
	SegmentRouting     *ISISSegmentRouting         `protobuf:"bytes,8,opt,name=segment_routing,json=segmentRouting,proto3" json:"segment_routing,omitempty"`
	TeRouterId         string                      `protobuf:"bytes,9,opt,name=te_router_id,json=teRouterId,proto3" json:"te_router_id,omitempty"`
	RoutesIpv4         *ISReachability_Node_Routes `protobuf:"bytes,10,opt,name=routes_ipv4,json=routesIpv4,proto3" json:"routes_ipv4,omitempty"`
	RoutesIpv6         *ISReachability_Node_Routes `protobuf:"bytes,12,opt,name=routes_ipv6,json=routesIpv6,proto3" json:"routes_ipv6,omitempty"`
	CapabilityRouterId string                      `protobuf:"bytes,11,opt,name=capability_router_id,json=capabilityRouterId,proto3" json:"capability_router_id,omitempty"` // NEXT ID: 13
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ISReachability_Node) Reset() {
	*x = ISReachability_Node{}
	mi := &file_ate_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISReachability_Node) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISReachability_Node) ProtoMessage() {}

func (x *ISReachability_Node) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISReachability_Node.ProtoReflect.Descriptor instead.
func (*ISReachability_Node) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{11, 0}
}

func (x *ISReachability_Node) GetIngressMetric() uint32 {
	if x != nil {
		return x.IngressMetric
	}
	return 0
}

func (x *ISReachability_Node) GetEgressMetric() uint32 {
	if x != nil {
		return x.EgressMetric
	}
	return 0
}

func (x *ISReachability_Node) GetSystemId() string {
	if x != nil {
		return x.SystemId
	}
	return ""
}

func (x *ISReachability_Node) GetLinks() []*ISReachability_Node_Link {
	if x != nil {
		return x.Links
	}
	return nil
}

func (x *ISReachability_Node) GetEnableTe() bool {
	if x != nil {
		return x.EnableTe
	}
	return false
}

func (x *ISReachability_Node) GetEnableWideMetric() bool {
	if x != nil {
		return x.EnableWideMetric
	}
	return false
}

func (x *ISReachability_Node) GetSegmentRouting() *ISISSegmentRouting {
	if x != nil {
		return x.SegmentRouting
	}
	return nil
}

func (x *ISReachability_Node) GetTeRouterId() string {
	if x != nil {
		return x.TeRouterId
	}
	return ""
}

func (x *ISReachability_Node) GetRoutesIpv4() *ISReachability_Node_Routes {
	if x != nil {
		return x.RoutesIpv4
	}
	return nil
}

func (x *ISReachability_Node) GetRoutesIpv6() *ISReachability_Node_Routes {
	if x != nil {
		return x.RoutesIpv6
	}
	return nil
}

func (x *ISReachability_Node) GetCapabilityRouterId() string {
	if x != nil {
		return x.CapabilityRouterId
	}
	return ""
}

type ISReachability_Node_Link struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FromIpv4      string                 `protobuf:"bytes,1,opt,name=from_ipv4,json=fromIpv4,proto3" json:"from_ipv4,omitempty"`
	ToIpv4        string                 `protobuf:"bytes,2,opt,name=to_ipv4,json=toIpv4,proto3" json:"to_ipv4,omitempty"`
	FromIpv6      string                 `protobuf:"bytes,3,opt,name=from_ipv6,json=fromIpv6,proto3" json:"from_ipv6,omitempty"`
	ToIpv6        string                 `protobuf:"bytes,4,opt,name=to_ipv6,json=toIpv6,proto3" json:"to_ipv6,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ISReachability_Node_Link) Reset() {
	*x = ISReachability_Node_Link{}
	mi := &file_ate_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISReachability_Node_Link) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISReachability_Node_Link) ProtoMessage() {}

func (x *ISReachability_Node_Link) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISReachability_Node_Link.ProtoReflect.Descriptor instead.
func (*ISReachability_Node_Link) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{11, 0, 0}
}

func (x *ISReachability_Node_Link) GetFromIpv4() string {
	if x != nil {
		return x.FromIpv4
	}
	return ""
}

func (x *ISReachability_Node_Link) GetToIpv4() string {
	if x != nil {
		return x.ToIpv4
	}
	return ""
}

func (x *ISReachability_Node_Link) GetFromIpv6() string {
	if x != nil {
		return x.FromIpv6
	}
	return ""
}

func (x *ISReachability_Node_Link) GetToIpv6() string {
	if x != nil {
		return x.ToIpv6
	}
	return ""
}

type ISReachability_Node_Routes struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Prefix        string                 `protobuf:"bytes,1,opt,name=prefix,proto3" json:"prefix,omitempty"`
	NumRoutes     uint64                 `protobuf:"varint,2,opt,name=num_routes,json=numRoutes,proto3" json:"num_routes,omitempty"`
	Reachability  *IPReachability        `protobuf:"bytes,3,opt,name=reachability,proto3" json:"reachability,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ISReachability_Node_Routes) Reset() {
	*x = ISReachability_Node_Routes{}
	mi := &file_ate_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISReachability_Node_Routes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISReachability_Node_Routes) ProtoMessage() {}

func (x *ISReachability_Node_Routes) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISReachability_Node_Routes.ProtoReflect.Descriptor instead.
func (*ISReachability_Node_Routes) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{11, 0, 1}
}

func (x *ISReachability_Node_Routes) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *ISReachability_Node_Routes) GetNumRoutes() uint64 {
	if x != nil {
		return x.NumRoutes
	}
	return 0
}

func (x *ISReachability_Node_Routes) GetReachability() *IPReachability {
	if x != nil {
		return x.Reachability
	}
	return nil
}

type BgpPeer_Capabilities struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	Ipv4Unicast             bool                   `protobuf:"varint,1,opt,name=ipv4_unicast,json=ipv4Unicast,proto3" json:"ipv4_unicast,omitempty"`
	Ipv4Multicast           bool                   `protobuf:"varint,2,opt,name=ipv4_multicast,json=ipv4Multicast,proto3" json:"ipv4_multicast,omitempty"`
	Ipv4MplsVpn             bool                   `protobuf:"varint,3,opt,name=ipv4_mpls_vpn,json=ipv4MplsVpn,proto3" json:"ipv4_mpls_vpn,omitempty"`
	Ipv6Unicast             bool                   `protobuf:"varint,4,opt,name=ipv6_unicast,json=ipv6Unicast,proto3" json:"ipv6_unicast,omitempty"`
	Ipv6Multicast           bool                   `protobuf:"varint,5,opt,name=ipv6_multicast,json=ipv6Multicast,proto3" json:"ipv6_multicast,omitempty"`
	Ipv6MplsVpn             bool                   `protobuf:"varint,6,opt,name=ipv6_mpls_vpn,json=ipv6MplsVpn,proto3" json:"ipv6_mpls_vpn,omitempty"`
	Ipv4Mdt                 bool                   `protobuf:"varint,7,opt,name=ipv4_mdt,json=ipv4Mdt,proto3" json:"ipv4_mdt,omitempty"`
	Vpls                    bool                   `protobuf:"varint,8,opt,name=vpls,proto3" json:"vpls,omitempty"`
	Ipv4MulticastVpn        bool                   `protobuf:"varint,9,opt,name=ipv4_multicast_vpn,json=ipv4MulticastVpn,proto3" json:"ipv4_multicast_vpn,omitempty"`
	Ipv6MulticastVpn        bool                   `protobuf:"varint,10,opt,name=ipv6_multicast_vpn,json=ipv6MulticastVpn,proto3" json:"ipv6_multicast_vpn,omitempty"`
	RouteRefresh            bool                   `protobuf:"varint,11,opt,name=route_refresh,json=routeRefresh,proto3" json:"route_refresh,omitempty"`
	RouteConstraint         bool                   `protobuf:"varint,12,opt,name=route_constraint,json=routeConstraint,proto3" json:"route_constraint,omitempty"`
	LinkStateNonVpn         bool                   `protobuf:"varint,13,opt,name=link_state_non_vpn,json=linkStateNonVpn,proto3" json:"link_state_non_vpn,omitempty"`
	Evpn                    bool                   `protobuf:"varint,14,opt,name=evpn,proto3" json:"evpn,omitempty"`
	Ipv4MulticastBgpMplsVpn bool                   `protobuf:"varint,15,opt,name=ipv4_multicast_bgp_mpls_vpn,json=ipv4MulticastBgpMplsVpn,proto3" json:"ipv4_multicast_bgp_mpls_vpn,omitempty"`
	Ipv6MulticastBgpMplsVpn bool                   `protobuf:"varint,16,opt,name=ipv6_multicast_bgp_mpls_vpn,json=ipv6MulticastBgpMplsVpn,proto3" json:"ipv6_multicast_bgp_mpls_vpn,omitempty"`
	Ipv4UnicastFlowSpec     bool                   `protobuf:"varint,17,opt,name=ipv4_unicast_flow_spec,json=ipv4UnicastFlowSpec,proto3" json:"ipv4_unicast_flow_spec,omitempty"`
	Ipv6UnicastFlowSpec     bool                   `protobuf:"varint,18,opt,name=ipv6_unicast_flow_spec,json=ipv6UnicastFlowSpec,proto3" json:"ipv6_unicast_flow_spec,omitempty"`
	Ipv4UnicastAddPath      bool                   `protobuf:"varint,19,opt,name=ipv4_unicast_add_path,json=ipv4UnicastAddPath,proto3" json:"ipv4_unicast_add_path,omitempty"`
	Ipv6UnicastAddPath      bool                   `protobuf:"varint,20,opt,name=ipv6_unicast_add_path,json=ipv6UnicastAddPath,proto3" json:"ipv6_unicast_add_path,omitempty"`
	ExtendedNextHopEncoding bool                   `protobuf:"varint,21,opt,name=extended_next_hop_encoding,json=extendedNextHopEncoding,proto3" json:"extended_next_hop_encoding,omitempty"`
	Ipv4SrtePolicy          bool                   `protobuf:"varint,22,opt,name=ipv4_srte_policy,json=ipv4SrtePolicy,proto3" json:"ipv4_srte_policy,omitempty"`
	Ipv6SrtePolicy          bool                   `protobuf:"varint,23,opt,name=ipv6_srte_policy,json=ipv6SrtePolicy,proto3" json:"ipv6_srte_policy,omitempty"`
	Ipv4MplsAddPath         bool                   `protobuf:"varint,24,opt,name=ipv4_mpls_add_path,json=ipv4MplsAddPath,proto3" json:"ipv4_mpls_add_path,omitempty"`
	Ipv6MplsAddPath         bool                   `protobuf:"varint,25,opt,name=ipv6_mpls_add_path,json=ipv6MplsAddPath,proto3" json:"ipv6_mpls_add_path,omitempty"`
	GracefulRestart         bool                   `protobuf:"varint,26,opt,name=graceful_restart,json=gracefulRestart,proto3" json:"graceful_restart,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *BgpPeer_Capabilities) Reset() {
	*x = BgpPeer_Capabilities{}
	mi := &file_ate_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_Capabilities) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_Capabilities) ProtoMessage() {}

func (x *BgpPeer_Capabilities) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_Capabilities.ProtoReflect.Descriptor instead.
func (*BgpPeer_Capabilities) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 0}
}

func (x *BgpPeer_Capabilities) GetIpv4Unicast() bool {
	if x != nil {
		return x.Ipv4Unicast
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4Multicast() bool {
	if x != nil {
		return x.Ipv4Multicast
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4MplsVpn() bool {
	if x != nil {
		return x.Ipv4MplsVpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6Unicast() bool {
	if x != nil {
		return x.Ipv6Unicast
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6Multicast() bool {
	if x != nil {
		return x.Ipv6Multicast
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6MplsVpn() bool {
	if x != nil {
		return x.Ipv6MplsVpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4Mdt() bool {
	if x != nil {
		return x.Ipv4Mdt
	}
	return false
}

func (x *BgpPeer_Capabilities) GetVpls() bool {
	if x != nil {
		return x.Vpls
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4MulticastVpn() bool {
	if x != nil {
		return x.Ipv4MulticastVpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6MulticastVpn() bool {
	if x != nil {
		return x.Ipv6MulticastVpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetRouteRefresh() bool {
	if x != nil {
		return x.RouteRefresh
	}
	return false
}

func (x *BgpPeer_Capabilities) GetRouteConstraint() bool {
	if x != nil {
		return x.RouteConstraint
	}
	return false
}

func (x *BgpPeer_Capabilities) GetLinkStateNonVpn() bool {
	if x != nil {
		return x.LinkStateNonVpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetEvpn() bool {
	if x != nil {
		return x.Evpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4MulticastBgpMplsVpn() bool {
	if x != nil {
		return x.Ipv4MulticastBgpMplsVpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6MulticastBgpMplsVpn() bool {
	if x != nil {
		return x.Ipv6MulticastBgpMplsVpn
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4UnicastFlowSpec() bool {
	if x != nil {
		return x.Ipv4UnicastFlowSpec
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6UnicastFlowSpec() bool {
	if x != nil {
		return x.Ipv6UnicastFlowSpec
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4UnicastAddPath() bool {
	if x != nil {
		return x.Ipv4UnicastAddPath
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6UnicastAddPath() bool {
	if x != nil {
		return x.Ipv6UnicastAddPath
	}
	return false
}

func (x *BgpPeer_Capabilities) GetExtendedNextHopEncoding() bool {
	if x != nil {
		return x.ExtendedNextHopEncoding
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4SrtePolicy() bool {
	if x != nil {
		return x.Ipv4SrtePolicy
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6SrtePolicy() bool {
	if x != nil {
		return x.Ipv6SrtePolicy
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv4MplsAddPath() bool {
	if x != nil {
		return x.Ipv4MplsAddPath
	}
	return false
}

func (x *BgpPeer_Capabilities) GetIpv6MplsAddPath() bool {
	if x != nil {
		return x.Ipv6MplsAddPath
	}
	return false
}

func (x *BgpPeer_Capabilities) GetGracefulRestart() bool {
	if x != nil {
		return x.GracefulRestart
	}
	return false
}

type BgpPeer_SrtePolicyGroup struct {
	state          protoimpl.MessageState                 `protogen:"open.v1"`
	Count          uint32                                 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Active         bool                                   `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
	Distinguisher  uint32                                 `protobuf:"varint,3,opt,name=distinguisher,proto3" json:"distinguisher,omitempty"`
	PolicyColor    *UInt32IncRange                        `protobuf:"bytes,4,opt,name=policy_color,json=policyColor,proto3" json:"policy_color,omitempty"`
	Endpoint       string                                 `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	NextHopAddress string                                 `protobuf:"bytes,6,opt,name=next_hop_address,json=nextHopAddress,proto3" json:"next_hop_address,omitempty"`
	OriginatorId   *StringIncRange                        `protobuf:"bytes,7,opt,name=originator_id,json=originatorId,proto3" json:"originator_id,omitempty"`
	Communities    *BgpCommunities                        `protobuf:"bytes,8,opt,name=communities,proto3" json:"communities,omitempty"`
	AsnSetMode     BgpAsnSetMode                          `protobuf:"varint,9,opt,name=asn_set_mode,json=asnSetMode,proto3,enum=ondatra.BgpAsnSetMode" json:"asn_set_mode,omitempty"`
	Preference     *BgpPeer_SrtePolicyGroup_Preference    `protobuf:"bytes,10,opt,name=preference,proto3" json:"preference,omitempty"`
	Binding        *BgpPeer_SrtePolicyGroup_Binding       `protobuf:"bytes,11,opt,name=binding,proto3" json:"binding,omitempty"`
	SegmentLists   []*BgpPeer_SrtePolicyGroup_SegmentList `protobuf:"bytes,12,rep,name=segment_lists,json=segmentLists,proto3" json:"segment_lists,omitempty"`
	Enlp           *BgpPeer_SrtePolicyGroup_Enlp          `protobuf:"bytes,13,opt,name=enlp,proto3" json:"enlp,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup) Reset() {
	*x = BgpPeer_SrtePolicyGroup{}
	mi := &file_ate_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1}
}

func (x *BgpPeer_SrtePolicyGroup) GetCount() uint32 {
	if x != nil {
		return x.Count
	}
	return 0
}

func (x *BgpPeer_SrtePolicyGroup) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *BgpPeer_SrtePolicyGroup) GetDistinguisher() uint32 {
	if x != nil {
		return x.Distinguisher
	}
	return 0
}

func (x *BgpPeer_SrtePolicyGroup) GetPolicyColor() *UInt32IncRange {
	if x != nil {
		return x.PolicyColor
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *BgpPeer_SrtePolicyGroup) GetNextHopAddress() string {
	if x != nil {
		return x.NextHopAddress
	}
	return ""
}

func (x *BgpPeer_SrtePolicyGroup) GetOriginatorId() *StringIncRange {
	if x != nil {
		return x.OriginatorId
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup) GetCommunities() *BgpCommunities {
	if x != nil {
		return x.Communities
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup) GetAsnSetMode() BgpAsnSetMode {
	if x != nil {
		return x.AsnSetMode
	}
	return BgpAsnSetMode_ASN_SET_MODE_UNSPECIFIED
}

func (x *BgpPeer_SrtePolicyGroup) GetPreference() *BgpPeer_SrtePolicyGroup_Preference {
	if x != nil {
		return x.Preference
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup) GetBinding() *BgpPeer_SrtePolicyGroup_Binding {
	if x != nil {
		return x.Binding
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup) GetSegmentLists() []*BgpPeer_SrtePolicyGroup_SegmentList {
	if x != nil {
		return x.SegmentLists
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup) GetEnlp() *BgpPeer_SrtePolicyGroup_Enlp {
	if x != nil {
		return x.Enlp
	}
	return nil
}

type BgpPeer_SrtePolicyGroup_Preference struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Preference    uint32                 `protobuf:"varint,1,opt,name=preference,proto3" json:"preference,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup_Preference) Reset() {
	*x = BgpPeer_SrtePolicyGroup_Preference{}
	mi := &file_ate_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup_Preference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup_Preference) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup_Preference) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup_Preference.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup_Preference) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1, 0}
}

func (x *BgpPeer_SrtePolicyGroup_Preference) GetPreference() uint32 {
	if x != nil {
		return x.Preference
	}
	return 0
}

type BgpPeer_SrtePolicyGroup_Binding struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*BgpPeer_SrtePolicyGroup_Binding_NoBinding
	//	*BgpPeer_SrtePolicyGroup_Binding_FourOctetSid
	//	*BgpPeer_SrtePolicyGroup_Binding_FourOctetSidAsMplsLabel
	//	*BgpPeer_SrtePolicyGroup_Binding_Ipv6Sid
	Type          isBgpPeer_SrtePolicyGroup_Binding_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup_Binding) Reset() {
	*x = BgpPeer_SrtePolicyGroup_Binding{}
	mi := &file_ate_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup_Binding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup_Binding) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup_Binding) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup_Binding.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup_Binding) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1, 1}
}

func (x *BgpPeer_SrtePolicyGroup_Binding) GetType() isBgpPeer_SrtePolicyGroup_Binding_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup_Binding) GetNoBinding() *emptypb.Empty {
	if x != nil {
		if x, ok := x.Type.(*BgpPeer_SrtePolicyGroup_Binding_NoBinding); ok {
			return x.NoBinding
		}
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup_Binding) GetFourOctetSid() *UInt32IncRange {
	if x != nil {
		if x, ok := x.Type.(*BgpPeer_SrtePolicyGroup_Binding_FourOctetSid); ok {
			return x.FourOctetSid
		}
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup_Binding) GetFourOctetSidAsMplsLabel() *UInt32IncRange {
	if x != nil {
		if x, ok := x.Type.(*BgpPeer_SrtePolicyGroup_Binding_FourOctetSidAsMplsLabel); ok {
			return x.FourOctetSidAsMplsLabel
		}
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup_Binding) GetIpv6Sid() string {
	if x != nil {
		if x, ok := x.Type.(*BgpPeer_SrtePolicyGroup_Binding_Ipv6Sid); ok {
			return x.Ipv6Sid
		}
	}
	return ""
}

type isBgpPeer_SrtePolicyGroup_Binding_Type interface {
	isBgpPeer_SrtePolicyGroup_Binding_Type()
}

type BgpPeer_SrtePolicyGroup_Binding_NoBinding struct {
	NoBinding *emptypb.Empty `protobuf:"bytes,1,opt,name=no_binding,json=noBinding,proto3,oneof"`
}

type BgpPeer_SrtePolicyGroup_Binding_FourOctetSid struct {
	FourOctetSid *UInt32IncRange `protobuf:"bytes,2,opt,name=four_octet_sid,json=fourOctetSid,proto3,oneof"`
}

type BgpPeer_SrtePolicyGroup_Binding_FourOctetSidAsMplsLabel struct {
	FourOctetSidAsMplsLabel *UInt32IncRange `protobuf:"bytes,3,opt,name=four_octet_sid_as_mpls_label,json=fourOctetSidAsMplsLabel,proto3,oneof"`
}

type BgpPeer_SrtePolicyGroup_Binding_Ipv6Sid struct {
	Ipv6Sid string `protobuf:"bytes,4,opt,name=ipv6_sid,json=ipv6Sid,proto3,oneof"`
}

func (*BgpPeer_SrtePolicyGroup_Binding_NoBinding) isBgpPeer_SrtePolicyGroup_Binding_Type() {}

func (*BgpPeer_SrtePolicyGroup_Binding_FourOctetSid) isBgpPeer_SrtePolicyGroup_Binding_Type() {}

func (*BgpPeer_SrtePolicyGroup_Binding_FourOctetSidAsMplsLabel) isBgpPeer_SrtePolicyGroup_Binding_Type() {
}

func (*BgpPeer_SrtePolicyGroup_Binding_Ipv6Sid) isBgpPeer_SrtePolicyGroup_Binding_Type() {}

type BgpPeer_SrtePolicyGroup_SegmentList struct {
	state         protoimpl.MessageState                         `protogen:"open.v1"`
	Active        bool                                           `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	Weight        *BgpPeer_SrtePolicyGroup_SegmentList_Weight    `protobuf:"bytes,2,opt,name=weight,proto3" json:"weight,omitempty"`
	Segments      []*BgpPeer_SrtePolicyGroup_SegmentList_Segment `protobuf:"bytes,4,rep,name=segments,proto3" json:"segments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList) Reset() {
	*x = BgpPeer_SrtePolicyGroup_SegmentList{}
	mi := &file_ate_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup_SegmentList) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup_SegmentList) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup_SegmentList.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup_SegmentList) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1, 2}
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList) GetWeight() *BgpPeer_SrtePolicyGroup_SegmentList_Weight {
	if x != nil {
		return x.Weight
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList) GetSegments() []*BgpPeer_SrtePolicyGroup_SegmentList_Segment {
	if x != nil {
		return x.Segments
	}
	return nil
}

type BgpPeer_SrtePolicyGroup_Enlp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Enlp          uint32                 `protobuf:"varint,1,opt,name=enlp,proto3" json:"enlp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup_Enlp) Reset() {
	*x = BgpPeer_SrtePolicyGroup_Enlp{}
	mi := &file_ate_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup_Enlp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup_Enlp) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup_Enlp) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup_Enlp.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup_Enlp) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1, 3}
}

func (x *BgpPeer_SrtePolicyGroup_Enlp) GetEnlp() uint32 {
	if x != nil {
		return x.Enlp
	}
	return 0
}

type BgpPeer_SrtePolicyGroup_SegmentList_Weight struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Weight        uint32                 `protobuf:"varint,1,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Weight) Reset() {
	*x = BgpPeer_SrtePolicyGroup_SegmentList_Weight{}
	mi := &file_ate_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Weight) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup_SegmentList_Weight) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Weight) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup_SegmentList_Weight.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup_SegmentList_Weight) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1, 2, 0}
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Weight) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type BgpPeer_SrtePolicyGroup_SegmentList_Segment struct {
	state  protoimpl.MessageState `protogen:"open.v1"`
	Active bool                   `protobuf:"varint,1,opt,name=active,proto3" json:"active,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid_
	//	*BgpPeer_SrtePolicyGroup_SegmentList_Segment_Ipv6Sid
	Type          isBgpPeer_SrtePolicyGroup_SegmentList_Segment_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment) Reset() {
	*x = BgpPeer_SrtePolicyGroup_SegmentList_Segment{}
	mi := &file_ate_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup_SegmentList_Segment) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup_SegmentList_Segment.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup_SegmentList_Segment) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1, 2, 1}
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment) GetType() isBgpPeer_SrtePolicyGroup_SegmentList_Segment_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment) GetMplsSid() *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid {
	if x != nil {
		if x, ok := x.Type.(*BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid_); ok {
			return x.MplsSid
		}
	}
	return nil
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment) GetIpv6Sid() string {
	if x != nil {
		if x, ok := x.Type.(*BgpPeer_SrtePolicyGroup_SegmentList_Segment_Ipv6Sid); ok {
			return x.Ipv6Sid
		}
	}
	return ""
}

type isBgpPeer_SrtePolicyGroup_SegmentList_Segment_Type interface {
	isBgpPeer_SrtePolicyGroup_SegmentList_Segment_Type()
}

type BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid_ struct {
	MplsSid *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid `protobuf:"bytes,2,opt,name=mpls_sid,json=mplsSid,proto3,oneof"`
}

type BgpPeer_SrtePolicyGroup_SegmentList_Segment_Ipv6Sid struct {
	Ipv6Sid string `protobuf:"bytes,3,opt,name=ipv6_sid,json=ipv6Sid,proto3,oneof"`
}

func (*BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid_) isBgpPeer_SrtePolicyGroup_SegmentList_Segment_Type() {
}

func (*BgpPeer_SrtePolicyGroup_SegmentList_Segment_Ipv6Sid) isBgpPeer_SrtePolicyGroup_SegmentList_Segment_Type() {
}

type BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Note that this is only a 20-bit value in the protocol.
	Label uint32 `protobuf:"varint,1,opt,name=label,proto3" json:"label,omitempty"`
	// Note that this is only a 3-bit value in the protocol.
	Tc uint32 `protobuf:"varint,2,opt,name=tc,proto3" json:"tc,omitempty"`
	S  bool   `protobuf:"varint,3,opt,name=s,proto3" json:"s,omitempty"`
	// Note that this is only an 8-bit value in the protocol.
	Ttl           uint32 `protobuf:"varint,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) Reset() {
	*x = BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid{}
	mi := &file_ate_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) ProtoMessage() {}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid.ProtoReflect.Descriptor instead.
func (*BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{14, 1, 2, 1, 0}
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) GetLabel() uint32 {
	if x != nil {
		return x.Label
	}
	return 0
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) GetTc() uint32 {
	if x != nil {
		return x.Tc
	}
	return 0
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) GetS() bool {
	if x != nil {
		return x.S
	}
	return false
}

func (x *BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid) GetTtl() uint32 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

type BgpAttributes_ExtendedCommunity struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Type:
	//
	//	*BgpAttributes_ExtendedCommunity_Color_
	Type          isBgpAttributes_ExtendedCommunity_Type `protobuf_oneof:"Type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpAttributes_ExtendedCommunity) Reset() {
	*x = BgpAttributes_ExtendedCommunity{}
	mi := &file_ate_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpAttributes_ExtendedCommunity) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpAttributes_ExtendedCommunity) ProtoMessage() {}

func (x *BgpAttributes_ExtendedCommunity) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpAttributes_ExtendedCommunity.ProtoReflect.Descriptor instead.
func (*BgpAttributes_ExtendedCommunity) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15, 0}
}

func (x *BgpAttributes_ExtendedCommunity) GetType() isBgpAttributes_ExtendedCommunity_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *BgpAttributes_ExtendedCommunity) GetColor() *BgpAttributes_ExtendedCommunity_Color {
	if x != nil {
		if x, ok := x.Type.(*BgpAttributes_ExtendedCommunity_Color_); ok {
			return x.Color
		}
	}
	return nil
}

type isBgpAttributes_ExtendedCommunity_Type interface {
	isBgpAttributes_ExtendedCommunity_Type()
}

type BgpAttributes_ExtendedCommunity_Color_ struct {
	Color *BgpAttributes_ExtendedCommunity_Color `protobuf:"bytes,1,opt,name=color,proto3,oneof"`
}

func (*BgpAttributes_ExtendedCommunity_Color_) isBgpAttributes_ExtendedCommunity_Type() {}

type BgpAttributes_AsPathSegment struct {
	state         protoimpl.MessageState           `protogen:"open.v1"`
	Type          BgpAttributes_AsPathSegment_Type `protobuf:"varint,1,opt,name=type,proto3,enum=ondatra.BgpAttributes_AsPathSegment_Type" json:"type,omitempty"`
	Asns          []uint32                         `protobuf:"varint,2,rep,packed,name=asns,proto3" json:"asns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpAttributes_AsPathSegment) Reset() {
	*x = BgpAttributes_AsPathSegment{}
	mi := &file_ate_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpAttributes_AsPathSegment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpAttributes_AsPathSegment) ProtoMessage() {}

func (x *BgpAttributes_AsPathSegment) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpAttributes_AsPathSegment.ProtoReflect.Descriptor instead.
func (*BgpAttributes_AsPathSegment) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15, 1}
}

func (x *BgpAttributes_AsPathSegment) GetType() BgpAttributes_AsPathSegment_Type {
	if x != nil {
		return x.Type
	}
	return BgpAttributes_AsPathSegment_TYPE_UNSPECIFIED
}

func (x *BgpAttributes_AsPathSegment) GetAsns() []uint32 {
	if x != nil {
		return x.Asns
	}
	return nil
}

type BgpAttributes_ExtendedCommunity_Color struct {
	state         protoimpl.MessageState                       `protogen:"open.v1"`
	CoBits        BgpAttributes_ExtendedCommunity_Color_CoBits `protobuf:"varint,1,opt,name=co_bits,json=coBits,proto3,enum=ondatra.BgpAttributes_ExtendedCommunity_Color_CoBits" json:"co_bits,omitempty"`
	ReservedBits  uint32                                       `protobuf:"varint,2,opt,name=reserved_bits,json=reservedBits,proto3" json:"reserved_bits,omitempty"`
	Value         uint32                                       `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BgpAttributes_ExtendedCommunity_Color) Reset() {
	*x = BgpAttributes_ExtendedCommunity_Color{}
	mi := &file_ate_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BgpAttributes_ExtendedCommunity_Color) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BgpAttributes_ExtendedCommunity_Color) ProtoMessage() {}

func (x *BgpAttributes_ExtendedCommunity_Color) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BgpAttributes_ExtendedCommunity_Color.ProtoReflect.Descriptor instead.
func (*BgpAttributes_ExtendedCommunity_Color) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{15, 0, 0}
}

func (x *BgpAttributes_ExtendedCommunity_Color) GetCoBits() BgpAttributes_ExtendedCommunity_Color_CoBits {
	if x != nil {
		return x.CoBits
	}
	return BgpAttributes_ExtendedCommunity_Color_CO_BITS_UNSPECIFIED
}

func (x *BgpAttributes_ExtendedCommunity_Color) GetReservedBits() uint32 {
	if x != nil {
		return x.ReservedBits
	}
	return 0
}

func (x *BgpAttributes_ExtendedCommunity_Color) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type RsvpConfig_Loopback struct {
	state         protoimpl.MessageState            `protogen:"open.v1"`
	LocalIpCidr   string                            `protobuf:"bytes,1,opt,name=local_ip_cidr,json=localIpCidr,proto3" json:"local_ip_cidr,omitempty"`
	IngressLsps   []*RsvpConfig_Loopback_IngressLSP `protobuf:"bytes,2,rep,name=ingress_lsps,json=ingressLsps,proto3" json:"ingress_lsps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RsvpConfig_Loopback) Reset() {
	*x = RsvpConfig_Loopback{}
	mi := &file_ate_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RsvpConfig_Loopback) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RsvpConfig_Loopback) ProtoMessage() {}

func (x *RsvpConfig_Loopback) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RsvpConfig_Loopback.ProtoReflect.Descriptor instead.
func (*RsvpConfig_Loopback) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{16, 0}
}

func (x *RsvpConfig_Loopback) GetLocalIpCidr() string {
	if x != nil {
		return x.LocalIpCidr
	}
	return ""
}

func (x *RsvpConfig_Loopback) GetIngressLsps() []*RsvpConfig_Loopback_IngressLSP {
	if x != nil {
		return x.IngressLsps
	}
	return nil
}

type RsvpConfig_Loopback_IngressLSP struct {
	state               protoimpl.MessageState                `protogen:"open.v1"`
	RemoteIpCidr        string                                `protobuf:"bytes,1,opt,name=remote_ip_cidr,json=remoteIpCidr,proto3" json:"remote_ip_cidr,omitempty"`
	LocalProtection     bool                                  `protobuf:"varint,2,opt,name=local_protection,json=localProtection,proto3" json:"local_protection,omitempty"`
	BandwidthProtection bool                                  `protobuf:"varint,3,opt,name=bandwidth_protection,json=bandwidthProtection,proto3" json:"bandwidth_protection,omitempty"`
	FastReroute         bool                                  `protobuf:"varint,4,opt,name=fast_reroute,json=fastReroute,proto3" json:"fast_reroute,omitempty"`
	PathReoptimization  bool                                  `protobuf:"varint,5,opt,name=path_reoptimization,json=pathReoptimization,proto3" json:"path_reoptimization,omitempty"`
	TunnelId            uint32                                `protobuf:"varint,8,opt,name=tunnel_id,json=tunnelId,proto3" json:"tunnel_id,omitempty"` // Max 16-bit value in the protocol.
	LspId               uint32                                `protobuf:"varint,9,opt,name=lsp_id,json=lspId,proto3" json:"lsp_id,omitempty"`          // Max 16-bit value in the protocol.
	Eros                []*RsvpConfig_Loopback_IngressLSP_ERO `protobuf:"bytes,6,rep,name=eros,proto3" json:"eros,omitempty"`
	Rros                []*RsvpConfig_Loopback_IngressLSP_RRO `protobuf:"bytes,7,rep,name=rros,proto3" json:"rros,omitempty"` // NEXT ID: 10
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *RsvpConfig_Loopback_IngressLSP) Reset() {
	*x = RsvpConfig_Loopback_IngressLSP{}
	mi := &file_ate_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RsvpConfig_Loopback_IngressLSP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RsvpConfig_Loopback_IngressLSP) ProtoMessage() {}

func (x *RsvpConfig_Loopback_IngressLSP) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RsvpConfig_Loopback_IngressLSP.ProtoReflect.Descriptor instead.
func (*RsvpConfig_Loopback_IngressLSP) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{16, 0, 0}
}

func (x *RsvpConfig_Loopback_IngressLSP) GetRemoteIpCidr() string {
	if x != nil {
		return x.RemoteIpCidr
	}
	return ""
}

func (x *RsvpConfig_Loopback_IngressLSP) GetLocalProtection() bool {
	if x != nil {
		return x.LocalProtection
	}
	return false
}

func (x *RsvpConfig_Loopback_IngressLSP) GetBandwidthProtection() bool {
	if x != nil {
		return x.BandwidthProtection
	}
	return false
}

func (x *RsvpConfig_Loopback_IngressLSP) GetFastReroute() bool {
	if x != nil {
		return x.FastReroute
	}
	return false
}

func (x *RsvpConfig_Loopback_IngressLSP) GetPathReoptimization() bool {
	if x != nil {
		return x.PathReoptimization
	}
	return false
}

func (x *RsvpConfig_Loopback_IngressLSP) GetTunnelId() uint32 {
	if x != nil {
		return x.TunnelId
	}
	return 0
}

func (x *RsvpConfig_Loopback_IngressLSP) GetLspId() uint32 {
	if x != nil {
		return x.LspId
	}
	return 0
}

func (x *RsvpConfig_Loopback_IngressLSP) GetEros() []*RsvpConfig_Loopback_IngressLSP_ERO {
	if x != nil {
		return x.Eros
	}
	return nil
}

func (x *RsvpConfig_Loopback_IngressLSP) GetRros() []*RsvpConfig_Loopback_IngressLSP_RRO {
	if x != nil {
		return x.Rros
	}
	return nil
}

type RsvpConfig_Loopback_IngressLSP_ERO struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ipv4Cidr      string                 `protobuf:"bytes,1,opt,name=ipv4_cidr,json=ipv4Cidr,proto3" json:"ipv4_cidr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RsvpConfig_Loopback_IngressLSP_ERO) Reset() {
	*x = RsvpConfig_Loopback_IngressLSP_ERO{}
	mi := &file_ate_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RsvpConfig_Loopback_IngressLSP_ERO) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RsvpConfig_Loopback_IngressLSP_ERO) ProtoMessage() {}

func (x *RsvpConfig_Loopback_IngressLSP_ERO) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RsvpConfig_Loopback_IngressLSP_ERO.ProtoReflect.Descriptor instead.
func (*RsvpConfig_Loopback_IngressLSP_ERO) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{16, 0, 0, 0}
}

func (x *RsvpConfig_Loopback_IngressLSP_ERO) GetIpv4Cidr() string {
	if x != nil {
		return x.Ipv4Cidr
	}
	return ""
}

type RsvpConfig_Loopback_IngressLSP_RRO struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ipv4          string                 `protobuf:"bytes,1,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RsvpConfig_Loopback_IngressLSP_RRO) Reset() {
	*x = RsvpConfig_Loopback_IngressLSP_RRO{}
	mi := &file_ate_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RsvpConfig_Loopback_IngressLSP_RRO) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RsvpConfig_Loopback_IngressLSP_RRO) ProtoMessage() {}

func (x *RsvpConfig_Loopback_IngressLSP_RRO) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RsvpConfig_Loopback_IngressLSP_RRO.ProtoReflect.Descriptor instead.
func (*RsvpConfig_Loopback_IngressLSP_RRO) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{16, 0, 0, 1}
}

func (x *RsvpConfig_Loopback_IngressLSP_RRO) GetIpv4() string {
	if x != nil {
		return x.Ipv4
	}
	return ""
}

type Network_ImportedBgpRoutes struct {
	state            protoimpl.MessageState                     `protogen:"open.v1"`
	RouteTableFormat Network_ImportedBgpRoutes_RouteTableFormat `protobuf:"varint,1,opt,name=route_table_format,json=routeTableFormat,proto3,enum=ondatra.Network_ImportedBgpRoutes_RouteTableFormat" json:"route_table_format,omitempty"`
	Ipv4RoutesPath   string                                     `protobuf:"bytes,2,opt,name=ipv4_routes_path,json=ipv4RoutesPath,proto3" json:"ipv4_routes_path,omitempty"`
	Ipv6RoutesPath   string                                     `protobuf:"bytes,3,opt,name=ipv6_routes_path,json=ipv6RoutesPath,proto3" json:"ipv6_routes_path,omitempty"`
	OverwriteNexthop bool                                       `protobuf:"varint,4,opt,name=overwrite_nexthop,json=overwriteNexthop,proto3" json:"overwrite_nexthop,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Network_ImportedBgpRoutes) Reset() {
	*x = Network_ImportedBgpRoutes{}
	mi := &file_ate_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Network_ImportedBgpRoutes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Network_ImportedBgpRoutes) ProtoMessage() {}

func (x *Network_ImportedBgpRoutes) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Network_ImportedBgpRoutes.ProtoReflect.Descriptor instead.
func (*Network_ImportedBgpRoutes) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{19, 0}
}

func (x *Network_ImportedBgpRoutes) GetRouteTableFormat() Network_ImportedBgpRoutes_RouteTableFormat {
	if x != nil {
		return x.RouteTableFormat
	}
	return Network_ImportedBgpRoutes_ROUTE_TABLE_FORMAT_UNSPECIFIED
}

func (x *Network_ImportedBgpRoutes) GetIpv4RoutesPath() string {
	if x != nil {
		return x.Ipv4RoutesPath
	}
	return ""
}

func (x *Network_ImportedBgpRoutes) GetIpv6RoutesPath() string {
	if x != nil {
		return x.Ipv6RoutesPath
	}
	return ""
}

func (x *Network_ImportedBgpRoutes) GetOverwriteNexthop() bool {
	if x != nil {
		return x.OverwriteNexthop
	}
	return false
}

type Flow_Endpoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	InterfaceName string                 `protobuf:"bytes,1,opt,name=interface_name,json=interfaceName,proto3" json:"interface_name,omitempty"`
	// Empty for interface endpoints.
	//
	// Types that are valid to be assigned to Generated:
	//
	//	*Flow_Endpoint_NetworkName
	//	*Flow_Endpoint_RsvpName
	Generated     isFlow_Endpoint_Generated `protobuf_oneof:"generated"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Flow_Endpoint) Reset() {
	*x = Flow_Endpoint{}
	mi := &file_ate_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Flow_Endpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Flow_Endpoint) ProtoMessage() {}

func (x *Flow_Endpoint) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Flow_Endpoint.ProtoReflect.Descriptor instead.
func (*Flow_Endpoint) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{22, 0}
}

func (x *Flow_Endpoint) GetInterfaceName() string {
	if x != nil {
		return x.InterfaceName
	}
	return ""
}

func (x *Flow_Endpoint) GetGenerated() isFlow_Endpoint_Generated {
	if x != nil {
		return x.Generated
	}
	return nil
}

func (x *Flow_Endpoint) GetNetworkName() string {
	if x != nil {
		if x, ok := x.Generated.(*Flow_Endpoint_NetworkName); ok {
			return x.NetworkName
		}
	}
	return ""
}

func (x *Flow_Endpoint) GetRsvpName() string {
	if x != nil {
		if x, ok := x.Generated.(*Flow_Endpoint_RsvpName); ok {
			return x.RsvpName
		}
	}
	return ""
}

type isFlow_Endpoint_Generated interface {
	isFlow_Endpoint_Generated()
}

type Flow_Endpoint_NetworkName struct {
	NetworkName string `protobuf:"bytes,2,opt,name=network_name,json=networkName,proto3,oneof"`
}

type Flow_Endpoint_RsvpName struct {
	RsvpName string `protobuf:"bytes,3,opt,name=rsvp_name,json=rsvpName,proto3,oneof"`
}

func (*Flow_Endpoint_NetworkName) isFlow_Endpoint_Generated() {}

func (*Flow_Endpoint_RsvpName) isFlow_Endpoint_Generated() {}

type Flow_IngressTrackingFilters struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MplsLabel     bool                   `protobuf:"varint,1,opt,name=mpls_label,json=mplsLabel,proto3" json:"mpls_label,omitempty"`
	SrcEndpoint   bool                   `protobuf:"varint,2,opt,name=src_endpoint,json=srcEndpoint,proto3" json:"src_endpoint,omitempty"`
	DstEndpoint   bool                   `protobuf:"varint,3,opt,name=dst_endpoint,json=dstEndpoint,proto3" json:"dst_endpoint,omitempty"`
	SrcIpv4       bool                   `protobuf:"varint,4,opt,name=src_ipv4,json=srcIpv4,proto3" json:"src_ipv4,omitempty"`
	DstIpv4       bool                   `protobuf:"varint,5,opt,name=dst_ipv4,json=dstIpv4,proto3" json:"dst_ipv4,omitempty"`
	SrcIpv6       bool                   `protobuf:"varint,6,opt,name=src_ipv6,json=srcIpv6,proto3" json:"src_ipv6,omitempty"`
	DstIpv6       bool                   `protobuf:"varint,7,opt,name=dst_ipv6,json=dstIpv6,proto3" json:"dst_ipv6,omitempty"`
	Ports         bool                   `protobuf:"varint,8,opt,name=ports,proto3" json:"ports,omitempty"`
	VlanId        bool                   `protobuf:"varint,9,opt,name=vlan_id,json=vlanId,proto3" json:"vlan_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Flow_IngressTrackingFilters) Reset() {
	*x = Flow_IngressTrackingFilters{}
	mi := &file_ate_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Flow_IngressTrackingFilters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Flow_IngressTrackingFilters) ProtoMessage() {}

func (x *Flow_IngressTrackingFilters) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Flow_IngressTrackingFilters.ProtoReflect.Descriptor instead.
func (*Flow_IngressTrackingFilters) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{22, 1}
}

func (x *Flow_IngressTrackingFilters) GetMplsLabel() bool {
	if x != nil {
		return x.MplsLabel
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetSrcEndpoint() bool {
	if x != nil {
		return x.SrcEndpoint
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetDstEndpoint() bool {
	if x != nil {
		return x.DstEndpoint
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetSrcIpv4() bool {
	if x != nil {
		return x.SrcIpv4
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetDstIpv4() bool {
	if x != nil {
		return x.DstIpv4
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetSrcIpv6() bool {
	if x != nil {
		return x.SrcIpv6
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetDstIpv6() bool {
	if x != nil {
		return x.DstIpv6
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetPorts() bool {
	if x != nil {
		return x.Ports
	}
	return false
}

func (x *Flow_IngressTrackingFilters) GetVlanId() bool {
	if x != nil {
		return x.VlanId
	}
	return false
}

type FrameSize_Random struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Min           uint32                 `protobuf:"varint,1,opt,name=min,proto3" json:"min,omitempty"`
	Max           uint32                 `protobuf:"varint,2,opt,name=max,proto3" json:"max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FrameSize_Random) Reset() {
	*x = FrameSize_Random{}
	mi := &file_ate_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FrameSize_Random) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FrameSize_Random) ProtoMessage() {}

func (x *FrameSize_Random) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FrameSize_Random.ProtoReflect.Descriptor instead.
func (*FrameSize_Random) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{24, 0}
}

func (x *FrameSize_Random) GetMin() uint32 {
	if x != nil {
		return x.Min
	}
	return 0
}

func (x *FrameSize_Random) GetMax() uint32 {
	if x != nil {
		return x.Max
	}
	return 0
}

type FrameSize_ImixCustomEntry struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Size          uint32                 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	Weight        uint32                 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FrameSize_ImixCustomEntry) Reset() {
	*x = FrameSize_ImixCustomEntry{}
	mi := &file_ate_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FrameSize_ImixCustomEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FrameSize_ImixCustomEntry) ProtoMessage() {}

func (x *FrameSize_ImixCustomEntry) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FrameSize_ImixCustomEntry.ProtoReflect.Descriptor instead.
func (*FrameSize_ImixCustomEntry) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{24, 1}
}

func (x *FrameSize_ImixCustomEntry) GetSize() uint32 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *FrameSize_ImixCustomEntry) GetWeight() uint32 {
	if x != nil {
		return x.Weight
	}
	return 0
}

type FrameSize_ImixCustom struct {
	state         protoimpl.MessageState       `protogen:"open.v1"`
	Entries       []*FrameSize_ImixCustomEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FrameSize_ImixCustom) Reset() {
	*x = FrameSize_ImixCustom{}
	mi := &file_ate_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FrameSize_ImixCustom) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FrameSize_ImixCustom) ProtoMessage() {}

func (x *FrameSize_ImixCustom) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FrameSize_ImixCustom.ProtoReflect.Descriptor instead.
func (*FrameSize_ImixCustom) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{24, 2}
}

func (x *FrameSize_ImixCustom) GetEntries() []*FrameSize_ImixCustomEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

type IcmpHeader_EchoReply struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_EchoReply) Reset() {
	*x = IcmpHeader_EchoReply{}
	mi := &file_ate_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_EchoReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_EchoReply) ProtoMessage() {}

func (x *IcmpHeader_EchoReply) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_EchoReply.ProtoReflect.Descriptor instead.
func (*IcmpHeader_EchoReply) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 0}
}

type IcmpHeader_DestinationUnreachable struct {
	state         protoimpl.MessageState                 `protogen:"open.v1"`
	Code          IcmpHeader_DestinationUnreachable_Code `protobuf:"varint,1,opt,name=code,proto3,enum=ondatra.IcmpHeader_DestinationUnreachable_Code" json:"code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_DestinationUnreachable) Reset() {
	*x = IcmpHeader_DestinationUnreachable{}
	mi := &file_ate_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_DestinationUnreachable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_DestinationUnreachable) ProtoMessage() {}

func (x *IcmpHeader_DestinationUnreachable) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_DestinationUnreachable.ProtoReflect.Descriptor instead.
func (*IcmpHeader_DestinationUnreachable) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 1}
}

func (x *IcmpHeader_DestinationUnreachable) GetCode() IcmpHeader_DestinationUnreachable_Code {
	if x != nil {
		return x.Code
	}
	return IcmpHeader_DestinationUnreachable_CODE_UNSPECIFIED
}

type IcmpHeader_RedirectMessage struct {
	state         protoimpl.MessageState          `protogen:"open.v1"`
	Code          IcmpHeader_RedirectMessage_Code `protobuf:"varint,1,opt,name=code,proto3,enum=ondatra.IcmpHeader_RedirectMessage_Code" json:"code,omitempty"`
	IpAddr        string                          `protobuf:"bytes,2,opt,name=ip_addr,json=ipAddr,proto3" json:"ip_addr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_RedirectMessage) Reset() {
	*x = IcmpHeader_RedirectMessage{}
	mi := &file_ate_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_RedirectMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_RedirectMessage) ProtoMessage() {}

func (x *IcmpHeader_RedirectMessage) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_RedirectMessage.ProtoReflect.Descriptor instead.
func (*IcmpHeader_RedirectMessage) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 2}
}

func (x *IcmpHeader_RedirectMessage) GetCode() IcmpHeader_RedirectMessage_Code {
	if x != nil {
		return x.Code
	}
	return IcmpHeader_RedirectMessage_CODE_UNSPECIFIED
}

func (x *IcmpHeader_RedirectMessage) GetIpAddr() string {
	if x != nil {
		return x.IpAddr
	}
	return ""
}

type IcmpHeader_EchoRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_EchoRequest) Reset() {
	*x = IcmpHeader_EchoRequest{}
	mi := &file_ate_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_EchoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_EchoRequest) ProtoMessage() {}

func (x *IcmpHeader_EchoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_EchoRequest.ProtoReflect.Descriptor instead.
func (*IcmpHeader_EchoRequest) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 3}
}

type IcmpHeader_TimeExceeded struct {
	state         protoimpl.MessageState       `protogen:"open.v1"`
	Code          IcmpHeader_TimeExceeded_Code `protobuf:"varint,1,opt,name=code,proto3,enum=ondatra.IcmpHeader_TimeExceeded_Code" json:"code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_TimeExceeded) Reset() {
	*x = IcmpHeader_TimeExceeded{}
	mi := &file_ate_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_TimeExceeded) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_TimeExceeded) ProtoMessage() {}

func (x *IcmpHeader_TimeExceeded) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_TimeExceeded.ProtoReflect.Descriptor instead.
func (*IcmpHeader_TimeExceeded) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 4}
}

func (x *IcmpHeader_TimeExceeded) GetCode() IcmpHeader_TimeExceeded_Code {
	if x != nil {
		return x.Code
	}
	return IcmpHeader_TimeExceeded_CODE_UNSPECIFIED
}

type IcmpHeader_ParameterProblem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pointer       uint32                 `protobuf:"varint,1,opt,name=pointer,proto3" json:"pointer,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_ParameterProblem) Reset() {
	*x = IcmpHeader_ParameterProblem{}
	mi := &file_ate_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_ParameterProblem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_ParameterProblem) ProtoMessage() {}

func (x *IcmpHeader_ParameterProblem) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_ParameterProblem.ProtoReflect.Descriptor instead.
func (*IcmpHeader_ParameterProblem) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 5}
}

func (x *IcmpHeader_ParameterProblem) GetPointer() uint32 {
	if x != nil {
		return x.Pointer
	}
	return 0
}

type IcmpHeader_Timestamp struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Seq           uint32                 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	OriginateTs   uint32                 `protobuf:"varint,3,opt,name=originate_ts,json=originateTs,proto3" json:"originate_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_Timestamp) Reset() {
	*x = IcmpHeader_Timestamp{}
	mi := &file_ate_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_Timestamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_Timestamp) ProtoMessage() {}

func (x *IcmpHeader_Timestamp) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_Timestamp.ProtoReflect.Descriptor instead.
func (*IcmpHeader_Timestamp) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 6}
}

func (x *IcmpHeader_Timestamp) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *IcmpHeader_Timestamp) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

func (x *IcmpHeader_Timestamp) GetOriginateTs() uint32 {
	if x != nil {
		return x.OriginateTs
	}
	return 0
}

type IcmpHeader_TimestampReply struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            uint32                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Seq           uint32                 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	OriginateTs   uint32                 `protobuf:"varint,3,opt,name=originate_ts,json=originateTs,proto3" json:"originate_ts,omitempty"`
	ReceiveTs     uint32                 `protobuf:"varint,4,opt,name=receive_ts,json=receiveTs,proto3" json:"receive_ts,omitempty"`
	TransmitTs    uint32                 `protobuf:"varint,5,opt,name=transmit_ts,json=transmitTs,proto3" json:"transmit_ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IcmpHeader_TimestampReply) Reset() {
	*x = IcmpHeader_TimestampReply{}
	mi := &file_ate_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IcmpHeader_TimestampReply) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IcmpHeader_TimestampReply) ProtoMessage() {}

func (x *IcmpHeader_TimestampReply) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IcmpHeader_TimestampReply.ProtoReflect.Descriptor instead.
func (*IcmpHeader_TimestampReply) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{37, 7}
}

func (x *IcmpHeader_TimestampReply) GetId() uint32 {
	if x != nil {
		return x.Id
	}
	return 0
}

func (x *IcmpHeader_TimestampReply) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

func (x *IcmpHeader_TimestampReply) GetOriginateTs() uint32 {
	if x != nil {
		return x.OriginateTs
	}
	return 0
}

func (x *IcmpHeader_TimestampReply) GetReceiveTs() uint32 {
	if x != nil {
		return x.ReceiveTs
	}
	return 0
}

func (x *IcmpHeader_TimestampReply) GetTransmitTs() uint32 {
	if x != nil {
		return x.TransmitTs
	}
	return 0
}

type OspfHeader_Hello struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	NetworkMaskLength      uint32                 `protobuf:"varint,1,opt,name=network_mask_length,json=networkMaskLength,proto3" json:"network_mask_length,omitempty"`
	HelloIntervalSec       uint32                 `protobuf:"varint,2,opt,name=hello_interval_sec,json=helloIntervalSec,proto3" json:"hello_interval_sec,omitempty"`
	RouterPriority         uint32                 `protobuf:"varint,3,opt,name=router_priority,json=routerPriority,proto3" json:"router_priority,omitempty"`
	RouterDeadIntervalSec  uint32                 `protobuf:"varint,4,opt,name=router_dead_interval_sec,json=routerDeadIntervalSec,proto3" json:"router_dead_interval_sec,omitempty"`
	DesignatedRouter       string                 `protobuf:"bytes,5,opt,name=designated_router,json=designatedRouter,proto3" json:"designated_router,omitempty"`
	BackupDesignatedRouter string                 `protobuf:"bytes,6,opt,name=backup_designated_router,json=backupDesignatedRouter,proto3" json:"backup_designated_router,omitempty"`
	Neighbors              []string               `protobuf:"bytes,7,rep,name=neighbors,proto3" json:"neighbors,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *OspfHeader_Hello) Reset() {
	*x = OspfHeader_Hello{}
	mi := &file_ate_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader_Hello) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader_Hello) ProtoMessage() {}

func (x *OspfHeader_Hello) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader_Hello.ProtoReflect.Descriptor instead.
func (*OspfHeader_Hello) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 0}
}

func (x *OspfHeader_Hello) GetNetworkMaskLength() uint32 {
	if x != nil {
		return x.NetworkMaskLength
	}
	return 0
}

func (x *OspfHeader_Hello) GetHelloIntervalSec() uint32 {
	if x != nil {
		return x.HelloIntervalSec
	}
	return 0
}

func (x *OspfHeader_Hello) GetRouterPriority() uint32 {
	if x != nil {
		return x.RouterPriority
	}
	return 0
}

func (x *OspfHeader_Hello) GetRouterDeadIntervalSec() uint32 {
	if x != nil {
		return x.RouterDeadIntervalSec
	}
	return 0
}

func (x *OspfHeader_Hello) GetDesignatedRouter() string {
	if x != nil {
		return x.DesignatedRouter
	}
	return ""
}

func (x *OspfHeader_Hello) GetBackupDesignatedRouter() string {
	if x != nil {
		return x.BackupDesignatedRouter
	}
	return ""
}

func (x *OspfHeader_Hello) GetNeighbors() []string {
	if x != nil {
		return x.Neighbors
	}
	return nil
}

type OspfHeader_DatabaseDescription struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Mtu           uint32                 `protobuf:"varint,1,opt,name=mtu,proto3" json:"mtu,omitempty"`
	Initial       bool                   `protobuf:"varint,2,opt,name=initial,proto3" json:"initial,omitempty"`
	More          bool                   `protobuf:"varint,3,opt,name=more,proto3" json:"more,omitempty"`
	Master        bool                   `protobuf:"varint,4,opt,name=master,proto3" json:"master,omitempty"`
	Seq           uint32                 `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OspfHeader_DatabaseDescription) Reset() {
	*x = OspfHeader_DatabaseDescription{}
	mi := &file_ate_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader_DatabaseDescription) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader_DatabaseDescription) ProtoMessage() {}

func (x *OspfHeader_DatabaseDescription) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader_DatabaseDescription.ProtoReflect.Descriptor instead.
func (*OspfHeader_DatabaseDescription) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 1}
}

func (x *OspfHeader_DatabaseDescription) GetMtu() uint32 {
	if x != nil {
		return x.Mtu
	}
	return 0
}

func (x *OspfHeader_DatabaseDescription) GetInitial() bool {
	if x != nil {
		return x.Initial
	}
	return false
}

func (x *OspfHeader_DatabaseDescription) GetMore() bool {
	if x != nil {
		return x.More
	}
	return false
}

func (x *OspfHeader_DatabaseDescription) GetMaster() bool {
	if x != nil {
		return x.Master
	}
	return false
}

func (x *OspfHeader_DatabaseDescription) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

type OspfHeader_LinkStateRequest struct {
	state             protoimpl.MessageState   `protogen:"open.v1"`
	Type              OspfHeader_LinkStateType `protobuf:"varint,1,opt,name=type,proto3,enum=ondatra.OspfHeader_LinkStateType" json:"type,omitempty"`
	LinkStateId       string                   `protobuf:"bytes,2,opt,name=link_state_id,json=linkStateId,proto3" json:"link_state_id,omitempty"`
	AdvertisingRouter string                   `protobuf:"bytes,3,opt,name=advertising_router,json=advertisingRouter,proto3" json:"advertising_router,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *OspfHeader_LinkStateRequest) Reset() {
	*x = OspfHeader_LinkStateRequest{}
	mi := &file_ate_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader_LinkStateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader_LinkStateRequest) ProtoMessage() {}

func (x *OspfHeader_LinkStateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader_LinkStateRequest.ProtoReflect.Descriptor instead.
func (*OspfHeader_LinkStateRequest) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 2}
}

func (x *OspfHeader_LinkStateRequest) GetType() OspfHeader_LinkStateType {
	if x != nil {
		return x.Type
	}
	return OspfHeader_LINK_STATE_TYPE_UNSPECIFIED
}

func (x *OspfHeader_LinkStateRequest) GetLinkStateId() string {
	if x != nil {
		return x.LinkStateId
	}
	return ""
}

func (x *OspfHeader_LinkStateRequest) GetAdvertisingRouter() string {
	if x != nil {
		return x.AdvertisingRouter
	}
	return ""
}

type OspfHeader_LinkStateAdvertisementHeader struct {
	state             protoimpl.MessageState   `protogen:"open.v1"`
	AgeSeconds        uint32                   `protobuf:"varint,1,opt,name=age_seconds,json=ageSeconds,proto3" json:"age_seconds,omitempty"`
	Type              OspfHeader_LinkStateType `protobuf:"varint,2,opt,name=type,proto3,enum=ondatra.OspfHeader_LinkStateType" json:"type,omitempty"`
	LinkStateId       string                   `protobuf:"bytes,3,opt,name=link_state_id,json=linkStateId,proto3" json:"link_state_id,omitempty"`
	AdvertisingRouter string                   `protobuf:"bytes,4,opt,name=advertising_router,json=advertisingRouter,proto3" json:"advertising_router,omitempty"`
	Seq               uint32                   `protobuf:"varint,5,opt,name=seq,proto3" json:"seq,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *OspfHeader_LinkStateAdvertisementHeader) Reset() {
	*x = OspfHeader_LinkStateAdvertisementHeader{}
	mi := &file_ate_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader_LinkStateAdvertisementHeader) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader_LinkStateAdvertisementHeader) ProtoMessage() {}

func (x *OspfHeader_LinkStateAdvertisementHeader) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader_LinkStateAdvertisementHeader.ProtoReflect.Descriptor instead.
func (*OspfHeader_LinkStateAdvertisementHeader) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 3}
}

func (x *OspfHeader_LinkStateAdvertisementHeader) GetAgeSeconds() uint32 {
	if x != nil {
		return x.AgeSeconds
	}
	return 0
}

func (x *OspfHeader_LinkStateAdvertisementHeader) GetType() OspfHeader_LinkStateType {
	if x != nil {
		return x.Type
	}
	return OspfHeader_LINK_STATE_TYPE_UNSPECIFIED
}

func (x *OspfHeader_LinkStateAdvertisementHeader) GetLinkStateId() string {
	if x != nil {
		return x.LinkStateId
	}
	return ""
}

func (x *OspfHeader_LinkStateAdvertisementHeader) GetAdvertisingRouter() string {
	if x != nil {
		return x.AdvertisingRouter
	}
	return ""
}

func (x *OspfHeader_LinkStateAdvertisementHeader) GetSeq() uint32 {
	if x != nil {
		return x.Seq
	}
	return 0
}

type OspfHeader_LinkStateUpdate struct {
	state          protoimpl.MessageState                      `protogen:"open.v1"`
	Advertisements []*OspfHeader_LinkStateUpdate_Advertisement `protobuf:"bytes,1,rep,name=advertisements,proto3" json:"advertisements,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *OspfHeader_LinkStateUpdate) Reset() {
	*x = OspfHeader_LinkStateUpdate{}
	mi := &file_ate_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader_LinkStateUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader_LinkStateUpdate) ProtoMessage() {}

func (x *OspfHeader_LinkStateUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader_LinkStateUpdate.ProtoReflect.Descriptor instead.
func (*OspfHeader_LinkStateUpdate) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 4}
}

func (x *OspfHeader_LinkStateUpdate) GetAdvertisements() []*OspfHeader_LinkStateUpdate_Advertisement {
	if x != nil {
		return x.Advertisements
	}
	return nil
}

type OspfHeader_LinkStateAck struct {
	state         protoimpl.MessageState                     `protogen:"open.v1"`
	Headers       []*OspfHeader_LinkStateAdvertisementHeader `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OspfHeader_LinkStateAck) Reset() {
	*x = OspfHeader_LinkStateAck{}
	mi := &file_ate_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader_LinkStateAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader_LinkStateAck) ProtoMessage() {}

func (x *OspfHeader_LinkStateAck) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader_LinkStateAck.ProtoReflect.Descriptor instead.
func (*OspfHeader_LinkStateAck) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 5}
}

func (x *OspfHeader_LinkStateAck) GetHeaders() []*OspfHeader_LinkStateAdvertisementHeader {
	if x != nil {
		return x.Headers
	}
	return nil
}

type OspfHeader_LinkStateUpdate_Advertisement struct {
	state         protoimpl.MessageState                   `protogen:"open.v1"`
	Header        *OspfHeader_LinkStateAdvertisementHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OspfHeader_LinkStateUpdate_Advertisement) Reset() {
	*x = OspfHeader_LinkStateUpdate_Advertisement{}
	mi := &file_ate_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OspfHeader_LinkStateUpdate_Advertisement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OspfHeader_LinkStateUpdate_Advertisement) ProtoMessage() {}

func (x *OspfHeader_LinkStateUpdate_Advertisement) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OspfHeader_LinkStateUpdate_Advertisement.ProtoReflect.Descriptor instead.
func (*OspfHeader_LinkStateUpdate_Advertisement) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{38, 4, 0}
}

func (x *OspfHeader_LinkStateUpdate_Advertisement) GetHeader() *OspfHeader_LinkStateAdvertisementHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

type PimHeader_Hello struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PimHeader_Hello) Reset() {
	*x = PimHeader_Hello{}
	mi := &file_ate_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PimHeader_Hello) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PimHeader_Hello) ProtoMessage() {}

func (x *PimHeader_Hello) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PimHeader_Hello.ProtoReflect.Descriptor instead.
func (*PimHeader_Hello) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{40, 0}
}

type LdpHeader_Hello struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	HoldTimeSec     uint32                 `protobuf:"varint,1,opt,name=hold_time_sec,json=holdTimeSec,proto3" json:"hold_time_sec,omitempty"`
	Targeted        bool                   `protobuf:"varint,2,opt,name=targeted,proto3" json:"targeted,omitempty"`
	RequestTargeted bool                   `protobuf:"varint,3,opt,name=request_targeted,json=requestTargeted,proto3" json:"request_targeted,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *LdpHeader_Hello) Reset() {
	*x = LdpHeader_Hello{}
	mi := &file_ate_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LdpHeader_Hello) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LdpHeader_Hello) ProtoMessage() {}

func (x *LdpHeader_Hello) ProtoReflect() protoreflect.Message {
	mi := &file_ate_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LdpHeader_Hello.ProtoReflect.Descriptor instead.
func (*LdpHeader_Hello) Descriptor() ([]byte, []int) {
	return file_ate_proto_rawDescGZIP(), []int{41, 0}
}

func (x *LdpHeader_Hello) GetHoldTimeSec() uint32 {
	if x != nil {
		return x.HoldTimeSec
	}
	return 0
}

func (x *LdpHeader_Hello) GetTargeted() bool {
	if x != nil {
		return x.Targeted
	}
	return false
}

func (x *LdpHeader_Hello) GetRequestTargeted() bool {
	if x != nil {
		return x.RequestTargeted
	}
	return false
}

var File_ate_proto protoreflect.FileDescriptor

const file_ate_proto_rawDesc = "" +
	"\n" +
	"\tate.proto\x12\aondatra\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/protobuf/empty.proto\".\n" +
	"\aTraffic\x12#\n" +
	"\x05flows\x18\x02 \x03(\v2\r.ondatra.FlowR\x05flows\"\xa1\x01\n" +
	"\x03Lag\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05ports\x18\x02 \x03(\tR\x05ports\x12%\n" +
	"\x04lacp\x18\x03 \x01(\v2\x11.ondatra.Lag.LacpR\x04lacp\x12'\n" +
	"\x06macsec\x18\x04 \x01(\v2\x0f.ondatra.MacSecR\x06macsec\x1a \n" +
	"\x04Lacp\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\"\xf7\x04\n" +
	"\x0fInterfaceConfig\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x04port\x18\x02 \x01(\tH\x00R\x04port\x12\x12\n" +
	"\x03lag\x18\x03 \x01(\tH\x00R\x03lag\x123\n" +
	"\bethernet\x18\x04 \x01(\v2\x17.ondatra.EthernetConfigR\bethernet\x12%\n" +
	"\x04ipv4\x18\x05 \x01(\v2\x11.ondatra.IpConfigR\x04ipv4\x12%\n" +
	"\x04ipv6\x18\x06 \x01(\v2\x11.ondatra.IpConfigR\x04ipv6\x12,\n" +
	"\x12ipv4_loopback_cidr\x18\v \x01(\tR\x10ipv4LoopbackCidr\x12,\n" +
	"\x12ipv6_loopback_cidr\x18\r \x01(\tR\x10ipv6LoopbackCidr\x12'\n" +
	"\x04isis\x18\a \x01(\v2\x13.ondatra.ISISConfigR\x04isis\x12$\n" +
	"\x03bgp\x18\b \x01(\v2\x12.ondatra.BgpConfigR\x03bgp\x12)\n" +
	"\x05rsvps\x18\f \x03(\v2\x13.ondatra.RsvpConfigR\x05rsvps\x12:\n" +
	"\rdhcpv6_client\x18\x0f \x01(\v2\x15.ondatra.DhcpV6ClientR\fdhcpv6Client\x12:\n" +
	"\rdhcpv6_server\x18\x10 \x01(\v2\x15.ondatra.DhcpV6ServerR\fdhcpv6Server\x12,\n" +
	"\bnetworks\x18\t \x03(\v2\x10.ondatra.NetworkR\bnetworks\x12\x1f\n" +
	"\venable_lacp\x18\n" +
	" \x01(\bR\n" +
	"enableLacpB\x06\n" +
	"\x04link\"\x84\x01\n" +
	"\x0eEthernetConfig\x12\x10\n" +
	"\x03mtu\x18\x01 \x01(\rR\x03mtu\x12\x17\n" +
	"\avlan_id\x18\x02 \x01(\rR\x06vlanId\x12'\n" +
	"\x06macsec\x18\x03 \x01(\v2\x0f.ondatra.MacSecR\x06macsec\x12\x1e\n" +
	"\x03fec\x18\x04 \x01(\v2\f.ondatra.FecR\x03fec\"\x1f\n" +
	"\x03Fec\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\"\xce\n" +
	"\n" +
	"\x06MacSec\x12>\n" +
	"\fcipher_suite\x18\x01 \x01(\x0e2\x1b.ondatra.MacSec.CipherSuiteR\vcipherSuite\x126\n" +
	"\x17encrypted_vlans_enabled\x18\x02 \x01(\bR\x15encryptedVlansEnabled\x126\n" +
	"\x17cleartext_ethernet_vlan\x18\x05 \x01(\bR\x15cleartextEthernetVlan\x12)\n" +
	"\x11rx_sec_tag_offset\x18\x06 \x01(\rR\x0erxSecTagOffset\x122\n" +
	"\vrx_sak_pool\x18\x03 \x01(\v2\x12.ondatra.RxSakPoolR\trxSakPool\x12%\n" +
	"\x03mka\x18\x04 \x01(\v2\x13.ondatra.MacSec.MKAR\x03mka\x1a\xa4\a\n" +
	"\x03MKA\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12>\n" +
	"\n" +
	"capability\x18\x02 \x01(\x0e2\x1e.ondatra.MacSec.MKA.CapabilityR\n" +
	"capability\x12`\n" +
	"\x16confidentiality_offset\x18\x03 \x01(\x0e2).ondatra.MacSec.MKA.ConfidentialityOffsetR\x15confidentialityOffset\x12>\n" +
	"\fcipher_suite\x18\x04 \x01(\x0e2\x1b.ondatra.MacSec.CipherSuiteR\vcipherSuite\x12a\n" +
	"\x17key_derivation_function\x18\x06 \x01(\x0e2).ondatra.MacSec.MKA.KeyDerivationFunctionR\x15keyDerivationFunction\x12f\n" +
	"\x18connectivity_association\x18\x05 \x01(\v2+.ondatra.MacSec.MKA.ConnectivityAssociationR\x17connectivityAssociation\x1a=\n" +
	"\x17ConnectivityAssociation\x12\x10\n" +
	"\x03ckn\x18\x01 \x01(\tR\x03ckn\x12\x10\n" +
	"\x03cak\x18\x02 \x01(\tR\x03cak\"\xbd\x01\n" +
	"\n" +
	"Capability\x12\x1a\n" +
	"\x16CAPABILITY_UNSPECIFIED\x10\x00\x12\x13\n" +
	"\x0fNOT_IMPLEMENTED\x10\x01\x12%\n" +
	"!INTEGRITY_WITHOUT_CONFIDENTIALITY\x10\x02\x12,\n" +
	"(INTEGRITY_WITH_NO_CONFIDENTIALITY_OFFSET\x10\x03\x12)\n" +
	"%INTEGRITY_WITH_CONFIDENTIALITY_OFFSET\x10\x04\"z\n" +
	"\x15ConfidentialityOffset\x12\x16\n" +
	"\x12OFFSET_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19OFFSET_NO_CONFIDENTIALITY\x10\x04\x12\f\n" +
	"\bOFFSET_0\x10\x01\x12\r\n" +
	"\tOFFSET_30\x10\x02\x12\r\n" +
	"\tOFFSET_50\x10\x03\"[\n" +
	"\x15KeyDerivationFunction\x12\x1e\n" +
	"\x1aKEY_DERIVATION_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fAES_128_CMAC\x10\x01\x12\x10\n" +
	"\fAES_256_CMAC\x10\x02\"g\n" +
	"\vCipherSuite\x12\x1c\n" +
	"\x18CIPHER_SUITE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aAES_128\x10\x01\x12\v\n" +
	"\aAES_256\x10\x02\x12\x0f\n" +
	"\vAES_XPN_128\x10\x03\x12\x0f\n" +
	"\vAES_XPN_256\x10\x04\";\n" +
	"\tRxSakPool\x12\x16\n" +
	"\x06sak128\x18\n" +
	" \x01(\tR\x06sak128\x12\x16\n" +
	"\x06sak256\x18\v \x01(\tR\x06sak256\"V\n" +
	"\bIpConfig\x12!\n" +
	"\faddress_cidr\x18\x01 \x01(\tR\vaddressCidr\x12'\n" +
	"\x0fdefault_gateway\x18\x02 \x01(\tR\x0edefaultGateway\"\xf3\t\n" +
	"\n" +
	"ISISConfig\x12/\n" +
	"\x05level\x18\x01 \x01(\x0e2\x19.ondatra.ISISConfig.LevelR\x05level\x12\x16\n" +
	"\x06metric\x18\x02 \x01(\rR\x06metric\x12\x17\n" +
	"\aarea_id\x18\x03 \x01(\tR\x06areaId\x12,\n" +
	"\x12enable_wide_metric\x18\x04 \x01(\bR\x10enableWideMetric\x12B\n" +
	"\fnetwork_type\x18\x05 \x01(\x0e2\x1f.ondatra.ISISConfig.NetworkTypeR\vnetworkType\x129\n" +
	"\tauth_type\x18\x06 \x01(\x0e2\x1c.ondatra.ISISConfig.AuthTypeR\bauthType\x12\x19\n" +
	"\bauth_key\x18\a \x01(\tR\aauthKey\x12B\n" +
	"\x0earea_auth_type\x18\x13 \x01(\x0e2\x1c.ondatra.ISISConfig.AuthTypeR\fareaAuthType\x12\"\n" +
	"\rarea_auth_key\x18\x14 \x01(\tR\vareaAuthKey\x12F\n" +
	"\x10domain_auth_type\x18\x15 \x01(\x0e2\x1c.ondatra.ISISConfig.AuthTypeR\x0edomainAuthType\x12&\n" +
	"\x0fdomain_auth_key\x18\x16 \x01(\tR\rdomainAuthKey\x120\n" +
	"\x14enable_hello_padding\x18\b \x01(\bR\x12enableHelloPadding\x12\x1b\n" +
	"\tenable_te\x18\t \x01(\bR\benableTe\x12!\n" +
	"\fdiscard_lsps\x18\n" +
	" \x01(\bR\vdiscardLsps\x12 \n" +
	"\fte_router_id\x18\v \x01(\tR\n" +
	"teRouterId\x12@\n" +
	"\x0fip_reachability\x18\f \x01(\v2\x17.ondatra.IPReachabilityR\x0eipReachability\x12D\n" +
	"\x11is_reachabilities\x18\r \x03(\v2\x17.ondatra.ISReachabilityR\x10isReachabilities\x12-\n" +
	"\x12interface_priority\x18\x0e \x01(\rR\x11interfacePriority\x12,\n" +
	"\x12hello_interval_sec\x18\x0f \x01(\rR\x10helloIntervalSec\x12*\n" +
	"\x11dead_interval_sec\x18\x10 \x01(\rR\x0fdeadIntervalSec\x12D\n" +
	"\x0fsegment_routing\x18\x11 \x01(\v2\x1b.ondatra.ISISSegmentRoutingR\x0esegmentRouting\x120\n" +
	"\x14capability_router_id\x18\x12 \x01(\tR\x12capabilityRouterId\"8\n" +
	"\x05Level\x12\x15\n" +
	"\x11LEVEL_UNSPECIFIED\x10\x00\x12\x06\n" +
	"\x02L1\x10\x01\x12\x06\n" +
	"\x02L2\x10\x02\x12\b\n" +
	"\x04L1L2\x10\x03\"N\n" +
	"\vNetworkType\x12\x1c\n" +
	"\x18NETWORK_TYPE_UNSPECIFIED\x10\x00\x12\r\n" +
	"\tBROADCAST\x10\x01\x12\x12\n" +
	"\x0ePOINT_TO_POINT\x10\x02\"<\n" +
	"\bAuthType\x12\x19\n" +
	"\x15AUTH_TYPE_UNSPECIFIED\x10\x00\x12\a\n" +
	"\x03MD5\x10\x01\x12\f\n" +
	"\bPASSWORD\x10\x02\"\xd3\a\n" +
	"\x12ISISSegmentRouting\x12\x16\n" +
	"\x06enable\x18\x01 \x01(\bR\x06enable\x12M\n" +
	"\radjacency_sid\x18\x02 \x01(\v2(.ondatra.ISISSegmentRouting.AdjacencySIDR\fadjacencySid\x12&\n" +
	"\x0fsid_index_label\x18\x03 \x01(\rR\rsidIndexLabel\x12E\n" +
	"\vsrgb_ranges\x18\x04 \x03(\v2$.ondatra.ISISSegmentRouting.SIDRangeR\n" +
	"srgbRanges\x12E\n" +
	"\vsrlb_ranges\x18\x05 \x03(\v2$.ondatra.ISISSegmentRouting.SIDRangeR\n" +
	"srlbRanges\x12)\n" +
	"\x10flag_readvertise\x18\x06 \x01(\bR\x0fflagReadvertise\x12\"\n" +
	"\rflag_node_sid\x18\a \x01(\bR\vflagNodeSid\x12\x1e\n" +
	"\vflag_no_php\x18\b \x01(\bR\tflagNoPhp\x12,\n" +
	"\x12flag_explicit_null\x18\t \x01(\bR\x10flagExplicitNull\x12\x1d\n" +
	"\n" +
	"flag_value\x18\n" +
	" \x01(\bR\tflagValue\x12\x1d\n" +
	"\n" +
	"flag_local\x18\v \x01(\bR\tflagLocal\x12\x1e\n" +
	"\n" +
	"algorithms\x18\f \x03(\rR\n" +
	"algorithms\x12\x1d\n" +
	"\n" +
	"prefix_sid\x18\r \x01(\tR\tprefixSid\x1a\xb4\x02\n" +
	"\fAdjacencySID\x12\x10\n" +
	"\x03sid\x18\x01 \x01(\tR\x03sid\x12?\n" +
	"\x1coverride_flag_address_family\x18\x02 \x01(\bR\x19overrideFlagAddressFamily\x12.\n" +
	"\x13flag_address_family\x18\x03 \x01(\bR\x11flagAddressFamily\x12\x1f\n" +
	"\vflag_backup\x18\x04 \x01(\bR\n" +
	"flagBackup\x12\x1d\n" +
	"\n" +
	"flag_value\x18\x05 \x01(\bR\tflagValue\x12\x1d\n" +
	"\n" +
	"flag_local\x18\x06 \x01(\bR\tflagLocal\x12\x19\n" +
	"\bflag_set\x18\a \x01(\bR\aflagSet\x12'\n" +
	"\x0fflag_persistent\x18\b \x01(\bR\x0eflagPersistent\x1aO\n" +
	"\bSIDRange\x12&\n" +
	"\x0fsid_start_label\x18\x01 \x01(\rR\rsidStartLabel\x12\x1b\n" +
	"\tsid_count\x18\x02 \x01(\rR\bsidCount\"\xa7\x04\n" +
	"\x0eIPReachability\x12\x16\n" +
	"\x06metric\x18\x01 \x01(\rR\x06metric\x12F\n" +
	"\froute_origin\x18\x02 \x01(\x0e2#.ondatra.IPReachability.RouteOriginR\vrouteOrigin\x12\x1c\n" +
	"\talgorithm\x18\x03 \x01(\rR\talgorithm\x12&\n" +
	"\x0fsid_index_label\x18\x04 \x01(\rR\rsidIndexLabel\x12)\n" +
	"\x10flag_readvertise\x18\x05 \x01(\bR\x0fflagReadvertise\x12\"\n" +
	"\rflag_node_sid\x18\x06 \x01(\bR\vflagNodeSid\x12\x1e\n" +
	"\vflag_no_php\x18\a \x01(\bR\tflagNoPhp\x12,\n" +
	"\x12flag_explicit_null\x18\b \x01(\bR\x10flagExplicitNull\x12\x1d\n" +
	"\n" +
	"flag_value\x18\t \x01(\bR\tflagValue\x12\x1d\n" +
	"\n" +
	"flag_local\x18\n" +
	" \x01(\bR\tflagLocal\x123\n" +
	"\x16enable_sid_index_label\x18\v \x01(\bR\x13enableSidIndexLabel\x12\x16\n" +
	"\x06active\x18\f \x01(\bR\x06active\"G\n" +
	"\vRouteOrigin\x12\x1c\n" +
	"\x18ROUTE_ORIGIN_UNSPECIFIED\x10\x00\x12\f\n" +
	"\bINTERNAL\x10\x01\x12\f\n" +
	"\bEXTERNAL\x10\x02\"\xe6\x06\n" +
	"\x0eISReachability\x122\n" +
	"\x05nodes\x18\x01 \x03(\v2\x1c.ondatra.ISReachability.NodeR\x05nodes\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x1a\x8b\x06\n" +
	"\x04Node\x12%\n" +
	"\x0eingress_metric\x18\x01 \x01(\rR\ringressMetric\x12#\n" +
	"\regress_metric\x18\x02 \x01(\rR\fegressMetric\x12\x1b\n" +
	"\tsystem_id\x18\x03 \x01(\tR\bsystemId\x127\n" +
	"\x05links\x18\x04 \x03(\v2!.ondatra.ISReachability.Node.LinkR\x05links\x12\x1b\n" +
	"\tenable_te\x18\x06 \x01(\bR\benableTe\x12,\n" +
	"\x12enable_wide_metric\x18\a \x01(\bR\x10enableWideMetric\x12D\n" +
	"\x0fsegment_routing\x18\b \x01(\v2\x1b.ondatra.ISISSegmentRoutingR\x0esegmentRouting\x12 \n" +
	"\fte_router_id\x18\t \x01(\tR\n" +
	"teRouterId\x12D\n" +
	"\vroutes_ipv4\x18\n" +
	" \x01(\v2#.ondatra.ISReachability.Node.RoutesR\n" +
	"routesIpv4\x12D\n" +
	"\vroutes_ipv6\x18\f \x01(\v2#.ondatra.ISReachability.Node.RoutesR\n" +
	"routesIpv6\x120\n" +
	"\x14capability_router_id\x18\v \x01(\tR\x12capabilityRouterId\x1ar\n" +
	"\x04Link\x12\x1b\n" +
	"\tfrom_ipv4\x18\x01 \x01(\tR\bfromIpv4\x12\x17\n" +
	"\ato_ipv4\x18\x02 \x01(\tR\x06toIpv4\x12\x1b\n" +
	"\tfrom_ipv6\x18\x03 \x01(\tR\bfromIpv6\x12\x17\n" +
	"\ato_ipv6\x18\x04 \x01(\tR\x06toIpv6\x1a|\n" +
	"\x06Routes\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x1d\n" +
	"\n" +
	"num_routes\x18\x02 \x01(\x04R\tnumRoutes\x12;\n" +
	"\freachability\x18\x03 \x01(\v2\x17.ondatra.IPReachabilityR\freachability\"\xe9\x01\n" +
	"\x0eBgpCommunities\x12\x1b\n" +
	"\tno_export\x18\x01 \x01(\bR\bnoExport\x12!\n" +
	"\fno_advertise\x18\x02 \x01(\bR\vnoAdvertise\x12.\n" +
	"\x13no_export_subconfed\x18\x03 \x01(\bR\x11noExportSubconfed\x12\x1d\n" +
	"\n" +
	"llgr_stale\x18\x04 \x01(\bR\tllgrStale\x12\x17\n" +
	"\ano_llgr\x18\x05 \x01(\bR\x06noLlgr\x12/\n" +
	"\x13private_communities\x18\x06 \x03(\tR\x12privateCommunities\":\n" +
	"\tBgpConfig\x12-\n" +
	"\tbgp_peers\x18\x01 \x03(\v2\x10.ondatra.BgpPeerR\bbgpPeers\"\xa6\x1a\n" +
	"\aBgpPeer\x12\x0e\n" +
	"\x02id\x18\v \x01(\rR\x02id\x12\x16\n" +
	"\x06active\x18\x01 \x01(\bR\x06active\x12\x1f\n" +
	"\von_loopback\x18\n" +
	" \x01(\bR\n" +
	"onLoopback\x12)\n" +
	"\x04type\x18\x02 \x01(\x0e2\x15.ondatra.BgpPeer.TypeR\x04type\x12!\n" +
	"\fpeer_address\x18\x03 \x01(\tR\vpeerAddress\x12\x1b\n" +
	"\tlocal_asn\x18\x04 \x01(\rR\blocalAsn\x12\"\n" +
	"\rhold_time_sec\x18\x05 \x01(\rR\vholdTimeSec\x12,\n" +
	"\x12keepalive_time_sec\x18\x06 \x01(\rR\x10keepaliveTimeSec\x12\x17\n" +
	"\amd5_key\x18\a \x01(\tR\x06md5Key\x12A\n" +
	"\fcapabilities\x18\b \x01(\v2\x1d.ondatra.BgpPeer.CapabilitiesR\fcapabilities\x12N\n" +
	"\x12srte_policy_groups\x18\t \x03(\v2 .ondatra.BgpPeer.SrtePolicyGroupR\x10srtePolicyGroups\x12<\n" +
	"\frestart_time\x18\f \x01(\v2\x19.google.protobuf.DurationR\vrestartTime\x128\n" +
	"\n" +
	"stale_time\x18\r \x01(\v2\x19.google.protobuf.DurationR\tstaleTime\x12/\n" +
	"\x14advertise_end_of_rib\x18\x0e \x01(\bR\x11advertiseEndOfRib\x12(\n" +
	"\x10act_as_restarted\x18\x0f \x01(\bR\x0eactAsRestarted\x1a\xe8\b\n" +
	"\fCapabilities\x12!\n" +
	"\fipv4_unicast\x18\x01 \x01(\bR\vipv4Unicast\x12%\n" +
	"\x0eipv4_multicast\x18\x02 \x01(\bR\ripv4Multicast\x12\"\n" +
	"\ripv4_mpls_vpn\x18\x03 \x01(\bR\vipv4MplsVpn\x12!\n" +
	"\fipv6_unicast\x18\x04 \x01(\bR\vipv6Unicast\x12%\n" +
	"\x0eipv6_multicast\x18\x05 \x01(\bR\ripv6Multicast\x12\"\n" +
	"\ripv6_mpls_vpn\x18\x06 \x01(\bR\vipv6MplsVpn\x12\x19\n" +
	"\bipv4_mdt\x18\a \x01(\bR\aipv4Mdt\x12\x12\n" +
	"\x04vpls\x18\b \x01(\bR\x04vpls\x12,\n" +
	"\x12ipv4_multicast_vpn\x18\t \x01(\bR\x10ipv4MulticastVpn\x12,\n" +
	"\x12ipv6_multicast_vpn\x18\n" +
	" \x01(\bR\x10ipv6MulticastVpn\x12#\n" +
	"\rroute_refresh\x18\v \x01(\bR\frouteRefresh\x12)\n" +
	"\x10route_constraint\x18\f \x01(\bR\x0frouteConstraint\x12+\n" +
	"\x12link_state_non_vpn\x18\r \x01(\bR\x0flinkStateNonVpn\x12\x12\n" +
	"\x04evpn\x18\x0e \x01(\bR\x04evpn\x12<\n" +
	"\x1bipv4_multicast_bgp_mpls_vpn\x18\x0f \x01(\bR\x17ipv4MulticastBgpMplsVpn\x12<\n" +
	"\x1bipv6_multicast_bgp_mpls_vpn\x18\x10 \x01(\bR\x17ipv6MulticastBgpMplsVpn\x123\n" +
	"\x16ipv4_unicast_flow_spec\x18\x11 \x01(\bR\x13ipv4UnicastFlowSpec\x123\n" +
	"\x16ipv6_unicast_flow_spec\x18\x12 \x01(\bR\x13ipv6UnicastFlowSpec\x121\n" +
	"\x15ipv4_unicast_add_path\x18\x13 \x01(\bR\x12ipv4UnicastAddPath\x121\n" +
	"\x15ipv6_unicast_add_path\x18\x14 \x01(\bR\x12ipv6UnicastAddPath\x12;\n" +
	"\x1aextended_next_hop_encoding\x18\x15 \x01(\bR\x17extendedNextHopEncoding\x12(\n" +
	"\x10ipv4_srte_policy\x18\x16 \x01(\bR\x0eipv4SrtePolicy\x12(\n" +
	"\x10ipv6_srte_policy\x18\x17 \x01(\bR\x0eipv6SrtePolicy\x12+\n" +
	"\x12ipv4_mpls_add_path\x18\x18 \x01(\bR\x0fipv4MplsAddPath\x12+\n" +
	"\x12ipv6_mpls_add_path\x18\x19 \x01(\bR\x0fipv6MplsAddPath\x12)\n" +
	"\x10graceful_restart\x18\x1a \x01(\bR\x0fgracefulRestart\x1a\xe6\v\n" +
	"\x0fSrtePolicyGroup\x12\x14\n" +
	"\x05count\x18\x01 \x01(\rR\x05count\x12\x16\n" +
	"\x06active\x18\x02 \x01(\bR\x06active\x12$\n" +
	"\rdistinguisher\x18\x03 \x01(\rR\rdistinguisher\x12:\n" +
	"\fpolicy_color\x18\x04 \x01(\v2\x17.ondatra.UInt32IncRangeR\vpolicyColor\x12\x1a\n" +
	"\bendpoint\x18\x05 \x01(\tR\bendpoint\x12(\n" +
	"\x10next_hop_address\x18\x06 \x01(\tR\x0enextHopAddress\x12<\n" +
	"\roriginator_id\x18\a \x01(\v2\x17.ondatra.StringIncRangeR\foriginatorId\x129\n" +
	"\vcommunities\x18\b \x01(\v2\x17.ondatra.BgpCommunitiesR\vcommunities\x128\n" +
	"\fasn_set_mode\x18\t \x01(\x0e2\x16.ondatra.BgpAsnSetModeR\n" +
	"asnSetMode\x12K\n" +
	"\n" +
	"preference\x18\n" +
	" \x01(\v2+.ondatra.BgpPeer.SrtePolicyGroup.PreferenceR\n" +
	"preference\x12B\n" +
	"\abinding\x18\v \x01(\v2(.ondatra.BgpPeer.SrtePolicyGroup.BindingR\abinding\x12Q\n" +
	"\rsegment_lists\x18\f \x03(\v2,.ondatra.BgpPeer.SrtePolicyGroup.SegmentListR\fsegmentLists\x129\n" +
	"\x04enlp\x18\r \x01(\v2%.ondatra.BgpPeer.SrtePolicyGroup.EnlpR\x04enlp\x1a,\n" +
	"\n" +
	"Preference\x12\x1e\n" +
	"\n" +
	"preference\x18\x01 \x01(\rR\n" +
	"preference\x1a\x82\x02\n" +
	"\aBinding\x127\n" +
	"\n" +
	"no_binding\x18\x01 \x01(\v2\x16.google.protobuf.EmptyH\x00R\tnoBinding\x12?\n" +
	"\x0efour_octet_sid\x18\x02 \x01(\v2\x17.ondatra.UInt32IncRangeH\x00R\ffourOctetSid\x12X\n" +
	"\x1cfour_octet_sid_as_mpls_label\x18\x03 \x01(\v2\x17.ondatra.UInt32IncRangeH\x00R\x17fourOctetSidAsMplsLabel\x12\x1b\n" +
	"\bipv6_sid\x18\x04 \x01(\tH\x00R\aipv6SidB\x06\n" +
	"\x04type\x1a\xdb\x03\n" +
	"\vSegmentList\x12\x16\n" +
	"\x06active\x18\x01 \x01(\bR\x06active\x12K\n" +
	"\x06weight\x18\x02 \x01(\v23.ondatra.BgpPeer.SrtePolicyGroup.SegmentList.WeightR\x06weight\x12P\n" +
	"\bsegments\x18\x04 \x03(\v24.ondatra.BgpPeer.SrtePolicyGroup.SegmentList.SegmentR\bsegments\x1a \n" +
	"\x06Weight\x12\x16\n" +
	"\x06weight\x18\x01 \x01(\rR\x06weight\x1a\xf2\x01\n" +
	"\aSegment\x12\x16\n" +
	"\x06active\x18\x01 \x01(\bR\x06active\x12Y\n" +
	"\bmpls_sid\x18\x02 \x01(\v2<.ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Segment.MplsSidH\x00R\amplsSid\x12\x1b\n" +
	"\bipv6_sid\x18\x03 \x01(\tH\x00R\aipv6Sid\x1aO\n" +
	"\aMplsSid\x12\x14\n" +
	"\x05label\x18\x01 \x01(\rR\x05label\x12\x0e\n" +
	"\x02tc\x18\x02 \x01(\rR\x02tc\x12\f\n" +
	"\x01s\x18\x03 \x01(\bR\x01s\x12\x10\n" +
	"\x03ttl\x18\x04 \x01(\rR\x03ttlB\x06\n" +
	"\x04type\x1a\x1a\n" +
	"\x04Enlp\x12\x12\n" +
	"\x04enlp\x18\x01 \x01(\rR\x04enlp\"B\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x11\n" +
	"\rTYPE_EXTERNAL\x10\x01\x12\x11\n" +
	"\rTYPE_INTERNAL\x10\x02\"\x83\f\n" +
	"\rBgpAttributes\x12\x16\n" +
	"\x06active\x18\b \x01(\bR\x06active\x12(\n" +
	"\x10next_hop_address\x18\x01 \x01(\tR\x0enextHopAddress\x125\n" +
	"\x06origin\x18\x02 \x01(\x0e2\x1d.ondatra.BgpAttributes.OriginR\x06origin\x12)\n" +
	"\x10local_preference\x18\x03 \x01(\rR\x0flocalPreference\x129\n" +
	"\vcommunities\x18\x04 \x01(\v2\x17.ondatra.BgpCommunitiesR\vcommunities\x12[\n" +
	"\x14extended_communities\x18\x05 \x03(\v2(.ondatra.BgpAttributes.ExtendedCommunityR\x13extendedCommunities\x128\n" +
	"\fasn_set_mode\x18\x06 \x01(\x0e2\x16.ondatra.BgpAsnSetModeR\n" +
	"asnSetMode\x12N\n" +
	"\x10as_path_segments\x18\a \x03(\v2$.ondatra.BgpAttributes.AsPathSegmentR\x0easPathSegments\x12<\n" +
	"\roriginator_id\x18\t \x01(\v2\x17.ondatra.StringIncRangeR\foriginatorId\x12\x1f\n" +
	"\vcluster_ids\x18\n" +
	" \x03(\tR\n" +
	"clusterIds\x12c\n" +
	"\x16advertisement_protocol\x18\v \x01(\x0e2,.ondatra.BgpAttributes.AdvertisementProtocolR\x15advertisementProtocol\x1a\xdb\x02\n" +
	"\x11ExtendedCommunity\x12F\n" +
	"\x05color\x18\x01 \x01(\v2..ondatra.BgpAttributes.ExtendedCommunity.ColorH\x00R\x05color\x1a\xf5\x01\n" +
	"\x05Color\x12N\n" +
	"\aco_bits\x18\x01 \x01(\x0e25.ondatra.BgpAttributes.ExtendedCommunity.Color.CoBitsR\x06coBits\x12#\n" +
	"\rreserved_bits\x18\x02 \x01(\rR\freservedBits\x12\x14\n" +
	"\x05value\x18\x03 \x01(\rR\x05value\"a\n" +
	"\x06CoBits\x12\x17\n" +
	"\x13CO_BITS_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"CO_BITS_00\x10\x01\x12\x0e\n" +
	"\n" +
	"CO_BITS_01\x10\x02\x12\x0e\n" +
	"\n" +
	"CO_BITS_10\x10\x03\x12\x0e\n" +
	"\n" +
	"CO_BITS_11\x10\x04B\x06\n" +
	"\x04Type\x1a\xe0\x01\n" +
	"\rAsPathSegment\x12=\n" +
	"\x04type\x18\x01 \x01(\x0e2).ondatra.BgpAttributes.AsPathSegment.TypeR\x04type\x12\x12\n" +
	"\x04asns\x18\x02 \x03(\rR\x04asns\"|\n" +
	"\x04Type\x12\x14\n" +
	"\x10TYPE_UNSPECIFIED\x10\x00\x12\x0f\n" +
	"\vTYPE_AS_SEQ\x10\x01\x12\x0f\n" +
	"\vTYPE_AS_SET\x10\x02\x12\x1d\n" +
	"\x19TYPE_AS_SEQ_CONFEDERATION\x10\x03\x12\x1d\n" +
	"\x19TYPE_AS_SET_CONFEDERATION\x10\x04\"W\n" +
	"\x06Origin\x12\x16\n" +
	"\x12ORIGIN_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"ORIGIN_IGP\x10\x01\x12\x0e\n" +
	"\n" +
	"ORIGIN_EGP\x10\x02\x12\x15\n" +
	"\x11ORIGIN_INCOMPLETE\x10\x03\"\xcd\x01\n" +
	"\x15AdvertisementProtocol\x12&\n" +
	"\"ADVERTISEMENT_PROTOCOL_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19ADVERTISEMENT_PROTOCOL_V4\x10\x01\x12\x1d\n" +
	"\x19ADVERTISEMENT_PROTOCOL_V6\x10\x02\x12$\n" +
	" ADVERTISEMENT_PROTOCOL_V4_AND_V6\x10\x03\x12(\n" +
	"$ADVERTISEMENT_PROTOCOL_SAME_AS_ROUTE\x10\x04\"\xf1\x06\n" +
	"\n" +
	"RsvpConfig\x12\x12\n" +
	"\x04name\x18\x06 \x01(\tR\x04name\x12%\n" +
	"\x0einterface_name\x18\a \x01(\tR\rinterfaceName\x120\n" +
	"\x14is_reachability_name\x18\x02 \x01(\tR\x12isReachabilityName\x12:\n" +
	"\tloopbacks\x18\x03 \x03(\v2\x1c.ondatra.RsvpConfig.LoopbackR\tloopbacks\x124\n" +
	"\x16bundle_message_sending\x18\x04 \x01(\bR\x14bundleMessageSending\x12+\n" +
	"\x11refresh_reduction\x18\x05 \x01(\bR\x10refreshReduction\x1a\xd6\x04\n" +
	"\bLoopback\x12\"\n" +
	"\rlocal_ip_cidr\x18\x01 \x01(\tR\vlocalIpCidr\x12J\n" +
	"\fingress_lsps\x18\x02 \x03(\v2'.ondatra.RsvpConfig.Loopback.IngressLSPR\vingressLsps\x1a\xd9\x03\n" +
	"\n" +
	"IngressLSP\x12$\n" +
	"\x0eremote_ip_cidr\x18\x01 \x01(\tR\fremoteIpCidr\x12)\n" +
	"\x10local_protection\x18\x02 \x01(\bR\x0flocalProtection\x121\n" +
	"\x14bandwidth_protection\x18\x03 \x01(\bR\x13bandwidthProtection\x12!\n" +
	"\ffast_reroute\x18\x04 \x01(\bR\vfastReroute\x12/\n" +
	"\x13path_reoptimization\x18\x05 \x01(\bR\x12pathReoptimization\x12\x1b\n" +
	"\ttunnel_id\x18\b \x01(\rR\btunnelId\x12\x15\n" +
	"\x06lsp_id\x18\t \x01(\rR\x05lspId\x12?\n" +
	"\x04eros\x18\x06 \x03(\v2+.ondatra.RsvpConfig.Loopback.IngressLSP.EROR\x04eros\x12?\n" +
	"\x04rros\x18\a \x03(\v2+.ondatra.RsvpConfig.Loopback.IngressLSP.RROR\x04rros\x1a\"\n" +
	"\x03ERO\x12\x1b\n" +
	"\tipv4_cidr\x18\x01 \x01(\tR\bipv4Cidr\x1a\x19\n" +
	"\x03RRO\x12\x12\n" +
	"\x04ipv4\x18\x01 \x01(\tR\x04ipv4\"\x0e\n" +
	"\fDhcpV6Client\"F\n" +
	"\fDhcpV6Server\x126\n" +
	"\vlease_addrs\x18\x01 \x01(\v2\x15.ondatra.AddressRangeR\n" +
	"leaseAddrs\"\x88\x06\n" +
	"\aNetwork\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12%\n" +
	"\x0einterface_name\x18\x02 \x01(\tR\rinterfaceName\x12%\n" +
	"\x03eth\x18\x03 \x01(\v2\x13.ondatra.NetworkEthR\x03eth\x12&\n" +
	"\x04ipv4\x18\x04 \x01(\v2\x12.ondatra.NetworkIpR\x04ipv4\x12&\n" +
	"\x04ipv6\x18\x05 \x01(\v2\x12.ondatra.NetworkIpR\x04ipv6\x12=\n" +
	"\x0ebgp_attributes\x18\x06 \x01(\v2\x16.ondatra.BgpAttributesR\rbgpAttributes\x12+\n" +
	"\x04isis\x18\a \x01(\v2\x17.ondatra.IPReachabilityR\x04isis\x12R\n" +
	"\x13imported_bgp_routes\x18\b \x01(\v2\".ondatra.Network.ImportedBgpRoutesR\x11importedBgpRoutes\x1a\x8a\x03\n" +
	"\x11ImportedBgpRoutes\x12a\n" +
	"\x12route_table_format\x18\x01 \x01(\x0e23.ondatra.Network.ImportedBgpRoutes.RouteTableFormatR\x10routeTableFormat\x12(\n" +
	"\x10ipv4_routes_path\x18\x02 \x01(\tR\x0eipv4RoutesPath\x12(\n" +
	"\x10ipv6_routes_path\x18\x03 \x01(\tR\x0eipv6RoutesPath\x12+\n" +
	"\x11overwrite_nexthop\x18\x04 \x01(\bR\x10overwriteNexthop\"\x90\x01\n" +
	"\x10RouteTableFormat\x12\"\n" +
	"\x1eROUTE_TABLE_FORMAT_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18ROUTE_TABLE_FORMAT_CISCO\x10\x01\x12\x1e\n" +
	"\x1aROUTE_TABLE_FORMAT_JUNIPER\x10\x02\x12\x1a\n" +
	"\x16ROUTE_TABLE_FORMAT_CSV\x10\x03\"\\\n" +
	"\n" +
	"NetworkEth\x12\x1f\n" +
	"\vmac_address\x18\x01 \x01(\tR\n" +
	"macAddress\x12\x14\n" +
	"\x05count\x18\x02 \x01(\rR\x05count\x12\x17\n" +
	"\avlan_id\x18\x03 \x01(\rR\x06vlanId\"D\n" +
	"\tNetworkIp\x12!\n" +
	"\faddress_cidr\x18\x01 \x01(\tR\vaddressCidr\x12\x14\n" +
	"\x05count\x18\x02 \x01(\rR\x05count\"\xd5\a\n" +
	"\x04Flow\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12;\n" +
	"\rsrc_endpoints\x18\n" +
	" \x03(\v2\x16.ondatra.Flow.EndpointR\fsrcEndpoints\x12;\n" +
	"\rdst_endpoints\x18\v \x03(\v2\x16.ondatra.Flow.EndpointR\fdstEndpoints\x12)\n" +
	"\aheaders\x18\x14 \x03(\v2\x0f.ondatra.HeaderR\aheaders\x121\n" +
	"\n" +
	"frame_rate\x18\x1e \x01(\v2\x12.ondatra.FrameRateR\tframeRate\x12@\n" +
	"\x0fegress_tracking\x18( \x01(\v2\x17.ondatra.EgressTrackingR\x0eegressTracking\x12^\n" +
	"\x18ingress_tracking_filters\x182 \x01(\v2$.ondatra.Flow.IngressTrackingFiltersR\x16ingressTrackingFilters\x121\n" +
	"\n" +
	"frame_size\x183 \x01(\v2\x12.ondatra.FrameSizeR\tframeSize\x129\n" +
	"\ftransmission\x184 \x01(\v2\x15.ondatra.TransmissionR\ftransmission\x121\n" +
	"\x14convergence_tracking\x185 \x01(\bR\x13convergenceTracking\x1a\x82\x01\n" +
	"\bEndpoint\x12%\n" +
	"\x0einterface_name\x18\x01 \x01(\tR\rinterfaceName\x12#\n" +
	"\fnetwork_name\x18\x02 \x01(\tH\x00R\vnetworkName\x12\x1d\n" +
	"\trsvp_name\x18\x03 \x01(\tH\x00R\brsvpNameB\v\n" +
	"\tgenerated\x1a\x98\x02\n" +
	"\x16IngressTrackingFilters\x12\x1d\n" +
	"\n" +
	"mpls_label\x18\x01 \x01(\bR\tmplsLabel\x12!\n" +
	"\fsrc_endpoint\x18\x02 \x01(\bR\vsrcEndpoint\x12!\n" +
	"\fdst_endpoint\x18\x03 \x01(\bR\vdstEndpoint\x12\x19\n" +
	"\bsrc_ipv4\x18\x04 \x01(\bR\asrcIpv4\x12\x19\n" +
	"\bdst_ipv4\x18\x05 \x01(\bR\adstIpv4\x12\x19\n" +
	"\bsrc_ipv6\x18\x06 \x01(\bR\asrcIpv6\x12\x19\n" +
	"\bdst_ipv6\x18\a \x01(\bR\adstIpv6\x12\x14\n" +
	"\x05ports\x18\b \x01(\bR\x05ports\x12\x17\n" +
	"\avlan_id\x18\t \x01(\bR\x06vlanId\"W\n" +
	"\tFrameRate\x12\x1a\n" +
	"\apercent\x18\x01 \x01(\x01H\x00R\apercent\x12\x12\n" +
	"\x03bps\x18\x02 \x01(\x04H\x00R\x03bps\x12\x12\n" +
	"\x03fps\x18\x03 \x01(\x04H\x00R\x03fpsB\x06\n" +
	"\x04type\"\xdf\x04\n" +
	"\tFrameSize\x12\x16\n" +
	"\x05fixed\x18\x01 \x01(\rH\x00R\x05fixed\x123\n" +
	"\x06random\x18\x02 \x01(\v2\x19.ondatra.FrameSize.RandomH\x00R\x06random\x12@\n" +
	"\vimix_preset\x18\x03 \x01(\x0e2\x1d.ondatra.FrameSize.ImixPresetH\x00R\n" +
	"imixPreset\x12@\n" +
	"\vimix_custom\x18\x04 \x01(\v2\x1d.ondatra.FrameSize.ImixCustomH\x00R\n" +
	"imixCustom\x1a,\n" +
	"\x06Random\x12\x10\n" +
	"\x03min\x18\x01 \x01(\rR\x03min\x12\x10\n" +
	"\x03max\x18\x02 \x01(\rR\x03max\x1a=\n" +
	"\x0fImixCustomEntry\x12\x12\n" +
	"\x04size\x18\x01 \x01(\rR\x04size\x12\x16\n" +
	"\x06weight\x18\x02 \x01(\rR\x06weight\x1aJ\n" +
	"\n" +
	"ImixCustom\x12<\n" +
	"\aentries\x18\x01 \x03(\v2\".ondatra.FrameSize.ImixCustomEntryR\aentries\"\xbf\x01\n" +
	"\n" +
	"ImixPreset\x12\x10\n" +
	"\fIMIX_UNKNOWN\x10\x00\x12\x0e\n" +
	"\n" +
	"IMIX_CISCO\x10\x01\x12\x10\n" +
	"\fIMIX_DEFAULT\x10\x02\x12\x0e\n" +
	"\n" +
	"IMIX_IPSEC\x10\x03\x12\r\n" +
	"\tIMIX_IPV6\x10\x04\x12\x16\n" +
	"\x12IMIX_RPR_QUADMODAL\x10\x05\x12\x15\n" +
	"\x11IMIX_RPR_TRIMODAL\x10\x06\x12\x11\n" +
	"\rIMIX_STANDARD\x10\a\x12\f\n" +
	"\bIMIX_TCP\x10\b\x12\x0e\n" +
	"\n" +
	"IMIX_TOLLY\x10\tB\x06\n" +
	"\x04type\"\x95\x03\n" +
	"\fTransmission\x127\n" +
	"\apattern\x18\x01 \x01(\x0e2\x1d.ondatra.Transmission.PatternR\apattern\x12\"\n" +
	"\rmin_gap_bytes\x18\x02 \x01(\rR\vminGapBytes\x12*\n" +
	"\x11packets_per_burst\x18\x03 \x01(\rR\x0fpacketsPerBurst\x12\"\n" +
	"\vnanoseconds\x18\x04 \x01(\rH\x00R\vnanoseconds\x12\x16\n" +
	"\x05bytes\x18\x05 \x01(\rH\x00R\x05bytes\x12\x1f\n" +
	"\vframe_count\x18\x06 \x01(\rR\n" +
	"frameCount\x12#\n" +
	"\rduration_secs\x18\a \x01(\rR\fdurationSecs\"h\n" +
	"\aPattern\x12\x17\n" +
	"\x13PATTERN_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"CONTINUOUS\x10\x01\x12\t\n" +
	"\x05BURST\x10\x02\x12\x15\n" +
	"\x11FIXED_FRAME_COUNT\x10\x03\x12\x12\n" +
	"\x0eFIXED_DURATION\x10\x04B\x10\n" +
	"\x0einterburst_gap\"n\n" +
	"\x0eEgressTracking\x12\x18\n" +
	"\aenabled\x18\x01 \x01(\bR\aenabled\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\rR\x06offset\x12\x14\n" +
	"\x05width\x18\x03 \x01(\rR\x05width\x12\x14\n" +
	"\x05count\x18\x04 \x01(\rR\x05count\"\xa8\x06\n" +
	"\x06Header\x12+\n" +
	"\x03eth\x18\x01 \x01(\v2\x17.ondatra.EthernetHeaderH\x00R\x03eth\x12&\n" +
	"\x03gre\x18\x02 \x01(\v2\x12.ondatra.GreHeaderH\x00R\x03gre\x12)\n" +
	"\x04ipv4\x18\x03 \x01(\v2\x13.ondatra.Ipv4HeaderH\x00R\x04ipv4\x12)\n" +
	"\x04ipv6\x18\x04 \x01(\v2\x13.ondatra.Ipv6HeaderH\x00R\x04ipv6\x12)\n" +
	"\x04mpls\x18\x05 \x01(\v2\x13.ondatra.MplsHeaderH\x00R\x04mpls\x12&\n" +
	"\x03tcp\x18\x06 \x01(\v2\x12.ondatra.TcpHeaderH\x00R\x03tcp\x12&\n" +
	"\x03udp\x18\a \x01(\v2\x12.ondatra.UdpHeaderH\x00R\x03udp\x12)\n" +
	"\x04http\x18\b \x01(\v2\x13.ondatra.HttpHeaderH\x00R\x04http\x12)\n" +
	"\x04icmp\x18\t \x01(\v2\x13.ondatra.IcmpHeaderH\x00R\x04icmp\x12)\n" +
	"\x04ospf\x18\n" +
	" \x01(\v2\x13.ondatra.OspfHeaderH\x00R\x04ospf\x12)\n" +
	"\x04rsvp\x18\v \x01(\v2\x13.ondatra.RsvpHeaderH\x00R\x04rsvp\x12&\n" +
	"\x03pim\x18\f \x01(\v2\x12.ondatra.PimHeaderH\x00R\x03pim\x12&\n" +
	"\x03ldp\x18\r \x01(\v2\x12.ondatra.LdpHeaderH\x00R\x03ldp\x12/\n" +
	"\x06macsec\x18\x0e \x01(\v2\x15.ondatra.MacsecHeaderH\x00R\x06macsec\x12&\n" +
	"\x03esp\x18\x0f \x01(\v2\x12.ondatra.EspHeaderH\x00R\x03esp\x12F\n" +
	"\x0fesp_over_macsec\x18\x10 \x01(\v2\x1c.ondatra.EspOverMacSecHeaderH\x00R\respOverMacsec\x12S\n" +
	"\x14pw_mpls_control_word\x18\x11 \x01(\v2 .ondatra.PwMplsControlWordHeaderH\x00R\x11pwMplsControlWordB\x06\n" +
	"\x04type\"\xe6\x01\n" +
	"\x0eEthernetHeader\x120\n" +
	"\bsrc_addr\x18\x01 \x01(\v2\x15.ondatra.AddressRangeR\asrcAddr\x120\n" +
	"\bdst_addr\x18\x02 \x01(\v2\x15.ondatra.AddressRangeR\adstAddr\x12\x17\n" +
	"\avlan_id\x18\x03 \x01(\rR\x06vlanId\x12\x17\n" +
	"\abad_crc\x18\x04 \x01(\bR\x06badCrc\x12\x1d\n" +
	"\n" +
	"ether_type\x18\x05 \x01(\rR\tetherType\x12\x1f\n" +
	"\vprotocol_id\x18\x06 \x01(\rR\n" +
	"protocolId\"/\n" +
	"\tGreHeader\x12\x10\n" +
	"\x03key\x18\x01 \x01(\rR\x03key\x12\x10\n" +
	"\x03seq\x18\x02 \x01(\rR\x03seq\"\x9c\x03\n" +
	"\n" +
	"Ipv4Header\x12\x12\n" +
	"\x04dscp\x18\x01 \x01(\rR\x04dscp\x12\x10\n" +
	"\x03ecn\x18\x02 \x01(\rR\x03ecn\x12&\n" +
	"\x0eidentification\x18\x03 \x01(\rR\x0eidentification\x12#\n" +
	"\rdont_fragment\x18\x04 \x01(\bR\fdontFragment\x12%\n" +
	"\x0emore_fragments\x18\x05 \x01(\bR\rmoreFragments\x12'\n" +
	"\x0ffragment_offset\x18\x06 \x01(\rR\x0efragmentOffset\x12\x15\n" +
	"\x03ttl\x18\a \x01(\rH\x00R\x03ttl\x88\x01\x01\x12\x1f\n" +
	"\bprotocol\x18\b \x01(\rH\x01R\bprotocol\x88\x01\x01\x12\x1a\n" +
	"\bchecksum\x18\t \x01(\rR\bchecksum\x120\n" +
	"\bsrc_addr\x18\n" +
	" \x01(\v2\x15.ondatra.AddressRangeR\asrcAddr\x120\n" +
	"\bdst_addr\x18\v \x01(\v2\x15.ondatra.AddressRangeR\adstAddrB\x06\n" +
	"\x04_ttlB\v\n" +
	"\t_protocol\"\xf9\x01\n" +
	"\n" +
	"Ipv6Header\x120\n" +
	"\bsrc_addr\x18\x01 \x01(\v2\x15.ondatra.AddressRangeR\asrcAddr\x120\n" +
	"\bdst_addr\x18\x02 \x01(\v2\x15.ondatra.AddressRangeR\adstAddr\x12 \n" +
	"\thop_limit\x18\x03 \x01(\rH\x00R\bhopLimit\x88\x01\x01\x121\n" +
	"\n" +
	"flow_label\x18\x04 \x01(\v2\x12.ondatra.UIntRangeR\tflowLabel\x12\x12\n" +
	"\x04dscp\x18\x05 \x01(\rR\x04dscp\x12\x10\n" +
	"\x03ecn\x18\x06 \x01(\rR\x03ecnB\f\n" +
	"\n" +
	"_hop_limit\"Z\n" +
	"\n" +
	"MplsHeader\x12(\n" +
	"\x05label\x18\x01 \x01(\v2\x12.ondatra.UIntRangeR\x05label\x12\x10\n" +
	"\x03exp\x18\x02 \x01(\rR\x03exp\x12\x10\n" +
	"\x03ttl\x18\x03 \x01(\rR\x03ttl\"{\n" +
	"\x17PwMplsControlWordHeader\x12\x17\n" +
	"\acw_rsvd\x18\x01 \x01(\rR\x06cwRsvd\x12\x19\n" +
	"\bcw_flags\x18\x02 \x01(\rR\acwFlags\x12\x15\n" +
	"\x06cw_frg\x18\x03 \x01(\rR\x05cwFrg\x12\x15\n" +
	"\x06cw_seq\x18\x04 \x01(\rR\x05cwSeq\"{\n" +
	"\tTcpHeader\x12-\n" +
	"\bsrc_port\x18\x01 \x01(\v2\x12.ondatra.UIntRangeR\asrcPort\x12-\n" +
	"\bdst_port\x18\x02 \x01(\v2\x12.ondatra.UIntRangeR\adstPort\x12\x10\n" +
	"\x03seq\x18\x03 \x01(\rR\x03seq\"i\n" +
	"\tUdpHeader\x12-\n" +
	"\bsrc_port\x18\x01 \x01(\v2\x12.ondatra.UIntRangeR\asrcPort\x12-\n" +
	"\bdst_port\x18\x02 \x01(\v2\x12.ondatra.UIntRangeR\adstPort\"\f\n" +
	"\n" +
	"HttpHeader\"\x9d\f\n" +
	"\n" +
	"IcmpHeader\x12>\n" +
	"\n" +
	"echo_reply\x18\x01 \x01(\v2\x1d.ondatra.IcmpHeader.EchoReplyH\x00R\techoReply\x12e\n" +
	"\x17destination_unreachable\x18\x02 \x01(\v2*.ondatra.IcmpHeader.DestinationUnreachableH\x00R\x16destinationUnreachable\x12P\n" +
	"\x10redirect_message\x18\x03 \x01(\v2#.ondatra.IcmpHeader.RedirectMessageH\x00R\x0fredirectMessage\x12D\n" +
	"\fecho_request\x18\x04 \x01(\v2\x1f.ondatra.IcmpHeader.EchoRequestH\x00R\vechoRequest\x12G\n" +
	"\rtime_exceeded\x18\x05 \x01(\v2 .ondatra.IcmpHeader.TimeExceededH\x00R\ftimeExceeded\x12S\n" +
	"\x11parameter_problem\x18\x06 \x01(\v2$.ondatra.IcmpHeader.ParameterProblemH\x00R\x10parameterProblem\x12=\n" +
	"\ttimestamp\x18\a \x01(\v2\x1d.ondatra.IcmpHeader.TimestampH\x00R\ttimestamp\x12M\n" +
	"\x0ftimestamp_reply\x18\b \x01(\v2\".ondatra.IcmpHeader.TimestampReplyH\x00R\x0etimestampReply\x1a\v\n" +
	"\tEchoReply\x1a\x90\x02\n" +
	"\x16DestinationUnreachable\x12C\n" +
	"\x04code\x18\x01 \x01(\x0e2/.ondatra.IcmpHeader.DestinationUnreachable.CodeR\x04code\"\xb0\x01\n" +
	"\x04Code\x12\x14\n" +
	"\x10CODE_UNSPECIFIED\x10\x00\x12\x17\n" +
	"\x13NETWORK_UNREACHABLE\x10\x01\x12\x14\n" +
	"\x10HOST_UNREACHABLE\x10\x02\x12\x18\n" +
	"\x14PROTOCOL_UNREACHABLE\x10\x03\x12\x14\n" +
	"\x10PORT_UNREACHABLE\x10\x04\x12\x1a\n" +
	"\x16FRAGMENTATION_REQUIRED\x10\x05\x12\x17\n" +
	"\x13SOURCE_ROUTE_FAILED\x10\x06\x1a\xc4\x01\n" +
	"\x0fRedirectMessage\x12<\n" +
	"\x04code\x18\x01 \x01(\x0e2(.ondatra.IcmpHeader.RedirectMessage.CodeR\x04code\x12\x17\n" +
	"\aip_addr\x18\x02 \x01(\tR\x06ipAddr\"Z\n" +
	"\x04Code\x12\x14\n" +
	"\x10CODE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aNETWORK\x10\x01\x12\b\n" +
	"\x04HOST\x10\x02\x12\x13\n" +
	"\x0fTOS_AND_NETWORK\x10\x03\x12\x10\n" +
	"\fTOS_AND_HOST\x10\x04\x1a\r\n" +
	"\vEchoRequest\x1a\x8d\x01\n" +
	"\fTimeExceeded\x129\n" +
	"\x04code\x18\x01 \x01(\x0e2%.ondatra.IcmpHeader.TimeExceeded.CodeR\x04code\"B\n" +
	"\x04Code\x12\x14\n" +
	"\x10CODE_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aTRANSIT\x10\x01\x12\x17\n" +
	"\x13FRAGMENT_REASSEMBLY\x10\x02\x1a,\n" +
	"\x10ParameterProblem\x12\x18\n" +
	"\apointer\x18\x01 \x01(\rR\apointer\x1aP\n" +
	"\tTimestamp\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\rR\x02id\x12\x10\n" +
	"\x03seq\x18\x02 \x01(\rR\x03seq\x12!\n" +
	"\foriginate_ts\x18\x03 \x01(\rR\voriginateTs\x1a\x95\x01\n" +
	"\x0eTimestampReply\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\rR\x02id\x12\x10\n" +
	"\x03seq\x18\x02 \x01(\rR\x03seq\x12!\n" +
	"\foriginate_ts\x18\x03 \x01(\rR\voriginateTs\x12\x1d\n" +
	"\n" +
	"receive_ts\x18\x04 \x01(\rR\treceiveTs\x12\x1f\n" +
	"\vtransmit_ts\x18\x05 \x01(\rR\n" +
	"transmitTsB\x06\n" +
	"\x04type\"\xaa\r\n" +
	"\n" +
	"OspfHeader\x12\x1b\n" +
	"\trouter_id\x18\x01 \x01(\tR\brouterId\x12\x17\n" +
	"\aarea_id\x18\x02 \x01(\tR\x06areaId\x121\n" +
	"\x05hello\x18\x03 \x01(\v2\x19.ondatra.OspfHeader.HelloH\x00R\x05hello\x12;\n" +
	"\x03dbd\x18\x04 \x01(\v2'.ondatra.OspfHeader.DatabaseDescriptionH\x00R\x03dbd\x128\n" +
	"\x03lsr\x18\x05 \x01(\v2$.ondatra.OspfHeader.LinkStateRequestH\x00R\x03lsr\x127\n" +
	"\x03lsu\x18\x06 \x01(\v2#.ondatra.OspfHeader.LinkStateUpdateH\x00R\x03lsu\x124\n" +
	"\x03lsa\x18\a \x01(\v2 .ondatra.OspfHeader.LinkStateAckH\x00R\x03lsa\x1a\xcc\x02\n" +
	"\x05Hello\x12.\n" +
	"\x13network_mask_length\x18\x01 \x01(\rR\x11networkMaskLength\x12,\n" +
	"\x12hello_interval_sec\x18\x02 \x01(\rR\x10helloIntervalSec\x12'\n" +
	"\x0frouter_priority\x18\x03 \x01(\rR\x0erouterPriority\x127\n" +
	"\x18router_dead_interval_sec\x18\x04 \x01(\rR\x15routerDeadIntervalSec\x12+\n" +
	"\x11designated_router\x18\x05 \x01(\tR\x10designatedRouter\x128\n" +
	"\x18backup_designated_router\x18\x06 \x01(\tR\x16backupDesignatedRouter\x12\x1c\n" +
	"\tneighbors\x18\a \x03(\tR\tneighbors\x1a\x7f\n" +
	"\x13DatabaseDescription\x12\x10\n" +
	"\x03mtu\x18\x01 \x01(\rR\x03mtu\x12\x18\n" +
	"\ainitial\x18\x02 \x01(\bR\ainitial\x12\x12\n" +
	"\x04more\x18\x03 \x01(\bR\x04more\x12\x16\n" +
	"\x06master\x18\x04 \x01(\bR\x06master\x12\x10\n" +
	"\x03seq\x18\x05 \x01(\rR\x03seq\x1a\x9c\x01\n" +
	"\x10LinkStateRequest\x125\n" +
	"\x04type\x18\x01 \x01(\x0e2!.ondatra.OspfHeader.LinkStateTypeR\x04type\x12\"\n" +
	"\rlink_state_id\x18\x02 \x01(\tR\vlinkStateId\x12-\n" +
	"\x12advertising_router\x18\x03 \x01(\tR\x11advertisingRouter\x1a\xdb\x01\n" +
	"\x1cLinkStateAdvertisementHeader\x12\x1f\n" +
	"\vage_seconds\x18\x01 \x01(\rR\n" +
	"ageSeconds\x125\n" +
	"\x04type\x18\x02 \x01(\x0e2!.ondatra.OspfHeader.LinkStateTypeR\x04type\x12\"\n" +
	"\rlink_state_id\x18\x03 \x01(\tR\vlinkStateId\x12-\n" +
	"\x12advertising_router\x18\x04 \x01(\tR\x11advertisingRouter\x12\x10\n" +
	"\x03seq\x18\x05 \x01(\rR\x03seq\x1a\xc7\x01\n" +
	"\x0fLinkStateUpdate\x12Y\n" +
	"\x0eadvertisements\x18\x01 \x03(\v21.ondatra.OspfHeader.LinkStateUpdate.AdvertisementR\x0eadvertisements\x1aY\n" +
	"\rAdvertisement\x12H\n" +
	"\x06header\x18\x01 \x01(\v20.ondatra.OspfHeader.LinkStateAdvertisementHeaderR\x06header\x1aZ\n" +
	"\fLinkStateAck\x12J\n" +
	"\aheaders\x18\x01 \x03(\v20.ondatra.OspfHeader.LinkStateAdvertisementHeaderR\aheaders\"\xd1\x01\n" +
	"\rLinkStateType\x12\x1f\n" +
	"\x1bLINK_STATE_TYPE_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16LINK_STATE_TYPE_ROUTER\x10\x01\x12\x1b\n" +
	"\x17LINK_STATE_TYPE_NETWORK\x10\x02\x12#\n" +
	"\x1fLINK_STATE_TYPE_SUMMARY_NETWORK\x10\x03\x12 \n" +
	"\x1cLINK_STATE_TYPE_SUMMARY_ASBR\x10\x04\x12\x1f\n" +
	"\x1bLINK_STATE_TYPE_AS_EXTERNAL\x10\x05B\x06\n" +
	"\x04type\"\xf9\x01\n" +
	"\n" +
	"RsvpHeader\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12:\n" +
	"\x19refresh_reduction_capable\x18\x02 \x01(\bR\x17refreshReductionCapable\x12B\n" +
	"\fmessage_type\x18\x03 \x01(\x0e2\x1f.ondatra.RsvpHeader.MessageTypeR\vmessageType\x12\x10\n" +
	"\x03ttl\x18\x04 \x01(\rR\x03ttl\"?\n" +
	"\vMessageType\x12\x1c\n" +
	"\x18MESSAGE_TYPE_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04PATH\x10\x01\x12\b\n" +
	"\x04RESV\x10\x02\"N\n" +
	"\tPimHeader\x120\n" +
	"\x05hello\x18\x01 \x01(\v2\x18.ondatra.PimHeader.HelloH\x00R\x05hello\x1a\a\n" +
	"\x05HelloB\x06\n" +
	"\x04type\"\x90\x02\n" +
	"\tLdpHeader\x12\x15\n" +
	"\x06lsr_id\x18\x01 \x01(\tR\x05lsrId\x12\x1f\n" +
	"\vlabel_space\x18\x02 \x01(\rR\n" +
	"labelSpace\x12\x1d\n" +
	"\n" +
	"message_id\x18\x03 \x01(\rR\tmessageId\x120\n" +
	"\x05hello\x18\x04 \x01(\v2\x18.ondatra.LdpHeader.HelloH\x00R\x05hello\x1ar\n" +
	"\x05Hello\x12\"\n" +
	"\rhold_time_sec\x18\x01 \x01(\rR\vholdTimeSec\x12\x1a\n" +
	"\btargeted\x18\x02 \x01(\bR\btargeted\x12)\n" +
	"\x10request_targeted\x18\x03 \x01(\bR\x0frequestTargetedB\x06\n" +
	"\x04type\"\x84\x01\n" +
	"\tEspHeader\x12:\n" +
	"\x19security_parameters_index\x18\x01 \x01(\rR\x17securityParametersIndex\x12;\n" +
	"\x0fsequence_number\x18\x02 \x01(\v2\x12.ondatra.UIntRangeR\x0esequenceNumber\"\x8e\x01\n" +
	"\x13EspOverMacSecHeader\x12:\n" +
	"\x19security_parameters_index\x18\x01 \x01(\rR\x17securityParametersIndex\x12;\n" +
	"\x0fsequence_number\x18\x02 \x01(\v2\x12.ondatra.UIntRangeR\x0esequenceNumber\"'\n" +
	"\fMacsecHeader\x12\x17\n" +
	"\avlan_id\x18\x01 \x01(\rR\x06vlanId\"~\n" +
	"\x12IpAddressGenerator\x12,\n" +
	"\x04list\x18\x01 \x01(\v2\x16.ondatra.IpAddressListH\x00R\x04list\x122\n" +
	"\x06random\x18\x02 \x01(\v2\x18.ondatra.IpAddressRandomH\x00R\x06randomB\x06\n" +
	"\x04type\"%\n" +
	"\rIpAddressList\x12\x14\n" +
	"\x05addrs\x18\x01 \x03(\tR\x05addrs\"?\n" +
	"\x0fIpAddressRandom\x12\x16\n" +
	"\x06prefix\x18\x01 \x01(\tR\x06prefix\x12\x14\n" +
	"\x05count\x18\x02 \x01(\rR\x05count\"q\n" +
	"\tUIntRange\x12\x10\n" +
	"\x03min\x18\x01 \x01(\rR\x03min\x12\x10\n" +
	"\x03max\x18\x02 \x01(\rR\x03max\x12\x12\n" +
	"\x04step\x18\x03 \x01(\rR\x04step\x12\x14\n" +
	"\x05count\x18\x04 \x01(\rR\x05count\x12\x16\n" +
	"\x06random\x18\x05 \x01(\bR\x06random\"t\n" +
	"\fAddressRange\x12\x10\n" +
	"\x03min\x18\x01 \x01(\tR\x03min\x12\x10\n" +
	"\x03max\x18\x02 \x01(\tR\x03max\x12\x12\n" +
	"\x04step\x18\x03 \x01(\tR\x04step\x12\x14\n" +
	"\x05count\x18\x04 \x01(\rR\x05count\x12\x16\n" +
	"\x06random\x18\x05 \x01(\bR\x06random\":\n" +
	"\x0eStringIncRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\tR\x05start\x12\x12\n" +
	"\x04step\x18\x02 \x01(\tR\x04step\":\n" +
	"\x0eUInt32IncRange\x12\x14\n" +
	"\x05start\x18\x01 \x01(\rR\x05start\x12\x12\n" +
	"\x04step\x18\x02 \x01(\rR\x04step*\xe8\x01\n" +
	"\rBgpAsnSetMode\x12\x1c\n" +
	"\x18ASN_SET_MODE_UNSPECIFIED\x10\x00\x12\x1f\n" +
	"\x1bASN_SET_MODE_DO_NOT_INCLUDE\x10\x01\x12\x17\n" +
	"\x13ASN_SET_MODE_AS_SEQ\x10\x02\x12\x17\n" +
	"\x13ASN_SET_MODE_AS_SET\x10\x03\x12%\n" +
	"!ASN_SET_MODE_AS_SEQ_CONFEDERATION\x10\x04\x12%\n" +
	"!ASN_SET_MODE_AS_SET_CONFEDERATION\x10\x05\x12\x18\n" +
	"\x14ASN_SET_MODE_PREPEND\x10\x06B%Z#github.com/openconfig/ondatra/protob\x06proto3"

var (
	file_ate_proto_rawDescOnce sync.Once
	file_ate_proto_rawDescData []byte
)

func file_ate_proto_rawDescGZIP() []byte {
	file_ate_proto_rawDescOnce.Do(func() {
		file_ate_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_ate_proto_rawDesc), len(file_ate_proto_rawDesc)))
	})
	return file_ate_proto_rawDescData
}

var file_ate_proto_enumTypes = make([]protoimpl.EnumInfo, 22)
var file_ate_proto_msgTypes = make([]protoimpl.MessageInfo, 99)
var file_ate_proto_goTypes = []any{
	(BgpAsnSetMode)(0),                                  // 0: ondatra.BgpAsnSetMode
	(MacSec_CipherSuite)(0),                             // 1: ondatra.MacSec.CipherSuite
	(MacSec_MKA_Capability)(0),                          // 2: ondatra.MacSec.MKA.Capability
	(MacSec_MKA_ConfidentialityOffset)(0),               // 3: ondatra.MacSec.MKA.ConfidentialityOffset
	(MacSec_MKA_KeyDerivationFunction)(0),               // 4: ondatra.MacSec.MKA.KeyDerivationFunction
	(ISISConfig_Level)(0),                               // 5: ondatra.ISISConfig.Level
	(ISISConfig_NetworkType)(0),                         // 6: ondatra.ISISConfig.NetworkType
	(ISISConfig_AuthType)(0),                            // 7: ondatra.ISISConfig.AuthType
	(IPReachability_RouteOrigin)(0),                     // 8: ondatra.IPReachability.RouteOrigin
	(BgpPeer_Type)(0),                                   // 9: ondatra.BgpPeer.Type
	(BgpAttributes_Origin)(0),                           // 10: ondatra.BgpAttributes.Origin
	(BgpAttributes_AdvertisementProtocol)(0),            // 11: ondatra.BgpAttributes.AdvertisementProtocol
	(BgpAttributes_ExtendedCommunity_Color_CoBits)(0),   // 12: ondatra.BgpAttributes.ExtendedCommunity.Color.CoBits
	(BgpAttributes_AsPathSegment_Type)(0),               // 13: ondatra.BgpAttributes.AsPathSegment.Type
	(Network_ImportedBgpRoutes_RouteTableFormat)(0),     // 14: ondatra.Network.ImportedBgpRoutes.RouteTableFormat
	(FrameSize_ImixPreset)(0),                           // 15: ondatra.FrameSize.ImixPreset
	(Transmission_Pattern)(0),                           // 16: ondatra.Transmission.Pattern
	(IcmpHeader_DestinationUnreachable_Code)(0),         // 17: ondatra.IcmpHeader.DestinationUnreachable.Code
	(IcmpHeader_RedirectMessage_Code)(0),                // 18: ondatra.IcmpHeader.RedirectMessage.Code
	(IcmpHeader_TimeExceeded_Code)(0),                   // 19: ondatra.IcmpHeader.TimeExceeded.Code
	(OspfHeader_LinkStateType)(0),                       // 20: ondatra.OspfHeader.LinkStateType
	(RsvpHeader_MessageType)(0),                         // 21: ondatra.RsvpHeader.MessageType
	(*Traffic)(nil),                                     // 22: ondatra.Traffic
	(*Lag)(nil),                                         // 23: ondatra.Lag
	(*InterfaceConfig)(nil),                             // 24: ondatra.InterfaceConfig
	(*EthernetConfig)(nil),                              // 25: ondatra.EthernetConfig
	(*Fec)(nil),                                         // 26: ondatra.Fec
	(*MacSec)(nil),                                      // 27: ondatra.MacSec
	(*RxSakPool)(nil),                                   // 28: ondatra.RxSakPool
	(*IpConfig)(nil),                                    // 29: ondatra.IpConfig
	(*ISISConfig)(nil),                                  // 30: ondatra.ISISConfig
	(*ISISSegmentRouting)(nil),                          // 31: ondatra.ISISSegmentRouting
	(*IPReachability)(nil),                              // 32: ondatra.IPReachability
	(*ISReachability)(nil),                              // 33: ondatra.ISReachability
	(*BgpCommunities)(nil),                              // 34: ondatra.BgpCommunities
	(*BgpConfig)(nil),                                   // 35: ondatra.BgpConfig
	(*BgpPeer)(nil),                                     // 36: ondatra.BgpPeer
	(*BgpAttributes)(nil),                               // 37: ondatra.BgpAttributes
	(*RsvpConfig)(nil),                                  // 38: ondatra.RsvpConfig
	(*DhcpV6Client)(nil),                                // 39: ondatra.DhcpV6Client
	(*DhcpV6Server)(nil),                                // 40: ondatra.DhcpV6Server
	(*Network)(nil),                                     // 41: ondatra.Network
	(*NetworkEth)(nil),                                  // 42: ondatra.NetworkEth
	(*NetworkIp)(nil),                                   // 43: ondatra.NetworkIp
	(*Flow)(nil),                                        // 44: ondatra.Flow
	(*FrameRate)(nil),                                   // 45: ondatra.FrameRate
	(*FrameSize)(nil),                                   // 46: ondatra.FrameSize
	(*Transmission)(nil),                                // 47: ondatra.Transmission
	(*EgressTracking)(nil),                              // 48: ondatra.EgressTracking
	(*Header)(nil),                                      // 49: ondatra.Header
	(*EthernetHeader)(nil),                              // 50: ondatra.EthernetHeader
	(*GreHeader)(nil),                                   // 51: ondatra.GreHeader
	(*Ipv4Header)(nil),                                  // 52: ondatra.Ipv4Header
	(*Ipv6Header)(nil),                                  // 53: ondatra.Ipv6Header
	(*MplsHeader)(nil),                                  // 54: ondatra.MplsHeader
	(*PwMplsControlWordHeader)(nil),                     // 55: ondatra.PwMplsControlWordHeader
	(*TcpHeader)(nil),                                   // 56: ondatra.TcpHeader
	(*UdpHeader)(nil),                                   // 57: ondatra.UdpHeader
	(*HttpHeader)(nil),                                  // 58: ondatra.HttpHeader
	(*IcmpHeader)(nil),                                  // 59: ondatra.IcmpHeader
	(*OspfHeader)(nil),                                  // 60: ondatra.OspfHeader
	(*RsvpHeader)(nil),                                  // 61: ondatra.RsvpHeader
	(*PimHeader)(nil),                                   // 62: ondatra.PimHeader
	(*LdpHeader)(nil),                                   // 63: ondatra.LdpHeader
	(*EspHeader)(nil),                                   // 64: ondatra.EspHeader
	(*EspOverMacSecHeader)(nil),                         // 65: ondatra.EspOverMacSecHeader
	(*MacsecHeader)(nil),                                // 66: ondatra.MacsecHeader
	(*IpAddressGenerator)(nil),                          // 67: ondatra.IpAddressGenerator
	(*IpAddressList)(nil),                               // 68: ondatra.IpAddressList
	(*IpAddressRandom)(nil),                             // 69: ondatra.IpAddressRandom
	(*UIntRange)(nil),                                   // 70: ondatra.UIntRange
	(*AddressRange)(nil),                                // 71: ondatra.AddressRange
	(*StringIncRange)(nil),                              // 72: ondatra.StringIncRange
	(*UInt32IncRange)(nil),                              // 73: ondatra.UInt32IncRange
	(*Lag_Lacp)(nil),                                    // 74: ondatra.Lag.Lacp
	(*MacSec_MKA)(nil),                                  // 75: ondatra.MacSec.MKA
	(*MacSec_MKA_ConnectivityAssociation)(nil),          // 76: ondatra.MacSec.MKA.ConnectivityAssociation
	(*ISISSegmentRouting_AdjacencySID)(nil),             // 77: ondatra.ISISSegmentRouting.AdjacencySID
	(*ISISSegmentRouting_SIDRange)(nil),                 // 78: ondatra.ISISSegmentRouting.SIDRange
	(*ISReachability_Node)(nil),                         // 79: ondatra.ISReachability.Node
	(*ISReachability_Node_Link)(nil),                    // 80: ondatra.ISReachability.Node.Link
	(*ISReachability_Node_Routes)(nil),                  // 81: ondatra.ISReachability.Node.Routes
	(*BgpPeer_Capabilities)(nil),                        // 82: ondatra.BgpPeer.Capabilities
	(*BgpPeer_SrtePolicyGroup)(nil),                     // 83: ondatra.BgpPeer.SrtePolicyGroup
	(*BgpPeer_SrtePolicyGroup_Preference)(nil),          // 84: ondatra.BgpPeer.SrtePolicyGroup.Preference
	(*BgpPeer_SrtePolicyGroup_Binding)(nil),             // 85: ondatra.BgpPeer.SrtePolicyGroup.Binding
	(*BgpPeer_SrtePolicyGroup_SegmentList)(nil),         // 86: ondatra.BgpPeer.SrtePolicyGroup.SegmentList
	(*BgpPeer_SrtePolicyGroup_Enlp)(nil),                // 87: ondatra.BgpPeer.SrtePolicyGroup.Enlp
	(*BgpPeer_SrtePolicyGroup_SegmentList_Weight)(nil),  // 88: ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Weight
	(*BgpPeer_SrtePolicyGroup_SegmentList_Segment)(nil), // 89: ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Segment
	(*BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid)(nil), // 90: ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Segment.MplsSid
	(*BgpAttributes_ExtendedCommunity)(nil),                     // 91: ondatra.BgpAttributes.ExtendedCommunity
	(*BgpAttributes_AsPathSegment)(nil),                         // 92: ondatra.BgpAttributes.AsPathSegment
	(*BgpAttributes_ExtendedCommunity_Color)(nil),               // 93: ondatra.BgpAttributes.ExtendedCommunity.Color
	(*RsvpConfig_Loopback)(nil),                                 // 94: ondatra.RsvpConfig.Loopback
	(*RsvpConfig_Loopback_IngressLSP)(nil),                      // 95: ondatra.RsvpConfig.Loopback.IngressLSP
	(*RsvpConfig_Loopback_IngressLSP_ERO)(nil),                  // 96: ondatra.RsvpConfig.Loopback.IngressLSP.ERO
	(*RsvpConfig_Loopback_IngressLSP_RRO)(nil),                  // 97: ondatra.RsvpConfig.Loopback.IngressLSP.RRO
	(*Network_ImportedBgpRoutes)(nil),                           // 98: ondatra.Network.ImportedBgpRoutes
	(*Flow_Endpoint)(nil),                                       // 99: ondatra.Flow.Endpoint
	(*Flow_IngressTrackingFilters)(nil),                         // 100: ondatra.Flow.IngressTrackingFilters
	(*FrameSize_Random)(nil),                                    // 101: ondatra.FrameSize.Random
	(*FrameSize_ImixCustomEntry)(nil),                           // 102: ondatra.FrameSize.ImixCustomEntry
	(*FrameSize_ImixCustom)(nil),                                // 103: ondatra.FrameSize.ImixCustom
	(*IcmpHeader_EchoReply)(nil),                                // 104: ondatra.IcmpHeader.EchoReply
	(*IcmpHeader_DestinationUnreachable)(nil),                   // 105: ondatra.IcmpHeader.DestinationUnreachable
	(*IcmpHeader_RedirectMessage)(nil),                          // 106: ondatra.IcmpHeader.RedirectMessage
	(*IcmpHeader_EchoRequest)(nil),                              // 107: ondatra.IcmpHeader.EchoRequest
	(*IcmpHeader_TimeExceeded)(nil),                             // 108: ondatra.IcmpHeader.TimeExceeded
	(*IcmpHeader_ParameterProblem)(nil),                         // 109: ondatra.IcmpHeader.ParameterProblem
	(*IcmpHeader_Timestamp)(nil),                                // 110: ondatra.IcmpHeader.Timestamp
	(*IcmpHeader_TimestampReply)(nil),                           // 111: ondatra.IcmpHeader.TimestampReply
	(*OspfHeader_Hello)(nil),                                    // 112: ondatra.OspfHeader.Hello
	(*OspfHeader_DatabaseDescription)(nil),                      // 113: ondatra.OspfHeader.DatabaseDescription
	(*OspfHeader_LinkStateRequest)(nil),                         // 114: ondatra.OspfHeader.LinkStateRequest
	(*OspfHeader_LinkStateAdvertisementHeader)(nil),             // 115: ondatra.OspfHeader.LinkStateAdvertisementHeader
	(*OspfHeader_LinkStateUpdate)(nil),                          // 116: ondatra.OspfHeader.LinkStateUpdate
	(*OspfHeader_LinkStateAck)(nil),                             // 117: ondatra.OspfHeader.LinkStateAck
	(*OspfHeader_LinkStateUpdate_Advertisement)(nil),            // 118: ondatra.OspfHeader.LinkStateUpdate.Advertisement
	(*PimHeader_Hello)(nil),                                     // 119: ondatra.PimHeader.Hello
	(*LdpHeader_Hello)(nil),                                     // 120: ondatra.LdpHeader.Hello
	(*durationpb.Duration)(nil),                                 // 121: google.protobuf.Duration
	(*emptypb.Empty)(nil),                                       // 122: google.protobuf.Empty
}
var file_ate_proto_depIdxs = []int32{
	44,  // 0: ondatra.Traffic.flows:type_name -> ondatra.Flow
	74,  // 1: ondatra.Lag.lacp:type_name -> ondatra.Lag.Lacp
	27,  // 2: ondatra.Lag.macsec:type_name -> ondatra.MacSec
	25,  // 3: ondatra.InterfaceConfig.ethernet:type_name -> ondatra.EthernetConfig
	29,  // 4: ondatra.InterfaceConfig.ipv4:type_name -> ondatra.IpConfig
	29,  // 5: ondatra.InterfaceConfig.ipv6:type_name -> ondatra.IpConfig
	30,  // 6: ondatra.InterfaceConfig.isis:type_name -> ondatra.ISISConfig
	35,  // 7: ondatra.InterfaceConfig.bgp:type_name -> ondatra.BgpConfig
	38,  // 8: ondatra.InterfaceConfig.rsvps:type_name -> ondatra.RsvpConfig
	39,  // 9: ondatra.InterfaceConfig.dhcpv6_client:type_name -> ondatra.DhcpV6Client
	40,  // 10: ondatra.InterfaceConfig.dhcpv6_server:type_name -> ondatra.DhcpV6Server
	41,  // 11: ondatra.InterfaceConfig.networks:type_name -> ondatra.Network
	27,  // 12: ondatra.EthernetConfig.macsec:type_name -> ondatra.MacSec
	26,  // 13: ondatra.EthernetConfig.fec:type_name -> ondatra.Fec
	1,   // 14: ondatra.MacSec.cipher_suite:type_name -> ondatra.MacSec.CipherSuite
	28,  // 15: ondatra.MacSec.rx_sak_pool:type_name -> ondatra.RxSakPool
	75,  // 16: ondatra.MacSec.mka:type_name -> ondatra.MacSec.MKA
	5,   // 17: ondatra.ISISConfig.level:type_name -> ondatra.ISISConfig.Level
	6,   // 18: ondatra.ISISConfig.network_type:type_name -> ondatra.ISISConfig.NetworkType
	7,   // 19: ondatra.ISISConfig.auth_type:type_name -> ondatra.ISISConfig.AuthType
	7,   // 20: ondatra.ISISConfig.area_auth_type:type_name -> ondatra.ISISConfig.AuthType
	7,   // 21: ondatra.ISISConfig.domain_auth_type:type_name -> ondatra.ISISConfig.AuthType
	32,  // 22: ondatra.ISISConfig.ip_reachability:type_name -> ondatra.IPReachability
	33,  // 23: ondatra.ISISConfig.is_reachabilities:type_name -> ondatra.ISReachability
	31,  // 24: ondatra.ISISConfig.segment_routing:type_name -> ondatra.ISISSegmentRouting
	77,  // 25: ondatra.ISISSegmentRouting.adjacency_sid:type_name -> ondatra.ISISSegmentRouting.AdjacencySID
	78,  // 26: ondatra.ISISSegmentRouting.srgb_ranges:type_name -> ondatra.ISISSegmentRouting.SIDRange
	78,  // 27: ondatra.ISISSegmentRouting.srlb_ranges:type_name -> ondatra.ISISSegmentRouting.SIDRange
	8,   // 28: ondatra.IPReachability.route_origin:type_name -> ondatra.IPReachability.RouteOrigin
	79,  // 29: ondatra.ISReachability.nodes:type_name -> ondatra.ISReachability.Node
	36,  // 30: ondatra.BgpConfig.bgp_peers:type_name -> ondatra.BgpPeer
	9,   // 31: ondatra.BgpPeer.type:type_name -> ondatra.BgpPeer.Type
	82,  // 32: ondatra.BgpPeer.capabilities:type_name -> ondatra.BgpPeer.Capabilities
	83,  // 33: ondatra.BgpPeer.srte_policy_groups:type_name -> ondatra.BgpPeer.SrtePolicyGroup
	121, // 34: ondatra.BgpPeer.restart_time:type_name -> google.protobuf.Duration
	121, // 35: ondatra.BgpPeer.stale_time:type_name -> google.protobuf.Duration
	10,  // 36: ondatra.BgpAttributes.origin:type_name -> ondatra.BgpAttributes.Origin
	34,  // 37: ondatra.BgpAttributes.communities:type_name -> ondatra.BgpCommunities
	91,  // 38: ondatra.BgpAttributes.extended_communities:type_name -> ondatra.BgpAttributes.ExtendedCommunity
	0,   // 39: ondatra.BgpAttributes.asn_set_mode:type_name -> ondatra.BgpAsnSetMode
	92,  // 40: ondatra.BgpAttributes.as_path_segments:type_name -> ondatra.BgpAttributes.AsPathSegment
	72,  // 41: ondatra.BgpAttributes.originator_id:type_name -> ondatra.StringIncRange
	11,  // 42: ondatra.BgpAttributes.advertisement_protocol:type_name -> ondatra.BgpAttributes.AdvertisementProtocol
	94,  // 43: ondatra.RsvpConfig.loopbacks:type_name -> ondatra.RsvpConfig.Loopback
	71,  // 44: ondatra.DhcpV6Server.lease_addrs:type_name -> ondatra.AddressRange
	42,  // 45: ondatra.Network.eth:type_name -> ondatra.NetworkEth
	43,  // 46: ondatra.Network.ipv4:type_name -> ondatra.NetworkIp
	43,  // 47: ondatra.Network.ipv6:type_name -> ondatra.NetworkIp
	37,  // 48: ondatra.Network.bgp_attributes:type_name -> ondatra.BgpAttributes
	32,  // 49: ondatra.Network.isis:type_name -> ondatra.IPReachability
	98,  // 50: ondatra.Network.imported_bgp_routes:type_name -> ondatra.Network.ImportedBgpRoutes
	99,  // 51: ondatra.Flow.src_endpoints:type_name -> ondatra.Flow.Endpoint
	99,  // 52: ondatra.Flow.dst_endpoints:type_name -> ondatra.Flow.Endpoint
	49,  // 53: ondatra.Flow.headers:type_name -> ondatra.Header
	45,  // 54: ondatra.Flow.frame_rate:type_name -> ondatra.FrameRate
	48,  // 55: ondatra.Flow.egress_tracking:type_name -> ondatra.EgressTracking
	100, // 56: ondatra.Flow.ingress_tracking_filters:type_name -> ondatra.Flow.IngressTrackingFilters
	46,  // 57: ondatra.Flow.frame_size:type_name -> ondatra.FrameSize
	47,  // 58: ondatra.Flow.transmission:type_name -> ondatra.Transmission
	101, // 59: ondatra.FrameSize.random:type_name -> ondatra.FrameSize.Random
	15,  // 60: ondatra.FrameSize.imix_preset:type_name -> ondatra.FrameSize.ImixPreset
	103, // 61: ondatra.FrameSize.imix_custom:type_name -> ondatra.FrameSize.ImixCustom
	16,  // 62: ondatra.Transmission.pattern:type_name -> ondatra.Transmission.Pattern
	50,  // 63: ondatra.Header.eth:type_name -> ondatra.EthernetHeader
	51,  // 64: ondatra.Header.gre:type_name -> ondatra.GreHeader
	52,  // 65: ondatra.Header.ipv4:type_name -> ondatra.Ipv4Header
	53,  // 66: ondatra.Header.ipv6:type_name -> ondatra.Ipv6Header
	54,  // 67: ondatra.Header.mpls:type_name -> ondatra.MplsHeader
	56,  // 68: ondatra.Header.tcp:type_name -> ondatra.TcpHeader
	57,  // 69: ondatra.Header.udp:type_name -> ondatra.UdpHeader
	58,  // 70: ondatra.Header.http:type_name -> ondatra.HttpHeader
	59,  // 71: ondatra.Header.icmp:type_name -> ondatra.IcmpHeader
	60,  // 72: ondatra.Header.ospf:type_name -> ondatra.OspfHeader
	61,  // 73: ondatra.Header.rsvp:type_name -> ondatra.RsvpHeader
	62,  // 74: ondatra.Header.pim:type_name -> ondatra.PimHeader
	63,  // 75: ondatra.Header.ldp:type_name -> ondatra.LdpHeader
	66,  // 76: ondatra.Header.macsec:type_name -> ondatra.MacsecHeader
	64,  // 77: ondatra.Header.esp:type_name -> ondatra.EspHeader
	65,  // 78: ondatra.Header.esp_over_macsec:type_name -> ondatra.EspOverMacSecHeader
	55,  // 79: ondatra.Header.pw_mpls_control_word:type_name -> ondatra.PwMplsControlWordHeader
	71,  // 80: ondatra.EthernetHeader.src_addr:type_name -> ondatra.AddressRange
	71,  // 81: ondatra.EthernetHeader.dst_addr:type_name -> ondatra.AddressRange
	71,  // 82: ondatra.Ipv4Header.src_addr:type_name -> ondatra.AddressRange
	71,  // 83: ondatra.Ipv4Header.dst_addr:type_name -> ondatra.AddressRange
	71,  // 84: ondatra.Ipv6Header.src_addr:type_name -> ondatra.AddressRange
	71,  // 85: ondatra.Ipv6Header.dst_addr:type_name -> ondatra.AddressRange
	70,  // 86: ondatra.Ipv6Header.flow_label:type_name -> ondatra.UIntRange
	70,  // 87: ondatra.MplsHeader.label:type_name -> ondatra.UIntRange
	70,  // 88: ondatra.TcpHeader.src_port:type_name -> ondatra.UIntRange
	70,  // 89: ondatra.TcpHeader.dst_port:type_name -> ondatra.UIntRange
	70,  // 90: ondatra.UdpHeader.src_port:type_name -> ondatra.UIntRange
	70,  // 91: ondatra.UdpHeader.dst_port:type_name -> ondatra.UIntRange
	104, // 92: ondatra.IcmpHeader.echo_reply:type_name -> ondatra.IcmpHeader.EchoReply
	105, // 93: ondatra.IcmpHeader.destination_unreachable:type_name -> ondatra.IcmpHeader.DestinationUnreachable
	106, // 94: ondatra.IcmpHeader.redirect_message:type_name -> ondatra.IcmpHeader.RedirectMessage
	107, // 95: ondatra.IcmpHeader.echo_request:type_name -> ondatra.IcmpHeader.EchoRequest
	108, // 96: ondatra.IcmpHeader.time_exceeded:type_name -> ondatra.IcmpHeader.TimeExceeded
	109, // 97: ondatra.IcmpHeader.parameter_problem:type_name -> ondatra.IcmpHeader.ParameterProblem
	110, // 98: ondatra.IcmpHeader.timestamp:type_name -> ondatra.IcmpHeader.Timestamp
	111, // 99: ondatra.IcmpHeader.timestamp_reply:type_name -> ondatra.IcmpHeader.TimestampReply
	112, // 100: ondatra.OspfHeader.hello:type_name -> ondatra.OspfHeader.Hello
	113, // 101: ondatra.OspfHeader.dbd:type_name -> ondatra.OspfHeader.DatabaseDescription
	114, // 102: ondatra.OspfHeader.lsr:type_name -> ondatra.OspfHeader.LinkStateRequest
	116, // 103: ondatra.OspfHeader.lsu:type_name -> ondatra.OspfHeader.LinkStateUpdate
	117, // 104: ondatra.OspfHeader.lsa:type_name -> ondatra.OspfHeader.LinkStateAck
	21,  // 105: ondatra.RsvpHeader.message_type:type_name -> ondatra.RsvpHeader.MessageType
	119, // 106: ondatra.PimHeader.hello:type_name -> ondatra.PimHeader.Hello
	120, // 107: ondatra.LdpHeader.hello:type_name -> ondatra.LdpHeader.Hello
	70,  // 108: ondatra.EspHeader.sequence_number:type_name -> ondatra.UIntRange
	70,  // 109: ondatra.EspOverMacSecHeader.sequence_number:type_name -> ondatra.UIntRange
	68,  // 110: ondatra.IpAddressGenerator.list:type_name -> ondatra.IpAddressList
	69,  // 111: ondatra.IpAddressGenerator.random:type_name -> ondatra.IpAddressRandom
	2,   // 112: ondatra.MacSec.MKA.capability:type_name -> ondatra.MacSec.MKA.Capability
	3,   // 113: ondatra.MacSec.MKA.confidentiality_offset:type_name -> ondatra.MacSec.MKA.ConfidentialityOffset
	1,   // 114: ondatra.MacSec.MKA.cipher_suite:type_name -> ondatra.MacSec.CipherSuite
	4,   // 115: ondatra.MacSec.MKA.key_derivation_function:type_name -> ondatra.MacSec.MKA.KeyDerivationFunction
	76,  // 116: ondatra.MacSec.MKA.connectivity_association:type_name -> ondatra.MacSec.MKA.ConnectivityAssociation
	80,  // 117: ondatra.ISReachability.Node.links:type_name -> ondatra.ISReachability.Node.Link
	31,  // 118: ondatra.ISReachability.Node.segment_routing:type_name -> ondatra.ISISSegmentRouting
	81,  // 119: ondatra.ISReachability.Node.routes_ipv4:type_name -> ondatra.ISReachability.Node.Routes
	81,  // 120: ondatra.ISReachability.Node.routes_ipv6:type_name -> ondatra.ISReachability.Node.Routes
	32,  // 121: ondatra.ISReachability.Node.Routes.reachability:type_name -> ondatra.IPReachability
	73,  // 122: ondatra.BgpPeer.SrtePolicyGroup.policy_color:type_name -> ondatra.UInt32IncRange
	72,  // 123: ondatra.BgpPeer.SrtePolicyGroup.originator_id:type_name -> ondatra.StringIncRange
	34,  // 124: ondatra.BgpPeer.SrtePolicyGroup.communities:type_name -> ondatra.BgpCommunities
	0,   // 125: ondatra.BgpPeer.SrtePolicyGroup.asn_set_mode:type_name -> ondatra.BgpAsnSetMode
	84,  // 126: ondatra.BgpPeer.SrtePolicyGroup.preference:type_name -> ondatra.BgpPeer.SrtePolicyGroup.Preference
	85,  // 127: ondatra.BgpPeer.SrtePolicyGroup.binding:type_name -> ondatra.BgpPeer.SrtePolicyGroup.Binding
	86,  // 128: ondatra.BgpPeer.SrtePolicyGroup.segment_lists:type_name -> ondatra.BgpPeer.SrtePolicyGroup.SegmentList
	87,  // 129: ondatra.BgpPeer.SrtePolicyGroup.enlp:type_name -> ondatra.BgpPeer.SrtePolicyGroup.Enlp
	122, // 130: ondatra.BgpPeer.SrtePolicyGroup.Binding.no_binding:type_name -> google.protobuf.Empty
	73,  // 131: ondatra.BgpPeer.SrtePolicyGroup.Binding.four_octet_sid:type_name -> ondatra.UInt32IncRange
	73,  // 132: ondatra.BgpPeer.SrtePolicyGroup.Binding.four_octet_sid_as_mpls_label:type_name -> ondatra.UInt32IncRange
	88,  // 133: ondatra.BgpPeer.SrtePolicyGroup.SegmentList.weight:type_name -> ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Weight
	89,  // 134: ondatra.BgpPeer.SrtePolicyGroup.SegmentList.segments:type_name -> ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Segment
	90,  // 135: ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Segment.mpls_sid:type_name -> ondatra.BgpPeer.SrtePolicyGroup.SegmentList.Segment.MplsSid
	93,  // 136: ondatra.BgpAttributes.ExtendedCommunity.color:type_name -> ondatra.BgpAttributes.ExtendedCommunity.Color
	13,  // 137: ondatra.BgpAttributes.AsPathSegment.type:type_name -> ondatra.BgpAttributes.AsPathSegment.Type
	12,  // 138: ondatra.BgpAttributes.ExtendedCommunity.Color.co_bits:type_name -> ondatra.BgpAttributes.ExtendedCommunity.Color.CoBits
	95,  // 139: ondatra.RsvpConfig.Loopback.ingress_lsps:type_name -> ondatra.RsvpConfig.Loopback.IngressLSP
	96,  // 140: ondatra.RsvpConfig.Loopback.IngressLSP.eros:type_name -> ondatra.RsvpConfig.Loopback.IngressLSP.ERO
	97,  // 141: ondatra.RsvpConfig.Loopback.IngressLSP.rros:type_name -> ondatra.RsvpConfig.Loopback.IngressLSP.RRO
	14,  // 142: ondatra.Network.ImportedBgpRoutes.route_table_format:type_name -> ondatra.Network.ImportedBgpRoutes.RouteTableFormat
	102, // 143: ondatra.FrameSize.ImixCustom.entries:type_name -> ondatra.FrameSize.ImixCustomEntry
	17,  // 144: ondatra.IcmpHeader.DestinationUnreachable.code:type_name -> ondatra.IcmpHeader.DestinationUnreachable.Code
	18,  // 145: ondatra.IcmpHeader.RedirectMessage.code:type_name -> ondatra.IcmpHeader.RedirectMessage.Code
	19,  // 146: ondatra.IcmpHeader.TimeExceeded.code:type_name -> ondatra.IcmpHeader.TimeExceeded.Code
	20,  // 147: ondatra.OspfHeader.LinkStateRequest.type:type_name -> ondatra.OspfHeader.LinkStateType
	20,  // 148: ondatra.OspfHeader.LinkStateAdvertisementHeader.type:type_name -> ondatra.OspfHeader.LinkStateType
	118, // 149: ondatra.OspfHeader.LinkStateUpdate.advertisements:type_name -> ondatra.OspfHeader.LinkStateUpdate.Advertisement
	115, // 150: ondatra.OspfHeader.LinkStateAck.headers:type_name -> ondatra.OspfHeader.LinkStateAdvertisementHeader
	115, // 151: ondatra.OspfHeader.LinkStateUpdate.Advertisement.header:type_name -> ondatra.OspfHeader.LinkStateAdvertisementHeader
	152, // [152:152] is the sub-list for method output_type
	152, // [152:152] is the sub-list for method input_type
	152, // [152:152] is the sub-list for extension type_name
	152, // [152:152] is the sub-list for extension extendee
	0,   // [0:152] is the sub-list for field type_name
}

func init() { file_ate_proto_init() }
func file_ate_proto_init() {
	if File_ate_proto != nil {
		return
	}
	file_ate_proto_msgTypes[2].OneofWrappers = []any{
		(*InterfaceConfig_Port)(nil),
		(*InterfaceConfig_Lag)(nil),
	}
	file_ate_proto_msgTypes[23].OneofWrappers = []any{
		(*FrameRate_Percent)(nil),
		(*FrameRate_Bps)(nil),
		(*FrameRate_Fps)(nil),
	}
	file_ate_proto_msgTypes[24].OneofWrappers = []any{
		(*FrameSize_Fixed)(nil),
		(*FrameSize_Random_)(nil),
		(*FrameSize_ImixPreset_)(nil),
		(*FrameSize_ImixCustom_)(nil),
	}
	file_ate_proto_msgTypes[25].OneofWrappers = []any{
		(*Transmission_Nanoseconds)(nil),
		(*Transmission_Bytes)(nil),
	}
	file_ate_proto_msgTypes[27].OneofWrappers = []any{
		(*Header_Eth)(nil),
		(*Header_Gre)(nil),
		(*Header_Ipv4)(nil),
		(*Header_Ipv6)(nil),
		(*Header_Mpls)(nil),
		(*Header_Tcp)(nil),
		(*Header_Udp)(nil),
		(*Header_Http)(nil),
		(*Header_Icmp)(nil),
		(*Header_Ospf)(nil),
		(*Header_Rsvp)(nil),
		(*Header_Pim)(nil),
		(*Header_Ldp)(nil),
		(*Header_Macsec)(nil),
		(*Header_Esp)(nil),
		(*Header_EspOverMacsec)(nil),
		(*Header_PwMplsControlWord)(nil),
	}
	file_ate_proto_msgTypes[30].OneofWrappers = []any{}
	file_ate_proto_msgTypes[31].OneofWrappers = []any{}
	file_ate_proto_msgTypes[37].OneofWrappers = []any{
		(*IcmpHeader_EchoReply_)(nil),
		(*IcmpHeader_DestinationUnreachable_)(nil),
		(*IcmpHeader_RedirectMessage_)(nil),
		(*IcmpHeader_EchoRequest_)(nil),
		(*IcmpHeader_TimeExceeded_)(nil),
		(*IcmpHeader_ParameterProblem_)(nil),
		(*IcmpHeader_Timestamp_)(nil),
		(*IcmpHeader_TimestampReply_)(nil),
	}
	file_ate_proto_msgTypes[38].OneofWrappers = []any{
		(*OspfHeader_Hello_)(nil),
		(*OspfHeader_Dbd)(nil),
		(*OspfHeader_Lsr)(nil),
		(*OspfHeader_Lsu)(nil),
		(*OspfHeader_Lsa)(nil),
	}
	file_ate_proto_msgTypes[40].OneofWrappers = []any{
		(*PimHeader_Hello_)(nil),
	}
	file_ate_proto_msgTypes[41].OneofWrappers = []any{
		(*LdpHeader_Hello_)(nil),
	}
	file_ate_proto_msgTypes[45].OneofWrappers = []any{
		(*IpAddressGenerator_List)(nil),
		(*IpAddressGenerator_Random)(nil),
	}
	file_ate_proto_msgTypes[63].OneofWrappers = []any{
		(*BgpPeer_SrtePolicyGroup_Binding_NoBinding)(nil),
		(*BgpPeer_SrtePolicyGroup_Binding_FourOctetSid)(nil),
		(*BgpPeer_SrtePolicyGroup_Binding_FourOctetSidAsMplsLabel)(nil),
		(*BgpPeer_SrtePolicyGroup_Binding_Ipv6Sid)(nil),
	}
	file_ate_proto_msgTypes[67].OneofWrappers = []any{
		(*BgpPeer_SrtePolicyGroup_SegmentList_Segment_MplsSid_)(nil),
		(*BgpPeer_SrtePolicyGroup_SegmentList_Segment_Ipv6Sid)(nil),
	}
	file_ate_proto_msgTypes[69].OneofWrappers = []any{
		(*BgpAttributes_ExtendedCommunity_Color_)(nil),
	}
	file_ate_proto_msgTypes[77].OneofWrappers = []any{
		(*Flow_Endpoint_NetworkName)(nil),
		(*Flow_Endpoint_RsvpName)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_ate_proto_rawDesc), len(file_ate_proto_rawDesc)),
			NumEnums:      22,
			NumMessages:   99,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_ate_proto_goTypes,
		DependencyIndexes: file_ate_proto_depIdxs,
		EnumInfos:         file_ate_proto_enumTypes,
		MessageInfos:      file_ate_proto_msgTypes,
	}.Build()
	File_ate_proto = out.File
	file_ate_proto_goTypes = nil
	file_ate_proto_depIdxs = nil
}
